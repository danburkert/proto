#![feature(prelude_import)]
#![allow(clippy::cognitive_complexity, clippy::module_inception,
clippy::unreadable_literal)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

#[macro_use]
extern crate cfg_if;

extern crate alloc;


pub mod decode_error {




    // Must be `pub` as doc tests are only executed on public types.




















    // Try to decode a message from the data. If decoding fails, continue.


    // TODO: Reenable this once sign-extension in negative int32s is figured out.
    // assert!(encoded_len <= data.len(), "encoded_len: {}, len: {}, all_types: {:?}",
    //         encoded_len, data.len(), all_types);




    /*
    // Useful for debugging:
    eprintln!(" data: {:?}", data.iter().map(|x| format!("0x{:x}", x)).collect::<Vec<_>>());
    eprintln!(" buf1: {:?}", buf1.iter().map(|x| format!("0x{:x}", x)).collect::<Vec<_>>());
    eprintln!("a: {:?}\nb: {:?}", all_types, roundtrip);
    */













    // Some selected encoded messages, mostly collected from failed fuzz runs.
    // optional_int32: -1
    // repeated_bool: [true, true]
    // oneof_double: nan
    // optional_float: -0.0
    // optional_value: nan




    // Test enum ident conversion.


    // We abuse the ident conversion protobuf for the custom attribute additions. We placed
    // `Ord` on the FooBarBaz (which is not implemented by ordinary messages).
    // Similar, but for oneof fields























    // Checks that skip_field will error appropriately when given a big stack of StartGroup
    // tags. When the no-recursion-limit feature is enabled this results in stack overflow.
    //
    // https://github.com/tokio-rs/prost/issues/267












    // optional group



    // skip group while decoding
    // start group (tag=1)
    // unused int32 (tag=6)
    // unused group (tag=5)
    // int32 (tag=2)
    // end group (tag=1)

    // repeated group










    #![cfg(test)]
    use alloc::{boxed::Box, string::ToString, vec::Vec};
    use prost::Message;
    use protobuf::test_messages::proto3::TestAllTypesProto3;
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_invalid_wire_type"]
    #[doc(hidden)]
    pub const test_decode_error_invalid_wire_type: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_invalid_wire_type"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 8usize,
                start_col: 4usize,
                end_line: 8usize,
                end_col: 39usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_invalid_wire_type())),
        };
    fn test_decode_error_invalid_wire_type() {
        let msg = [0x36].as_slice();
        match (&TestAllTypesProto3::decode(msg).unwrap_err().to_string(),
                &"failed to decode Protobuf message: invalid wire type value: 6")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_invalid_varint"]
    #[doc(hidden)]
    pub const test_decode_error_invalid_varint: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_invalid_varint"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 17usize,
                start_col: 4usize,
                end_line: 17usize,
                end_col: 36usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_invalid_varint())),
        };
    fn test_decode_error_invalid_varint() {
        let msg =
            [0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF].as_slice();
        match (&TestAllTypesProto3::decode(msg).unwrap_err().to_string(),
                &"failed to decode Protobuf message: TestAllTypesProto3.optional_int32: invalid varint")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_multiple_levels"]
    #[doc(hidden)]
    pub const test_decode_error_multiple_levels: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_multiple_levels"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 26usize,
                start_col: 4usize,
                end_line: 26usize,
                end_col: 37usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_multiple_levels())),
        };
    fn test_decode_error_multiple_levels() {
        use protobuf::test_messages::proto3::ForeignMessage;
        let msg =
            TestAllTypesProto3 {
                recursive_message: Some(Box::new(TestAllTypesProto3 {
                            optional_foreign_message: Some(ForeignMessage { c: -1 }),
                            ..Default::default()
                        })),
                ..Default::default()
            };
        let mut buf = msg.encode_to_vec();
        match (&buf.last().unwrap(), &&0x01) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        *buf.last_mut().unwrap() = 0xFF;
        match (&TestAllTypesProto3::decode(buf.as_slice()).unwrap_err().to_string(),
                &"failed to decode Protobuf message: ForeignMessage.c: TestAllTypesProto3.optional_foreign_message: TestAllTypesProto3.recursive_message: invalid varint")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker =
    "decode_error::test_decode_error_recursion_limit_reached"]
    #[doc(hidden)]
    pub const test_decode_error_recursion_limit_reached: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_recursion_limit_reached"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 60usize,
                start_col: 4usize,
                end_line: 60usize,
                end_col: 45usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_recursion_limit_reached())),
        };
    fn test_decode_error_recursion_limit_reached() {
        let recursve_message =
            {
                let mut msg = TestAllTypesProto3::default();
                for _ in 0..101 {
                    msg =
                        TestAllTypesProto3 {
                            recursive_message: Some(Box::new(msg)),
                            ..Default::default()
                        };
                }
                msg
            };
        let buf = recursve_message.encode_to_vec();
        match (&TestAllTypesProto3::decode(buf.as_slice()).unwrap_err().to_string(),
                &"failed to decode Protobuf message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: TestAllTypesProto3.recursive_message: recursion limit reached")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_invalid_key_value"]
    #[doc(hidden)]
    pub const test_decode_error_invalid_key_value: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_invalid_key_value"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 80usize,
                start_col: 4usize,
                end_line: 80usize,
                end_col: 39usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_invalid_key_value())),
        };
    fn test_decode_error_invalid_key_value() {
        let msg = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01].as_slice();
        match (&TestAllTypesProto3::decode(msg).unwrap_err().to_string(),
                &"failed to decode Protobuf message: invalid key value: 1125899906842623")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_invalid_tag"]
    #[doc(hidden)]
    pub const test_decode_error_invalid_tag: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_invalid_tag"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 89usize,
                start_col: 4usize,
                end_line: 89usize,
                end_col: 33usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_invalid_tag())),
        };
    fn test_decode_error_invalid_tag() {
        let msg = [0x00].as_slice();
        match (&TestAllTypesProto3::decode(msg).unwrap_err().to_string(),
                &"failed to decode Protobuf message: invalid tag value: 0") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker =
    "decode_error::test_decode_error_unexpected_wire_type"]
    #[doc(hidden)]
    pub const test_decode_error_unexpected_wire_type: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_unexpected_wire_type"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 98usize,
                start_col: 4usize,
                end_line: 98usize,
                end_col: 42usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_unexpected_wire_type())),
        };
    fn test_decode_error_unexpected_wire_type() {
        let mut buf = [0x00].as_slice();
        let mut msg = TestAllTypesProto3::default();
        let ctx = prost::encoding::DecodeContext::default();
        match (&msg.merge_field(1, prost::encoding::WireType::LengthDelimited,
                                &mut buf, ctx).unwrap_err().to_string(),
                &"failed to decode Protobuf message: TestAllTypesProto3.optional_int32: invalid wire type: LengthDelimited (expected Varint)")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_buffer_underflow"]
    #[doc(hidden)]
    pub const test_decode_error_buffer_underflow: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_buffer_underflow"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 109usize,
                start_col: 4usize,
                end_line: 109usize,
                end_col: 38usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_buffer_underflow())),
        };
    fn test_decode_error_buffer_underflow() {
        let msg = [0x12].as_slice();
        match (&TestAllTypesProto3::decode_length_delimited(msg).unwrap_err().to_string(),
                &"failed to decode Protobuf message: buffer underflow") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_invalid_string"]
    #[doc(hidden)]
    pub const test_decode_error_invalid_string: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_invalid_string"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 120usize,
                start_col: 4usize,
                end_line: 120usize,
                end_col: 36usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_invalid_string())),
        };
    fn test_decode_error_invalid_string() {
        let msg =
            TestAllTypesProto3 {
                optional_string: "Hello".to_string(),
                ..Default::default()
            };
        let mut buf = msg.encode_to_vec();
        match (&buf.last().unwrap(), &&b'o') {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        *buf.last_mut().unwrap() = 0xA0;
        match (&TestAllTypesProto3::decode(buf.as_slice()).unwrap_err().to_string(),
                &"failed to decode Protobuf message: TestAllTypesProto3.optional_string: invalid string value: data is not UTF-8 encoded")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_decode_error_any"]
    #[doc(hidden)]
    pub const test_decode_error_any: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_decode_error_any"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 138usize,
                start_col: 4usize,
                end_line: 138usize,
                end_col: 25usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_decode_error_any())),
        };
    fn test_decode_error_any() {
        use prost_types::{Any, Timestamp};
        let msg =
            Any {
                type_url: "non-existing-url".to_string(),
                value: Vec::new(),
            };
        match (&msg.to_msg::<Timestamp>().unwrap_err().to_string(),
                &"failed to decode Protobuf message: unexpected type URL.type_url: expected type URL: \"type.googleapis.com/google.protobuf.Timestamp\" (got: \"non-existing-url\")")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_push"]
    #[doc(hidden)]
    pub const test_push: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_push"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 153usize,
                start_col: 4usize,
                end_line: 153usize,
                end_col: 13usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_push())),
        };
    fn test_push() {
        let mut decode_error = prost::DecodeError::new("something failed");
        decode_error.push("Foo bad", "bar.foo");
        decode_error.push("Baz bad", "bar.baz");
        match (&decode_error.to_string(),
                &"failed to decode Protobuf message: Foo bad.bar.foo: Baz bad.bar.baz: something failed")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "decode_error::test_into_std_io_error"]
    #[doc(hidden)]
    pub const test_into_std_io_error: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("decode_error::test_into_std_io_error"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/decode_error.rs",
                start_line: 166usize,
                start_col: 4usize,
                end_line: 166usize,
                end_col: 26usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_into_std_io_error())),
        };
    #[cfg(feature = "std")]
    fn test_into_std_io_error() {
        let decode_error = prost::DecodeError::new("something failed");
        let std_io_error = std::io::Error::from(decode_error);
        match (&std_io_error.kind(), &std::io::ErrorKind::InvalidData) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&std_io_error.to_string(),
                &"failed to decode Protobuf message: something failed") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
pub mod extern_paths {
    //! Tests nested packages with `extern_path`.
    pub struct Root {}
    #[automatically_derived]
    impl ::core::clone::Clone for Root {
        #[inline]
        fn clone(&self) -> Root { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Root { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Root { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Root {
        #[inline]
        fn eq(&self, other: &Root) -> bool { true }
    }
    impl ::prost::Message for Root {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for Root {
        fn default() -> Self { Root {} }
    }
    impl ::core::fmt::Debug for Root {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Root");
            builder.finish()
        }
    }
    /// Nested message and enum types in `Root`.
    pub mod root {
        pub struct Inner {}
        #[automatically_derived]
        impl ::core::clone::Clone for Inner {
            #[inline]
            fn clone(&self) -> Inner { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Inner { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Inner { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Inner {
            #[inline]
            fn eq(&self, other: &Inner) -> bool { true }
        }
        impl ::prost::Message for Inner {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Inner {
            fn default() -> Self { Inner {} }
        }
        impl ::core::fmt::Debug for Inner {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Inner");
                builder.finish()
            }
        }
    }
    pub mod widget {
        pub struct Widget {}
        #[automatically_derived]
        impl ::core::clone::Clone for Widget {
            #[inline]
            fn clone(&self) -> Widget { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Widget { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Widget { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Widget {
            #[inline]
            fn eq(&self, other: &Widget) -> bool { true }
        }
        impl ::prost::Message for Widget {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Widget {
            fn default() -> Self { Widget {} }
        }
        impl ::core::fmt::Debug for Widget {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Widget");
                builder.finish()
            }
        }
        /// Nested message and enum types in `Widget`.
        pub mod widget {
            pub struct Inner {}
            #[automatically_derived]
            impl ::core::clone::Clone for Inner {
                #[inline]
                fn clone(&self) -> Inner { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Inner { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Inner { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Inner {
                #[inline]
                fn eq(&self, other: &Inner) -> bool { true }
            }
            impl ::prost::Message for Inner {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Inner {
                fn default() -> Self { Inner {} }
            }
            impl ::core::fmt::Debug for Inner {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Inner");
                    builder.finish()
                }
            }
            #[repr(i32)]
            pub enum Type { A = 0, B = 1, C = 2, }
            #[automatically_derived]
            impl ::core::clone::Clone for Type {
                #[inline]
                fn clone(&self) -> Type { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Type { }
            #[automatically_derived]
            impl ::core::fmt::Debug for Type {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f,
                        match self {
                            Type::A => "A",
                            Type::B => "B",
                            Type::C => "C",
                        })
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Type { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Type {
                #[inline]
                fn eq(&self, other: &Type) -> bool {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Type {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Type {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H)
                    -> () {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_discr, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Type {
                #[inline]
                fn partial_cmp(&self, other: &Type)
                    -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                        &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Type {
                #[inline]
                fn cmp(&self, other: &Type) -> ::core::cmp::Ordering {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl Type {
                #[doc = "Returns `true` if `value` is a variant of `Type`."]
                pub fn is_valid(value: i32) -> bool {
                    match value { 0 => true, 1 => true, 2 => true, _ => false, }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                #[doc =
                "Converts an `i32` to a `Type`, or `None` if `value` is not a valid variant."]
                pub fn from_i32(value: i32) -> ::core::option::Option<Type> {
                    match value {
                        0 => ::core::option::Option::Some(Type::A),
                        1 => ::core::option::Option::Some(Type::B),
                        2 => ::core::option::Option::Some(Type::C),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for Type {
                fn default() -> Type { Type::A }
            }
            impl ::core::convert::From<Type> for i32 {
                fn from(value: Type) -> i32 { value as i32 }
            }
            impl ::core::convert::TryFrom<i32> for Type {
                type Error = ::prost::UnknownEnumValue;
                fn try_from(value: i32)
                    -> ::core::result::Result<Type, ::prost::UnknownEnumValue> {
                    match value {
                        0 => ::core::result::Result::Ok(Type::A),
                        1 => ::core::result::Result::Ok(Type::B),
                        2 => ::core::result::Result::Ok(Type::C),
                        _ =>
                            ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                    }
                }
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::A => "A",
                        Self::B => "B",
                        Self::C => "C",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str)
                    -> ::core::option::Option<Self> {
                    match value {
                        "A" => Some(Self::A),
                        "B" => Some(Self::B),
                        "C" => Some(Self::C),
                        _ => None,
                    }
                }
            }
        }
        pub mod factory {
            pub struct WidgetFactory {
                #[prost(message, optional, tag = "1")]
                pub inner: ::core::option::Option<widget_factory::Inner>,
                #[prost(message, optional, tag = "2")]
                pub root: ::core::option::Option<super::super::Root>,
                #[prost(message, optional, tag = "3")]
                pub root_inner: ::core::option::Option<super::super::root::Inner>,
                #[prost(message, optional, tag = "4")]
                pub widget: ::core::option::Option<super::Widget>,
                #[prost(message, optional, tag = "5")]
                pub widget_inner: ::core::option::Option<super::widget::Inner>,
                #[prost(enumeration = "super::widget::Type", tag = "8")]
                pub widget_type: i32,
                #[prost(message, optional, tag = "6")]
                pub gizmo: ::core::option::Option<crate::packages::gizmo::Gizmo>,
                #[prost(message, optional, tag = "7")]
                pub gizmo_inner: ::core::option::Option<crate::packages::gizmo::gizmo::Inner>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for WidgetFactory {
                #[inline]
                fn clone(&self) -> WidgetFactory {
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<widget_factory::Inner>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::Root>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::root::Inner>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::Widget>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::widget::Inner>>;
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<crate::packages::gizmo::Gizmo>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<crate::packages::gizmo::gizmo::Inner>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for WidgetFactory { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for WidgetFactory { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for WidgetFactory {
                #[inline]
                fn eq(&self, other: &WidgetFactory) -> bool {
                    self.inner == other.inner && self.root == other.root &&
                                            self.root_inner == other.root_inner &&
                                        self.widget == other.widget &&
                                    self.widget_inner == other.widget_inner &&
                                self.widget_type == other.widget_type &&
                            self.gizmo == other.gizmo &&
                        self.gizmo_inner == other.gizmo_inner
                }
            }
            impl ::prost::Message for WidgetFactory {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    if let Some(ref msg) = self.inner {
                            ::prost::encoding::message::encode(1u32, msg, buf);
                        }
                    if let Some(ref msg) = self.root {
                            ::prost::encoding::message::encode(2u32, msg, buf);
                        }
                    if let Some(ref msg) = self.root_inner {
                            ::prost::encoding::message::encode(3u32, msg, buf);
                        }
                    if let Some(ref msg) = self.widget {
                            ::prost::encoding::message::encode(4u32, msg, buf);
                        }
                    if let Some(ref msg) = self.widget_inner {
                            ::prost::encoding::message::encode(5u32, msg, buf);
                        }
                    if let Some(ref msg) = self.gizmo {
                            ::prost::encoding::message::encode(6u32, msg, buf);
                        }
                    if let Some(ref msg) = self.gizmo_inner {
                            ::prost::encoding::message::encode(7u32, msg, buf);
                        }
                    if self.widget_type != super::widget::Type::default() as i32
                            {
                            ::prost::encoding::int32::encode(8u32, &self.widget_type,
                                buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    const STRUCT_NAME: &'static str = "WidgetFactory";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "inner"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.root;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "root"); error })
                        }
                        3u32 => {
                            let mut value = &mut self.root_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "root_inner"); error })
                        }
                        4u32 => {
                            let mut value = &mut self.widget;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget"); error })
                        }
                        5u32 => {
                            let mut value = &mut self.widget_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget_inner"); error })
                        }
                        6u32 => {
                            let mut value = &mut self.gizmo;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "gizmo"); error })
                        }
                        7u32 => {
                            let mut value = &mut self.gizmo_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "gizmo_inner"); error })
                        }
                        8u32 => {
                            let mut value = &mut self.widget_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget_type"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                                                    self.inner.as_ref().map_or(0,
                                                        |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                                self.root.as_ref().map_or(0,
                                                    |msg| ::prost::encoding::message::encoded_len(2u32, msg)) +
                                            self.root_inner.as_ref().map_or(0,
                                                |msg| ::prost::encoding::message::encoded_len(3u32, msg)) +
                                        self.widget.as_ref().map_or(0,
                                            |msg| ::prost::encoding::message::encoded_len(4u32, msg)) +
                                    self.widget_inner.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(5u32, msg)) +
                                self.gizmo.as_ref().map_or(0,
                                    |msg| ::prost::encoding::message::encoded_len(6u32, msg)) +
                            self.gizmo_inner.as_ref().map_or(0,
                                |msg| ::prost::encoding::message::encoded_len(7u32, msg)) +
                        if self.widget_type != super::widget::Type::default() as i32
                                {
                                ::prost::encoding::int32::encoded_len(8u32,
                                    &self.widget_type)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.inner = ::core::option::Option::None;
                    self.root = ::core::option::Option::None;
                    self.root_inner = ::core::option::Option::None;
                    self.widget = ::core::option::Option::None;
                    self.widget_inner = ::core::option::Option::None;
                    self.gizmo = ::core::option::Option::None;
                    self.gizmo_inner = ::core::option::Option::None;
                    self.widget_type = super::widget::Type::default() as i32;
                }
            }
            impl ::core::default::Default for WidgetFactory {
                fn default() -> Self {
                    WidgetFactory {
                        inner: ::core::default::Default::default(),
                        root: ::core::default::Default::default(),
                        root_inner: ::core::default::Default::default(),
                        widget: ::core::default::Default::default(),
                        widget_inner: ::core::default::Default::default(),
                        gizmo: ::core::default::Default::default(),
                        gizmo_inner: ::core::default::Default::default(),
                        widget_type: super::widget::Type::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for WidgetFactory {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("WidgetFactory");
                    let builder =
                        {
                            let wrapper = &self.inner;
                            builder.field("inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.root;
                            builder.field("root", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.root_inner;
                            builder.field("root_inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.widget;
                            builder.field("widget", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.widget_inner;
                            builder.field("widget_inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    struct ScalarWrapper<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            let res: ::core::result::Result<super::widget::Type, _> =
                                                ::core::convert::TryFrom::try_from(*self.0);
                                            match res {
                                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ScalarWrapper(&self.widget_type)
                                };
                            builder.field("widget_type", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.gizmo;
                            builder.field("gizmo", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.gizmo_inner;
                            builder.field("gizmo_inner", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl WidgetFactory {
                #[doc =
                "Returns the enum value of `widget_type`, or the default if the field is set to an invalid enum value."]
                pub fn widget_type(&self) -> super::widget::Type {
                    ::core::convert::TryFrom::try_from(self.widget_type).unwrap_or(super::widget::Type::default())
                }
                #[doc = "Sets `widget_type` to the provided enum value."]
                pub fn set_widget_type(&mut self,
                    value: super::widget::Type) {
                    self.widget_type = value as i32;
                }
            }
            /// Nested message and enum types in `WidgetFactory`.
            pub mod widget_factory {
                pub struct Inner {}
                #[automatically_derived]
                impl ::core::clone::Clone for Inner {
                    #[inline]
                    fn clone(&self) -> Inner { *self }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Inner { }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Inner { }
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Inner {
                    #[inline]
                    fn eq(&self, other: &Inner) -> bool { true }
                }
                impl ::prost::Message for Inner {
                    #[allow(unused_variables)]
                    fn encode_raw(&self,
                        buf: &mut impl ::prost::bytes::BufMut) {}
                    #[allow(unused_variables)]
                    fn merge_field(&mut self, tag: u32,
                        wire_type: ::prost::encoding::wire_type::WireType,
                        buf: &mut impl ::prost::bytes::Buf,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> {
                        match tag {
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize { 0 }
                    fn clear(&mut self) {}
                }
                impl ::core::default::Default for Inner {
                    fn default() -> Self { Inner {} }
                }
                impl ::core::fmt::Debug for Inner {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("Inner");
                        builder.finish()
                    }
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "extern_paths::test"]
    #[doc(hidden)]
    pub const test: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("extern_paths::test"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/extern_paths.rs",
                start_line: 16usize,
                start_col: 4usize,
                end_line: 16usize,
                end_col: 8usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test())),
        };
    fn test() {
        use crate::packages::gizmo;
        use crate::packages::DoIt;
        use prost::Message;
        let mut widget_factory = widget::factory::WidgetFactory::default();
        match (&0, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.inner =
            Some(widget::factory::widget_factory::Inner {});
        match (&2, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root = Some(Root {});
        match (&4, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root_inner = Some(root::Inner {});
        match (&6, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget = Some(widget::Widget {});
        match (&8, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget_inner = Some(widget::widget::Inner {});
        match (&10, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo = Some(gizmo::Gizmo {});
        match (&12, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo.as_ref().map(DoIt::do_it);
        widget_factory.gizmo_inner = Some(gizmo::gizmo::Inner {});
        match (&14, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
pub mod no_root_packages {
    //! Tests nested packages without a root package.
    pub struct Root {}
    #[automatically_derived]
    impl ::core::clone::Clone for Root {
        #[inline]
        fn clone(&self) -> Root { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Root { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Root { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Root {
        #[inline]
        fn eq(&self, other: &Root) -> bool { true }
    }
    impl ::prost::Message for Root {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for Root {
        fn default() -> Self { Root {} }
    }
    impl ::core::fmt::Debug for Root {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Root");
            builder.finish()
        }
    }
    /// Nested message and enum types in `Root`.
    pub mod root {
        pub struct Inner {}
        #[automatically_derived]
        impl ::core::clone::Clone for Inner {
            #[inline]
            fn clone(&self) -> Inner { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Inner { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Inner { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Inner {
            #[inline]
            fn eq(&self, other: &Inner) -> bool { true }
        }
        impl ::prost::Message for Inner {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Inner {
            fn default() -> Self { Inner {} }
        }
        impl ::core::fmt::Debug for Inner {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Inner");
                builder.finish()
            }
        }
    }
    pub mod gizmo {
        pub struct Gizmo {}
        #[automatically_derived]
        impl ::core::clone::Clone for Gizmo {
            #[inline]
            fn clone(&self) -> Gizmo { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Gizmo { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Gizmo { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Gizmo {
            #[inline]
            fn eq(&self, other: &Gizmo) -> bool { true }
        }
        impl ::prost::Message for Gizmo {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Gizmo {
            fn default() -> Self { Gizmo {} }
        }
        impl ::core::fmt::Debug for Gizmo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Gizmo");
                builder.finish()
            }
        }
        /// Nested message and enum types in `Gizmo`.
        pub mod gizmo {
            pub struct Inner {}
            #[automatically_derived]
            impl ::core::clone::Clone for Inner {
                #[inline]
                fn clone(&self) -> Inner { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Inner { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Inner { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Inner {
                #[inline]
                fn eq(&self, other: &Inner) -> bool { true }
            }
            impl ::prost::Message for Inner {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Inner {
                fn default() -> Self { Inner {} }
            }
            impl ::core::fmt::Debug for Inner {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Inner");
                    builder.finish()
                }
            }
        }
    }
    pub mod widget {
        pub struct Widget {}
        #[automatically_derived]
        impl ::core::clone::Clone for Widget {
            #[inline]
            fn clone(&self) -> Widget { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Widget { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Widget { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Widget {
            #[inline]
            fn eq(&self, other: &Widget) -> bool { true }
        }
        impl ::prost::Message for Widget {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Widget {
            fn default() -> Self { Widget {} }
        }
        impl ::core::fmt::Debug for Widget {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Widget");
                builder.finish()
            }
        }
        /// Nested message and enum types in `Widget`.
        pub mod widget {
            pub struct Inner {}
            #[automatically_derived]
            impl ::core::clone::Clone for Inner {
                #[inline]
                fn clone(&self) -> Inner { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Inner { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Inner { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Inner {
                #[inline]
                fn eq(&self, other: &Inner) -> bool { true }
            }
            impl ::prost::Message for Inner {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Inner {
                fn default() -> Self { Inner {} }
            }
            impl ::core::fmt::Debug for Inner {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Inner");
                    builder.finish()
                }
            }
            #[repr(i32)]
            pub enum Type { A = 0, B = 1, C = 2, }
            #[automatically_derived]
            impl ::core::clone::Clone for Type {
                #[inline]
                fn clone(&self) -> Type { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Type { }
            #[automatically_derived]
            impl ::core::fmt::Debug for Type {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f,
                        match self {
                            Type::A => "A",
                            Type::B => "B",
                            Type::C => "C",
                        })
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Type { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Type {
                #[inline]
                fn eq(&self, other: &Type) -> bool {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Type {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Type {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H)
                    -> () {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_discr, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Type {
                #[inline]
                fn partial_cmp(&self, other: &Type)
                    -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                        &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Type {
                #[inline]
                fn cmp(&self, other: &Type) -> ::core::cmp::Ordering {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl Type {
                #[doc = "Returns `true` if `value` is a variant of `Type`."]
                pub fn is_valid(value: i32) -> bool {
                    match value { 0 => true, 1 => true, 2 => true, _ => false, }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                #[doc =
                "Converts an `i32` to a `Type`, or `None` if `value` is not a valid variant."]
                pub fn from_i32(value: i32) -> ::core::option::Option<Type> {
                    match value {
                        0 => ::core::option::Option::Some(Type::A),
                        1 => ::core::option::Option::Some(Type::B),
                        2 => ::core::option::Option::Some(Type::C),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for Type {
                fn default() -> Type { Type::A }
            }
            impl ::core::convert::From<Type> for i32 {
                fn from(value: Type) -> i32 { value as i32 }
            }
            impl ::core::convert::TryFrom<i32> for Type {
                type Error = ::prost::UnknownEnumValue;
                fn try_from(value: i32)
                    -> ::core::result::Result<Type, ::prost::UnknownEnumValue> {
                    match value {
                        0 => ::core::result::Result::Ok(Type::A),
                        1 => ::core::result::Result::Ok(Type::B),
                        2 => ::core::result::Result::Ok(Type::C),
                        _ =>
                            ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                    }
                }
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::A => "A",
                        Self::B => "B",
                        Self::C => "C",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str)
                    -> ::core::option::Option<Self> {
                    match value {
                        "A" => Some(Self::A),
                        "B" => Some(Self::B),
                        "C" => Some(Self::C),
                        _ => None,
                    }
                }
            }
        }
        pub mod factory {
            pub struct WidgetFactory {
                #[prost(message, optional, tag = "1")]
                pub inner: ::core::option::Option<widget_factory::Inner>,
                #[prost(message, optional, tag = "2")]
                pub root: ::core::option::Option<super::super::Root>,
                #[prost(message, optional, tag = "3")]
                pub root_inner: ::core::option::Option<super::super::root::Inner>,
                #[prost(message, optional, tag = "4")]
                pub widget: ::core::option::Option<super::Widget>,
                #[prost(message, optional, tag = "5")]
                pub widget_inner: ::core::option::Option<super::widget::Inner>,
                #[prost(enumeration = "super::widget::Type", tag = "8")]
                pub widget_type: i32,
                #[prost(message, optional, tag = "6")]
                pub gizmo: ::core::option::Option<super::super::gizmo::Gizmo>,
                #[prost(message, optional, tag = "7")]
                pub gizmo_inner: ::core::option::Option<super::super::gizmo::gizmo::Inner>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for WidgetFactory {
                #[inline]
                fn clone(&self) -> WidgetFactory {
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<widget_factory::Inner>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::Root>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::root::Inner>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::Widget>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::widget::Inner>>;
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::gizmo::Gizmo>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::gizmo::gizmo::Inner>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for WidgetFactory { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for WidgetFactory { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for WidgetFactory {
                #[inline]
                fn eq(&self, other: &WidgetFactory) -> bool {
                    self.inner == other.inner && self.root == other.root &&
                                            self.root_inner == other.root_inner &&
                                        self.widget == other.widget &&
                                    self.widget_inner == other.widget_inner &&
                                self.widget_type == other.widget_type &&
                            self.gizmo == other.gizmo &&
                        self.gizmo_inner == other.gizmo_inner
                }
            }
            impl ::prost::Message for WidgetFactory {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    if let Some(ref msg) = self.inner {
                            ::prost::encoding::message::encode(1u32, msg, buf);
                        }
                    if let Some(ref msg) = self.root {
                            ::prost::encoding::message::encode(2u32, msg, buf);
                        }
                    if let Some(ref msg) = self.root_inner {
                            ::prost::encoding::message::encode(3u32, msg, buf);
                        }
                    if let Some(ref msg) = self.widget {
                            ::prost::encoding::message::encode(4u32, msg, buf);
                        }
                    if let Some(ref msg) = self.widget_inner {
                            ::prost::encoding::message::encode(5u32, msg, buf);
                        }
                    if let Some(ref msg) = self.gizmo {
                            ::prost::encoding::message::encode(6u32, msg, buf);
                        }
                    if let Some(ref msg) = self.gizmo_inner {
                            ::prost::encoding::message::encode(7u32, msg, buf);
                        }
                    if self.widget_type != super::widget::Type::default() as i32
                            {
                            ::prost::encoding::int32::encode(8u32, &self.widget_type,
                                buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    const STRUCT_NAME: &'static str = "WidgetFactory";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "inner"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.root;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "root"); error })
                        }
                        3u32 => {
                            let mut value = &mut self.root_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "root_inner"); error })
                        }
                        4u32 => {
                            let mut value = &mut self.widget;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget"); error })
                        }
                        5u32 => {
                            let mut value = &mut self.widget_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget_inner"); error })
                        }
                        6u32 => {
                            let mut value = &mut self.gizmo;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "gizmo"); error })
                        }
                        7u32 => {
                            let mut value = &mut self.gizmo_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "gizmo_inner"); error })
                        }
                        8u32 => {
                            let mut value = &mut self.widget_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget_type"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                                                    self.inner.as_ref().map_or(0,
                                                        |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                                self.root.as_ref().map_or(0,
                                                    |msg| ::prost::encoding::message::encoded_len(2u32, msg)) +
                                            self.root_inner.as_ref().map_or(0,
                                                |msg| ::prost::encoding::message::encoded_len(3u32, msg)) +
                                        self.widget.as_ref().map_or(0,
                                            |msg| ::prost::encoding::message::encoded_len(4u32, msg)) +
                                    self.widget_inner.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(5u32, msg)) +
                                self.gizmo.as_ref().map_or(0,
                                    |msg| ::prost::encoding::message::encoded_len(6u32, msg)) +
                            self.gizmo_inner.as_ref().map_or(0,
                                |msg| ::prost::encoding::message::encoded_len(7u32, msg)) +
                        if self.widget_type != super::widget::Type::default() as i32
                                {
                                ::prost::encoding::int32::encoded_len(8u32,
                                    &self.widget_type)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.inner = ::core::option::Option::None;
                    self.root = ::core::option::Option::None;
                    self.root_inner = ::core::option::Option::None;
                    self.widget = ::core::option::Option::None;
                    self.widget_inner = ::core::option::Option::None;
                    self.gizmo = ::core::option::Option::None;
                    self.gizmo_inner = ::core::option::Option::None;
                    self.widget_type = super::widget::Type::default() as i32;
                }
            }
            impl ::core::default::Default for WidgetFactory {
                fn default() -> Self {
                    WidgetFactory {
                        inner: ::core::default::Default::default(),
                        root: ::core::default::Default::default(),
                        root_inner: ::core::default::Default::default(),
                        widget: ::core::default::Default::default(),
                        widget_inner: ::core::default::Default::default(),
                        gizmo: ::core::default::Default::default(),
                        gizmo_inner: ::core::default::Default::default(),
                        widget_type: super::widget::Type::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for WidgetFactory {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("WidgetFactory");
                    let builder =
                        {
                            let wrapper = &self.inner;
                            builder.field("inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.root;
                            builder.field("root", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.root_inner;
                            builder.field("root_inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.widget;
                            builder.field("widget", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.widget_inner;
                            builder.field("widget_inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    struct ScalarWrapper<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            let res: ::core::result::Result<super::widget::Type, _> =
                                                ::core::convert::TryFrom::try_from(*self.0);
                                            match res {
                                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ScalarWrapper(&self.widget_type)
                                };
                            builder.field("widget_type", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.gizmo;
                            builder.field("gizmo", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.gizmo_inner;
                            builder.field("gizmo_inner", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl WidgetFactory {
                #[doc =
                "Returns the enum value of `widget_type`, or the default if the field is set to an invalid enum value."]
                pub fn widget_type(&self) -> super::widget::Type {
                    ::core::convert::TryFrom::try_from(self.widget_type).unwrap_or(super::widget::Type::default())
                }
                #[doc = "Sets `widget_type` to the provided enum value."]
                pub fn set_widget_type(&mut self,
                    value: super::widget::Type) {
                    self.widget_type = value as i32;
                }
            }
            /// Nested message and enum types in `WidgetFactory`.
            pub mod widget_factory {
                pub struct Inner {}
                #[automatically_derived]
                impl ::core::clone::Clone for Inner {
                    #[inline]
                    fn clone(&self) -> Inner { *self }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Inner { }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Inner { }
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Inner {
                    #[inline]
                    fn eq(&self, other: &Inner) -> bool { true }
                }
                impl ::prost::Message for Inner {
                    #[allow(unused_variables)]
                    fn encode_raw(&self,
                        buf: &mut impl ::prost::bytes::BufMut) {}
                    #[allow(unused_variables)]
                    fn merge_field(&mut self, tag: u32,
                        wire_type: ::prost::encoding::wire_type::WireType,
                        buf: &mut impl ::prost::bytes::Buf,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> {
                        match tag {
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize { 0 }
                    fn clear(&mut self) {}
                }
                impl ::core::default::Default for Inner {
                    fn default() -> Self { Inner {} }
                }
                impl ::core::fmt::Debug for Inner {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("Inner");
                        builder.finish()
                    }
                }
            }
        }
    }
    pub mod generated_include {
        pub struct Root {}
        #[automatically_derived]
        impl ::core::clone::Clone for Root {
            #[inline]
            fn clone(&self) -> Root { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Root { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Root { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Root {
            #[inline]
            fn eq(&self, other: &Root) -> bool { true }
        }
        impl ::prost::Message for Root {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Root {
            fn default() -> Self { Root {} }
        }
        impl ::core::fmt::Debug for Root {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Root");
                builder.finish()
            }
        }
        /// Nested message and enum types in `Root`.
        pub mod root {
            pub struct Inner {}
            #[automatically_derived]
            impl ::core::clone::Clone for Inner {
                #[inline]
                fn clone(&self) -> Inner { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Inner { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Inner { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Inner {
                #[inline]
                fn eq(&self, other: &Inner) -> bool { true }
            }
            impl ::prost::Message for Inner {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Inner {
                fn default() -> Self { Inner {} }
            }
            impl ::core::fmt::Debug for Inner {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Inner");
                    builder.finish()
                }
            }
        }
        pub mod gizmo {
            pub struct Gizmo {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gizmo {
                #[inline]
                fn clone(&self) -> Gizmo { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gizmo { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gizmo { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gizmo {
                #[inline]
                fn eq(&self, other: &Gizmo) -> bool { true }
            }
            impl ::prost::Message for Gizmo {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Gizmo {
                fn default() -> Self { Gizmo {} }
            }
            impl ::core::fmt::Debug for Gizmo {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Gizmo");
                    builder.finish()
                }
            }
            /// Nested message and enum types in `Gizmo`.
            pub mod gizmo {
                pub struct Inner {}
                #[automatically_derived]
                impl ::core::clone::Clone for Inner {
                    #[inline]
                    fn clone(&self) -> Inner { *self }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Inner { }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Inner { }
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Inner {
                    #[inline]
                    fn eq(&self, other: &Inner) -> bool { true }
                }
                impl ::prost::Message for Inner {
                    #[allow(unused_variables)]
                    fn encode_raw(&self,
                        buf: &mut impl ::prost::bytes::BufMut) {}
                    #[allow(unused_variables)]
                    fn merge_field(&mut self, tag: u32,
                        wire_type: ::prost::encoding::wire_type::WireType,
                        buf: &mut impl ::prost::bytes::Buf,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> {
                        match tag {
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize { 0 }
                    fn clear(&mut self) {}
                }
                impl ::core::default::Default for Inner {
                    fn default() -> Self { Inner {} }
                }
                impl ::core::fmt::Debug for Inner {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("Inner");
                        builder.finish()
                    }
                }
            }
        }
        pub mod widget {
            pub struct Widget {}
            #[automatically_derived]
            impl ::core::clone::Clone for Widget {
                #[inline]
                fn clone(&self) -> Widget { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Widget { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Widget { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Widget {
                #[inline]
                fn eq(&self, other: &Widget) -> bool { true }
            }
            impl ::prost::Message for Widget {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Widget {
                fn default() -> Self { Widget {} }
            }
            impl ::core::fmt::Debug for Widget {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Widget");
                    builder.finish()
                }
            }
            /// Nested message and enum types in `Widget`.
            pub mod widget {
                pub struct Inner {}
                #[automatically_derived]
                impl ::core::clone::Clone for Inner {
                    #[inline]
                    fn clone(&self) -> Inner { *self }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Inner { }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Inner { }
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Inner {
                    #[inline]
                    fn eq(&self, other: &Inner) -> bool { true }
                }
                impl ::prost::Message for Inner {
                    #[allow(unused_variables)]
                    fn encode_raw(&self,
                        buf: &mut impl ::prost::bytes::BufMut) {}
                    #[allow(unused_variables)]
                    fn merge_field(&mut self, tag: u32,
                        wire_type: ::prost::encoding::wire_type::WireType,
                        buf: &mut impl ::prost::bytes::Buf,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> {
                        match tag {
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize { 0 }
                    fn clear(&mut self) {}
                }
                impl ::core::default::Default for Inner {
                    fn default() -> Self { Inner {} }
                }
                impl ::core::fmt::Debug for Inner {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("Inner");
                        builder.finish()
                    }
                }
                #[repr(i32)]
                pub enum Type { A = 0, B = 1, C = 2, }
                #[automatically_derived]
                impl ::core::clone::Clone for Type {
                    #[inline]
                    fn clone(&self) -> Type { *self }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Type { }
                #[automatically_derived]
                impl ::core::fmt::Debug for Type {
                    #[inline]
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f,
                            match self {
                                Type::A => "A",
                                Type::B => "B",
                                Type::C => "C",
                            })
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Type { }
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Type {
                    #[inline]
                    fn eq(&self, other: &Type) -> bool {
                        let __self_discr =
                            ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr =
                            ::core::intrinsics::discriminant_value(other);
                        __self_discr == __arg1_discr
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for Type {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                #[automatically_derived]
                impl ::core::hash::Hash for Type {
                    #[inline]
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H)
                        -> () {
                        let __self_discr =
                            ::core::intrinsics::discriminant_value(self);
                        ::core::hash::Hash::hash(&__self_discr, state)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for Type {
                    #[inline]
                    fn partial_cmp(&self, other: &Type)
                        -> ::core::option::Option<::core::cmp::Ordering> {
                        let __self_discr =
                            ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr =
                            ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                            &__arg1_discr)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for Type {
                    #[inline]
                    fn cmp(&self, other: &Type) -> ::core::cmp::Ordering {
                        let __self_discr =
                            ::core::intrinsics::discriminant_value(self);
                        let __arg1_discr =
                            ::core::intrinsics::discriminant_value(other);
                        ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                    }
                }
                impl Type {
                    #[doc = "Returns `true` if `value` is a variant of `Type`."]
                    pub fn is_valid(value: i32) -> bool {
                        match value { 0 => true, 1 => true, 2 => true, _ => false, }
                    }
                    #[deprecated =
                    "Use the TryFrom<i32> implementation instead"]
                    #[doc =
                    "Converts an `i32` to a `Type`, or `None` if `value` is not a valid variant."]
                    pub fn from_i32(value: i32)
                        -> ::core::option::Option<Type> {
                        match value {
                            0 => ::core::option::Option::Some(Type::A),
                            1 => ::core::option::Option::Some(Type::B),
                            2 => ::core::option::Option::Some(Type::C),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl ::core::default::Default for Type {
                    fn default() -> Type { Type::A }
                }
                impl ::core::convert::From<Type> for i32 {
                    fn from(value: Type) -> i32 { value as i32 }
                }
                impl ::core::convert::TryFrom<i32> for Type {
                    type Error = ::prost::UnknownEnumValue;
                    fn try_from(value: i32)
                        -> ::core::result::Result<Type, ::prost::UnknownEnumValue> {
                        match value {
                            0 => ::core::result::Result::Ok(Type::A),
                            1 => ::core::result::Result::Ok(Type::B),
                            2 => ::core::result::Result::Ok(Type::C),
                            _ =>
                                ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                        }
                    }
                }
                impl Type {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::A => "A",
                            Self::B => "B",
                            Self::C => "C",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str)
                        -> ::core::option::Option<Self> {
                        match value {
                            "A" => Some(Self::A),
                            "B" => Some(Self::B),
                            "C" => Some(Self::C),
                            _ => None,
                        }
                    }
                }
            }
            pub mod factory {
                pub struct WidgetFactory {
                    #[prost(message, optional, tag = "1")]
                    pub inner: ::core::option::Option<widget_factory::Inner>,
                    #[prost(message, optional, tag = "2")]
                    pub root: ::core::option::Option<super::super::Root>,
                    #[prost(message, optional, tag = "3")]
                    pub root_inner: ::core::option::Option<super::super::root::Inner>,
                    #[prost(message, optional, tag = "4")]
                    pub widget: ::core::option::Option<super::Widget>,
                    #[prost(message, optional, tag = "5")]
                    pub widget_inner: ::core::option::Option<super::widget::Inner>,
                    #[prost(enumeration = "super::widget::Type", tag = "8")]
                    pub widget_type: i32,
                    #[prost(message, optional, tag = "6")]
                    pub gizmo: ::core::option::Option<super::super::gizmo::Gizmo>,
                    #[prost(message, optional, tag = "7")]
                    pub gizmo_inner: ::core::option::Option<super::super::gizmo::gizmo::Inner>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for WidgetFactory {
                    #[inline]
                    fn clone(&self) -> WidgetFactory {
                        let _:
                                ::core::clone::AssertParamIsClone<::core::option::Option<widget_factory::Inner>>;
                        let _:
                                ::core::clone::AssertParamIsClone<::core::option::Option<super::super::Root>>;
                        let _:
                                ::core::clone::AssertParamIsClone<::core::option::Option<super::super::root::Inner>>;
                        let _:
                                ::core::clone::AssertParamIsClone<::core::option::Option<super::Widget>>;
                        let _:
                                ::core::clone::AssertParamIsClone<::core::option::Option<super::widget::Inner>>;
                        let _: ::core::clone::AssertParamIsClone<i32>;
                        let _:
                                ::core::clone::AssertParamIsClone<::core::option::Option<super::super::gizmo::Gizmo>>;
                        let _:
                                ::core::clone::AssertParamIsClone<::core::option::Option<super::super::gizmo::gizmo::Inner>>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for WidgetFactory { }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for WidgetFactory { }
                #[automatically_derived]
                impl ::core::cmp::PartialEq for WidgetFactory {
                    #[inline]
                    fn eq(&self, other: &WidgetFactory) -> bool {
                        self.inner == other.inner && self.root == other.root &&
                                                self.root_inner == other.root_inner &&
                                            self.widget == other.widget &&
                                        self.widget_inner == other.widget_inner &&
                                    self.widget_type == other.widget_type &&
                                self.gizmo == other.gizmo &&
                            self.gizmo_inner == other.gizmo_inner
                    }
                }
                impl ::prost::Message for WidgetFactory {
                    #[allow(unused_variables)]
                    fn encode_raw(&self,
                        buf: &mut impl ::prost::bytes::BufMut) {
                        if let Some(ref msg) = self.inner {
                                ::prost::encoding::message::encode(1u32, msg, buf);
                            }
                        if let Some(ref msg) = self.root {
                                ::prost::encoding::message::encode(2u32, msg, buf);
                            }
                        if let Some(ref msg) = self.root_inner {
                                ::prost::encoding::message::encode(3u32, msg, buf);
                            }
                        if let Some(ref msg) = self.widget {
                                ::prost::encoding::message::encode(4u32, msg, buf);
                            }
                        if let Some(ref msg) = self.widget_inner {
                                ::prost::encoding::message::encode(5u32, msg, buf);
                            }
                        if let Some(ref msg) = self.gizmo {
                                ::prost::encoding::message::encode(6u32, msg, buf);
                            }
                        if let Some(ref msg) = self.gizmo_inner {
                                ::prost::encoding::message::encode(7u32, msg, buf);
                            }
                        if self.widget_type != super::widget::Type::default() as i32
                                {
                                ::prost::encoding::int32::encode(8u32, &self.widget_type,
                                    buf);
                            }
                    }
                    #[allow(unused_variables)]
                    fn merge_field(&mut self, tag: u32,
                        wire_type: ::prost::encoding::wire_type::WireType,
                        buf: &mut impl ::prost::bytes::Buf,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> {
                        const STRUCT_NAME: &'static str = "WidgetFactory";
                        match tag {
                            1u32 => {
                                let mut value = &mut self.inner;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "inner"); error })
                            }
                            2u32 => {
                                let mut value = &mut self.root;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "root"); error })
                            }
                            3u32 => {
                                let mut value = &mut self.root_inner;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "root_inner"); error })
                            }
                            4u32 => {
                                let mut value = &mut self.widget;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "widget"); error })
                            }
                            5u32 => {
                                let mut value = &mut self.widget_inner;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "widget_inner"); error })
                            }
                            6u32 => {
                                let mut value = &mut self.gizmo;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "gizmo"); error })
                            }
                            7u32 => {
                                let mut value = &mut self.gizmo_inner;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "gizmo_inner"); error })
                            }
                            8u32 => {
                                let mut value = &mut self.widget_type;
                                ::prost::encoding::int32::merge(wire_type, value, buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "widget_type"); error })
                            }
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize {
                        0 +
                                                        self.inner.as_ref().map_or(0,
                                                            |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                                    self.root.as_ref().map_or(0,
                                                        |msg| ::prost::encoding::message::encoded_len(2u32, msg)) +
                                                self.root_inner.as_ref().map_or(0,
                                                    |msg| ::prost::encoding::message::encoded_len(3u32, msg)) +
                                            self.widget.as_ref().map_or(0,
                                                |msg| ::prost::encoding::message::encoded_len(4u32, msg)) +
                                        self.widget_inner.as_ref().map_or(0,
                                            |msg| ::prost::encoding::message::encoded_len(5u32, msg)) +
                                    self.gizmo.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(6u32, msg)) +
                                self.gizmo_inner.as_ref().map_or(0,
                                    |msg| ::prost::encoding::message::encoded_len(7u32, msg)) +
                            if self.widget_type != super::widget::Type::default() as i32
                                    {
                                    ::prost::encoding::int32::encoded_len(8u32,
                                        &self.widget_type)
                                } else { 0 }
                    }
                    fn clear(&mut self) {
                        self.inner = ::core::option::Option::None;
                        self.root = ::core::option::Option::None;
                        self.root_inner = ::core::option::Option::None;
                        self.widget = ::core::option::Option::None;
                        self.widget_inner = ::core::option::Option::None;
                        self.gizmo = ::core::option::Option::None;
                        self.gizmo_inner = ::core::option::Option::None;
                        self.widget_type = super::widget::Type::default() as i32;
                    }
                }
                impl ::core::default::Default for WidgetFactory {
                    fn default() -> Self {
                        WidgetFactory {
                            inner: ::core::default::Default::default(),
                            root: ::core::default::Default::default(),
                            root_inner: ::core::default::Default::default(),
                            widget: ::core::default::Default::default(),
                            widget_inner: ::core::default::Default::default(),
                            gizmo: ::core::default::Default::default(),
                            gizmo_inner: ::core::default::Default::default(),
                            widget_type: super::widget::Type::default() as i32,
                        }
                    }
                }
                impl ::core::fmt::Debug for WidgetFactory {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("WidgetFactory");
                        let builder =
                            {
                                let wrapper = &self.inner;
                                builder.field("inner", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper = &self.root;
                                builder.field("root", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper = &self.root_inner;
                                builder.field("root_inner", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper = &self.widget;
                                builder.field("widget", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper = &self.widget_inner;
                                builder.field("widget_inner", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper =
                                    {
                                        struct ScalarWrapper<'a>(&'a i32);
                                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                let res: ::core::result::Result<super::widget::Type, _> =
                                                    ::core::convert::TryFrom::try_from(*self.0);
                                                match res {
                                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                                }
                                            }
                                        }
                                        ScalarWrapper(&self.widget_type)
                                    };
                                builder.field("widget_type", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper = &self.gizmo;
                                builder.field("gizmo", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper = &self.gizmo_inner;
                                builder.field("gizmo_inner", &wrapper)
                            };
                        ;
                        builder.finish()
                    }
                }
                #[allow(dead_code)]
                impl WidgetFactory {
                    #[doc =
                    "Returns the enum value of `widget_type`, or the default if the field is set to an invalid enum value."]
                    pub fn widget_type(&self) -> super::widget::Type {
                        ::core::convert::TryFrom::try_from(self.widget_type).unwrap_or(super::widget::Type::default())
                    }
                    #[doc = "Sets `widget_type` to the provided enum value."]
                    pub fn set_widget_type(&mut self,
                        value: super::widget::Type) {
                        self.widget_type = value as i32;
                    }
                }
                /// Nested message and enum types in `WidgetFactory`.
                pub mod widget_factory {
                    pub struct Inner {}
                    #[automatically_derived]
                    impl ::core::clone::Clone for Inner {
                        #[inline]
                        fn clone(&self) -> Inner { *self }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for Inner { }
                    #[automatically_derived]
                    impl ::core::marker::StructuralPartialEq for Inner { }
                    #[automatically_derived]
                    impl ::core::cmp::PartialEq for Inner {
                        #[inline]
                        fn eq(&self, other: &Inner) -> bool { true }
                    }
                    impl ::prost::Message for Inner {
                        #[allow(unused_variables)]
                        fn encode_raw(&self,
                            buf: &mut impl ::prost::bytes::BufMut) {}
                        #[allow(unused_variables)]
                        fn merge_field(&mut self, tag: u32,
                            wire_type: ::prost::encoding::wire_type::WireType,
                            buf: &mut impl ::prost::bytes::Buf,
                            ctx: ::prost::encoding::DecodeContext)
                            -> ::core::result::Result<(), ::prost::DecodeError> {
                            match tag {
                                _ =>
                                    ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                            }
                        }
                        #[inline]
                        fn encoded_len(&self) -> usize { 0 }
                        fn clear(&mut self) {}
                    }
                    impl ::core::default::Default for Inner {
                        fn default() -> Self { Inner {} }
                    }
                    impl ::core::fmt::Debug for Inner {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                            -> ::core::fmt::Result {
                            let mut builder = f.debug_struct("Inner");
                            builder.finish()
                        }
                    }
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "no_root_packages::test"]
    #[doc(hidden)]
    pub const test: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("no_root_packages::test"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/no_root_packages/mod.rs",
                start_line: 24usize,
                start_col: 4usize,
                end_line: 24usize,
                end_col: 8usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test())),
        };
    fn test() {
        use prost::Message;
        let mut widget_factory = widget::factory::WidgetFactory::default();
        match (&0, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.inner =
            Some(widget::factory::widget_factory::Inner {});
        match (&2, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root = Some(Root {});
        match (&4, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root_inner = Some(root::Inner {});
        match (&6, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget = Some(widget::Widget {});
        match (&8, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget_inner = Some(widget::widget::Inner {});
        match (&10, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo = Some(gizmo::Gizmo {});
        match (&12, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo_inner = Some(gizmo::gizmo::Inner {});
        match (&14, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "no_root_packages::generated_include"]
    #[doc(hidden)]
    pub const generated_include: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("no_root_packages::generated_include"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/no_root_packages/mod.rs",
                start_line: 53usize,
                start_col: 4usize,
                end_line: 53usize,
                end_col: 21usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(generated_include())),
        };
    fn generated_include() {
        use prost::Message;
        let mut widget_factory =
            generated_include::widget::factory::WidgetFactory::default();
        match (&0, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.inner =
            Some(generated_include::widget::factory::widget_factory::Inner {});
        match (&2, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root = Some(generated_include::Root {});
        match (&4, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root_inner = Some(generated_include::root::Inner {});
        match (&6, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget = Some(generated_include::widget::Widget {});
        match (&8, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget_inner =
            Some(generated_include::widget::widget::Inner {});
        match (&10, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo = Some(generated_include::gizmo::Gizmo {});
        match (&12, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo_inner =
            Some(generated_include::gizmo::gizmo::Inner {});
        match (&14, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
pub mod packages {
    //! Tests nested packages.
    pub struct Root {}
    #[automatically_derived]
    impl ::core::clone::Clone for Root {
        #[inline]
        fn clone(&self) -> Root { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Root { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Root { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Root {
        #[inline]
        fn eq(&self, other: &Root) -> bool { true }
    }
    impl ::prost::Message for Root {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for Root {
        fn default() -> Self { Root {} }
    }
    impl ::core::fmt::Debug for Root {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Root");
            builder.finish()
        }
    }
    /// Nested message and enum types in `Root`.
    pub mod root {
        pub struct Inner {}
        #[automatically_derived]
        impl ::core::clone::Clone for Inner {
            #[inline]
            fn clone(&self) -> Inner { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Inner { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Inner { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Inner {
            #[inline]
            fn eq(&self, other: &Inner) -> bool { true }
        }
        impl ::prost::Message for Inner {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Inner {
            fn default() -> Self { Inner {} }
        }
        impl ::core::fmt::Debug for Inner {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Inner");
                builder.finish()
            }
        }
    }
    pub mod gizmo {
        pub struct Gizmo {}
        #[automatically_derived]
        impl ::core::clone::Clone for Gizmo {
            #[inline]
            fn clone(&self) -> Gizmo { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Gizmo { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Gizmo { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Gizmo {
            #[inline]
            fn eq(&self, other: &Gizmo) -> bool { true }
        }
        impl ::prost::Message for Gizmo {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Gizmo {
            fn default() -> Self { Gizmo {} }
        }
        impl ::core::fmt::Debug for Gizmo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Gizmo");
                builder.finish()
            }
        }
        /// Nested message and enum types in `Gizmo`.
        pub mod gizmo {
            pub struct Inner {}
            #[automatically_derived]
            impl ::core::clone::Clone for Inner {
                #[inline]
                fn clone(&self) -> Inner { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Inner { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Inner { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Inner {
                #[inline]
                fn eq(&self, other: &Inner) -> bool { true }
            }
            impl ::prost::Message for Inner {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Inner {
                fn default() -> Self { Inner {} }
            }
            impl ::core::fmt::Debug for Inner {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Inner");
                    builder.finish()
                }
            }
        }
    }
    pub mod widget {
        pub struct Widget {}
        #[automatically_derived]
        impl ::core::clone::Clone for Widget {
            #[inline]
            fn clone(&self) -> Widget { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Widget { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Widget { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Widget {
            #[inline]
            fn eq(&self, other: &Widget) -> bool { true }
        }
        impl ::prost::Message for Widget {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Widget {
            fn default() -> Self { Widget {} }
        }
        impl ::core::fmt::Debug for Widget {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Widget");
                builder.finish()
            }
        }
        /// Nested message and enum types in `Widget`.
        pub mod widget {
            pub struct Inner {}
            #[automatically_derived]
            impl ::core::clone::Clone for Inner {
                #[inline]
                fn clone(&self) -> Inner { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Inner { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Inner { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Inner {
                #[inline]
                fn eq(&self, other: &Inner) -> bool { true }
            }
            impl ::prost::Message for Inner {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Inner {
                fn default() -> Self { Inner {} }
            }
            impl ::core::fmt::Debug for Inner {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Inner");
                    builder.finish()
                }
            }
            #[repr(i32)]
            pub enum Type { A = 0, B = 1, C = 2, }
            #[automatically_derived]
            impl ::core::clone::Clone for Type {
                #[inline]
                fn clone(&self) -> Type { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Type { }
            #[automatically_derived]
            impl ::core::fmt::Debug for Type {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f,
                        match self {
                            Type::A => "A",
                            Type::B => "B",
                            Type::C => "C",
                        })
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Type { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Type {
                #[inline]
                fn eq(&self, other: &Type) -> bool {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Type {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Type {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H)
                    -> () {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_discr, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Type {
                #[inline]
                fn partial_cmp(&self, other: &Type)
                    -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                        &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Type {
                #[inline]
                fn cmp(&self, other: &Type) -> ::core::cmp::Ordering {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl Type {
                #[doc = "Returns `true` if `value` is a variant of `Type`."]
                pub fn is_valid(value: i32) -> bool {
                    match value { 0 => true, 1 => true, 2 => true, _ => false, }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                #[doc =
                "Converts an `i32` to a `Type`, or `None` if `value` is not a valid variant."]
                pub fn from_i32(value: i32) -> ::core::option::Option<Type> {
                    match value {
                        0 => ::core::option::Option::Some(Type::A),
                        1 => ::core::option::Option::Some(Type::B),
                        2 => ::core::option::Option::Some(Type::C),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for Type {
                fn default() -> Type { Type::A }
            }
            impl ::core::convert::From<Type> for i32 {
                fn from(value: Type) -> i32 { value as i32 }
            }
            impl ::core::convert::TryFrom<i32> for Type {
                type Error = ::prost::UnknownEnumValue;
                fn try_from(value: i32)
                    -> ::core::result::Result<Type, ::prost::UnknownEnumValue> {
                    match value {
                        0 => ::core::result::Result::Ok(Type::A),
                        1 => ::core::result::Result::Ok(Type::B),
                        2 => ::core::result::Result::Ok(Type::C),
                        _ =>
                            ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                    }
                }
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::A => "A",
                        Self::B => "B",
                        Self::C => "C",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str)
                    -> ::core::option::Option<Self> {
                    match value {
                        "A" => Some(Self::A),
                        "B" => Some(Self::B),
                        "C" => Some(Self::C),
                        _ => None,
                    }
                }
            }
        }
        pub mod factory {
            pub struct WidgetFactory {
                #[prost(message, optional, tag = "1")]
                pub inner: ::core::option::Option<widget_factory::Inner>,
                #[prost(message, optional, tag = "2")]
                pub root: ::core::option::Option<super::super::Root>,
                #[prost(message, optional, tag = "3")]
                pub root_inner: ::core::option::Option<super::super::root::Inner>,
                #[prost(message, optional, tag = "4")]
                pub widget: ::core::option::Option<super::Widget>,
                #[prost(message, optional, tag = "5")]
                pub widget_inner: ::core::option::Option<super::widget::Inner>,
                #[prost(enumeration = "super::widget::Type", tag = "8")]
                pub widget_type: i32,
                #[prost(message, optional, tag = "6")]
                pub gizmo: ::core::option::Option<super::super::gizmo::Gizmo>,
                #[prost(message, optional, tag = "7")]
                pub gizmo_inner: ::core::option::Option<super::super::gizmo::gizmo::Inner>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for WidgetFactory {
                #[inline]
                fn clone(&self) -> WidgetFactory {
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<widget_factory::Inner>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::Root>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::root::Inner>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::Widget>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::widget::Inner>>;
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::gizmo::Gizmo>>;
                    let _:
                            ::core::clone::AssertParamIsClone<::core::option::Option<super::super::gizmo::gizmo::Inner>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for WidgetFactory { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for WidgetFactory { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for WidgetFactory {
                #[inline]
                fn eq(&self, other: &WidgetFactory) -> bool {
                    self.inner == other.inner && self.root == other.root &&
                                            self.root_inner == other.root_inner &&
                                        self.widget == other.widget &&
                                    self.widget_inner == other.widget_inner &&
                                self.widget_type == other.widget_type &&
                            self.gizmo == other.gizmo &&
                        self.gizmo_inner == other.gizmo_inner
                }
            }
            impl ::prost::Message for WidgetFactory {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    if let Some(ref msg) = self.inner {
                            ::prost::encoding::message::encode(1u32, msg, buf);
                        }
                    if let Some(ref msg) = self.root {
                            ::prost::encoding::message::encode(2u32, msg, buf);
                        }
                    if let Some(ref msg) = self.root_inner {
                            ::prost::encoding::message::encode(3u32, msg, buf);
                        }
                    if let Some(ref msg) = self.widget {
                            ::prost::encoding::message::encode(4u32, msg, buf);
                        }
                    if let Some(ref msg) = self.widget_inner {
                            ::prost::encoding::message::encode(5u32, msg, buf);
                        }
                    if let Some(ref msg) = self.gizmo {
                            ::prost::encoding::message::encode(6u32, msg, buf);
                        }
                    if let Some(ref msg) = self.gizmo_inner {
                            ::prost::encoding::message::encode(7u32, msg, buf);
                        }
                    if self.widget_type != super::widget::Type::default() as i32
                            {
                            ::prost::encoding::int32::encode(8u32, &self.widget_type,
                                buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    const STRUCT_NAME: &'static str = "WidgetFactory";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "inner"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.root;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "root"); error })
                        }
                        3u32 => {
                            let mut value = &mut self.root_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "root_inner"); error })
                        }
                        4u32 => {
                            let mut value = &mut self.widget;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget"); error })
                        }
                        5u32 => {
                            let mut value = &mut self.widget_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget_inner"); error })
                        }
                        6u32 => {
                            let mut value = &mut self.gizmo;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "gizmo"); error })
                        }
                        7u32 => {
                            let mut value = &mut self.gizmo_inner;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "gizmo_inner"); error })
                        }
                        8u32 => {
                            let mut value = &mut self.widget_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "widget_type"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                                                    self.inner.as_ref().map_or(0,
                                                        |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                                self.root.as_ref().map_or(0,
                                                    |msg| ::prost::encoding::message::encoded_len(2u32, msg)) +
                                            self.root_inner.as_ref().map_or(0,
                                                |msg| ::prost::encoding::message::encoded_len(3u32, msg)) +
                                        self.widget.as_ref().map_or(0,
                                            |msg| ::prost::encoding::message::encoded_len(4u32, msg)) +
                                    self.widget_inner.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(5u32, msg)) +
                                self.gizmo.as_ref().map_or(0,
                                    |msg| ::prost::encoding::message::encoded_len(6u32, msg)) +
                            self.gizmo_inner.as_ref().map_or(0,
                                |msg| ::prost::encoding::message::encoded_len(7u32, msg)) +
                        if self.widget_type != super::widget::Type::default() as i32
                                {
                                ::prost::encoding::int32::encoded_len(8u32,
                                    &self.widget_type)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.inner = ::core::option::Option::None;
                    self.root = ::core::option::Option::None;
                    self.root_inner = ::core::option::Option::None;
                    self.widget = ::core::option::Option::None;
                    self.widget_inner = ::core::option::Option::None;
                    self.gizmo = ::core::option::Option::None;
                    self.gizmo_inner = ::core::option::Option::None;
                    self.widget_type = super::widget::Type::default() as i32;
                }
            }
            impl ::core::default::Default for WidgetFactory {
                fn default() -> Self {
                    WidgetFactory {
                        inner: ::core::default::Default::default(),
                        root: ::core::default::Default::default(),
                        root_inner: ::core::default::Default::default(),
                        widget: ::core::default::Default::default(),
                        widget_inner: ::core::default::Default::default(),
                        gizmo: ::core::default::Default::default(),
                        gizmo_inner: ::core::default::Default::default(),
                        widget_type: super::widget::Type::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for WidgetFactory {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("WidgetFactory");
                    let builder =
                        {
                            let wrapper = &self.inner;
                            builder.field("inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.root;
                            builder.field("root", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.root_inner;
                            builder.field("root_inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.widget;
                            builder.field("widget", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.widget_inner;
                            builder.field("widget_inner", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    struct ScalarWrapper<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            let res: ::core::result::Result<super::widget::Type, _> =
                                                ::core::convert::TryFrom::try_from(*self.0);
                                            match res {
                                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ScalarWrapper(&self.widget_type)
                                };
                            builder.field("widget_type", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.gizmo;
                            builder.field("gizmo", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.gizmo_inner;
                            builder.field("gizmo_inner", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl WidgetFactory {
                #[doc =
                "Returns the enum value of `widget_type`, or the default if the field is set to an invalid enum value."]
                pub fn widget_type(&self) -> super::widget::Type {
                    ::core::convert::TryFrom::try_from(self.widget_type).unwrap_or(super::widget::Type::default())
                }
                #[doc = "Sets `widget_type` to the provided enum value."]
                pub fn set_widget_type(&mut self,
                    value: super::widget::Type) {
                    self.widget_type = value as i32;
                }
            }
            /// Nested message and enum types in `WidgetFactory`.
            pub mod widget_factory {
                pub struct Inner {}
                #[automatically_derived]
                impl ::core::clone::Clone for Inner {
                    #[inline]
                    fn clone(&self) -> Inner { *self }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Inner { }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Inner { }
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Inner {
                    #[inline]
                    fn eq(&self, other: &Inner) -> bool { true }
                }
                impl ::prost::Message for Inner {
                    #[allow(unused_variables)]
                    fn encode_raw(&self,
                        buf: &mut impl ::prost::bytes::BufMut) {}
                    #[allow(unused_variables)]
                    fn merge_field(&mut self, tag: u32,
                        wire_type: ::prost::encoding::wire_type::WireType,
                        buf: &mut impl ::prost::bytes::Buf,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> {
                        match tag {
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize { 0 }
                    fn clear(&mut self) {}
                }
                impl ::core::default::Default for Inner {
                    fn default() -> Self { Inner {} }
                }
                impl ::core::fmt::Debug for Inner {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("Inner");
                        builder.finish()
                    }
                }
            }
        }
    }
    pub trait DoIt {
        fn do_it(&self);
    }
    impl DoIt for gizmo::Gizmo {
        fn do_it(&self) {}
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "packages::test"]
    #[doc(hidden)]
    pub const test: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("packages::test"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/packages/mod.rs",
                start_line: 26usize,
                start_col: 4usize,
                end_line: 26usize,
                end_col: 8usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test())),
        };
    fn test() {
        use prost::Message;
        let mut widget_factory = widget::factory::WidgetFactory::default();
        match (&0, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.inner =
            Some(widget::factory::widget_factory::Inner {});
        match (&2, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root = Some(Root {});
        match (&4, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.root_inner = Some(root::Inner {});
        match (&6, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget = Some(widget::Widget {});
        match (&8, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.widget_inner = Some(widget::widget::Inner {});
        match (&10, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo = Some(gizmo::Gizmo {});
        match (&12, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        widget_factory.gizmo_inner = Some(gizmo::gizmo::Inner {});
        match (&14, &widget_factory.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
pub mod unittest {
    #![cfg(test)]
    #![allow(clippy::float_cmp)]
    use core::{f32, f64};
    use protobuf::test_messages::protobuf_unittest;
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "unittest::extreme_default_values"]
    #[doc(hidden)]
    pub const extreme_default_values: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("unittest::extreme_default_values"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/unittest.rs",
                start_line: 9usize,
                start_col: 4usize,
                end_line: 9usize,
                end_col: 26usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(extreme_default_values())),
        };
    fn extreme_default_values() {
        let pb = protobuf_unittest::TestExtremeDefaultValues::default();
        match (&b"\0\x01\x07\x08\x0C\n\r\t\x0B\\\'\"\xFE",
                &pb.escaped_bytes()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&0xFFFFFFFF, &pb.large_uint32()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&0xFFFFFFFFFFFFFFFF, &pb.large_uint64()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&-0x7FFFFFFF, &pb.small_int32()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&-0x7FFFFFFFFFFFFFFF, &pb.small_int64()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&-0x80000000, &pb.really_small_int32()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&-0x8000000000000000, &pb.really_small_int64()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&pb.utf8_string(), &"\u{1234}") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&0.0, &pb.zero_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&1.0, &pb.one_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&1.5, &pb.small_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&-1.0, &pb.negative_one_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&-1.5, &pb.negative_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&2E8, &pb.large_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&-8e-28, &pb.small_negative_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&f64::INFINITY, &pb.inf_double()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&f64::NEG_INFINITY, &pb.neg_inf_double()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&pb.nan_double(), &pb.nan_double()) {
            (left_val, right_val) => {
                if *left_val == *right_val {
                        let kind = ::core::panicking::AssertKind::Ne;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&f32::INFINITY, &pb.inf_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&f32::NEG_INFINITY, &pb.neg_inf_float()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&pb.nan_float(), &pb.nan_float()) {
            (left_val, right_val) => {
                if *left_val == *right_val {
                        let kind = ::core::panicking::AssertKind::Ne;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"? ? ?? ?? ??? ??/ ??-", &pb.cpp_trigraph()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"hel\x00lo", &pb.string_with_zero()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&b"wor\x00ld", &pb.bytes_with_zero()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"ab\x00c", &pb.string_piece_with_zero()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"12\x003", &pb.cord_with_zero()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"${unknown}", &pb.replacement_string()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
#[cfg(test)]
mod bootstrap {
    #![cfg(feature = "std")]
    use std::path::Path;
    use std::path::PathBuf;
    macro_rules! assert_eq_bootstrapped_file {
        ($expected_path:expr, $actual_path:expr) =>
        {
            {
                let expected =
                std::fs::read_to_string($expected_path).unwrap(); let actual =
                std::fs::read_to_string($actual_path).unwrap(); let expected =
                expected.replace("\r\n", "\n"); let actual =
                actual.replace("\r\n", "\n"); if expected != actual
                { std::fs::write($expected_path, &actual).unwrap(); }
                assert_eq!(expected, actual);
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "bootstrap::bootstrap"]
    #[doc(hidden)]
    pub const bootstrap: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("bootstrap::bootstrap"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/bootstrap.rs",
                start_line: 26usize,
                start_col: 4usize,
                end_line: 26usize,
                end_col: 13usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(bootstrap())),
        };
    /// Test which bootstraps protobuf.rs and compiler.rs from the .proto definitions in the Protobuf
    /// repo. Ensures that the checked-in compiled versions are up-to-date.
    fn bootstrap() {
        let include =
            PathBuf::from("/home/mzabaluev/work/tokio-rs/prost/tests").parent().unwrap().join("tests").join("src").join("include");
        let protobuf = include.join("google").join("protobuf");
        let tempdir =
            tempfile::Builder::new().prefix("prost-types-bootstrap").tempdir().unwrap();
        prost_build::Config::new().compile_well_known_types().btree_map(["."]).out_dir(tempdir.path()).compile_protos(&[protobuf.join("descriptor.proto"),
                            protobuf.join("compiler").join("plugin.proto"),
                            protobuf.join("any.proto"), protobuf.join("api.proto"),
                            protobuf.join("duration.proto"),
                            protobuf.join("field_mask.proto"),
                            protobuf.join("source_context.proto"),
                            protobuf.join("struct.proto"),
                            protobuf.join("timestamp.proto"),
                            protobuf.join("type.proto")], &[include]).unwrap();
        let src =
            Path::new("/home/mzabaluev/work/tokio-rs/prost/tests").parent().expect("no parent").join("prost-types").join("src");
        {
            let expected =
                std::fs::read_to_string(src.join("protobuf.rs")).unwrap();
            let actual =
                std::fs::read_to_string(tempdir.path().join("google.protobuf.rs")).unwrap();
            let expected = expected.replace("\r\n", "\n");
            let actual = actual.replace("\r\n", "\n");
            if expected != actual {
                    std::fs::write(src.join("protobuf.rs"), &actual).unwrap();
                }
            match (&expected, &actual) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        };
        {
            let expected =
                std::fs::read_to_string(src.join("compiler.rs")).unwrap();
            let actual =
                std::fs::read_to_string(tempdir.path().join("google.protobuf.compiler.rs")).unwrap();
            let expected = expected.replace("\r\n", "\n");
            let actual = actual.replace("\r\n", "\n");
            if expected != actual {
                    std::fs::write(src.join("compiler.rs"), &actual).unwrap();
                }
            match (&expected, &actual) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        };
    }
}
#[cfg(test)]
mod debug {
    //! Tests for our own Debug implementation.
    //!
    //! The tests check against expected output. This may be a bit fragile, but it is likely OK for
    //! actual use.
    use prost::alloc::format;
    use prost::OpenEnum;
    #[cfg(feature = "std")]
    use crate::message_encoding::Basic;
    use crate::message_encoding::BasicEnumeration;
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "debug::basic"]
    #[doc(hidden)]
    pub const basic: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("debug::basic"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/debug.rs",
                start_line: 19usize,
                start_col: 4usize,
                end_line: 19usize,
                end_col: 9usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(basic())),
        };
    /// Some real-life message
    #[cfg(feature = "std")]
    fn basic() {
        let mut basic = Basic::default();
        match (&::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?}", basic));
                            res
                        }),
                &"Basic { \
         int32: 0, \
         bools: [], \
         string: \"\", \
         optional_string: None, \
         enumeration: ZERO, \
         enumeration_map: {}, \
         string_map: {}, \
         enumeration_btree_map: {}, \
         string_btree_map: {}, \
         oneof: None, \
         bytes_map: {} \
         }")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        basic.enumeration_map.insert(0, BasicEnumeration::TWO.into());
        basic.enumeration = OpenEnum::from_raw(42);
        basic.bytes_map.insert("hello".to_string(),
            "world".as_bytes().into());
        match (&::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?}", basic));
                            res
                        }),
                &"Basic { \
         int32: 0, \
         bools: [], \
         string: \"\", \
         optional_string: None, \
         enumeration: Unknown(42), \
         enumeration_map: {0: TWO}, \
         string_map: {}, \
         enumeration_btree_map: {}, \
         string_btree_map: {}, \
         oneof: None, \
         bytes_map: {\"hello\": [119, 111, 114, 108, 100]} \
         }")
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "debug::tuple_struct"]
    #[doc(hidden)]
    pub const tuple_struct: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("debug::tuple_struct"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/debug.rs",
                start_line: 64usize,
                start_col: 4usize,
                end_line: 64usize,
                end_col: 16usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(tuple_struct())),
        };
    /// A special case with a tuple struct
    fn tuple_struct() {
        struct NewType(
            #[prost(enumeration = "BasicEnumeration", tag = "5")]
            OpenEnum<BasicEnumeration>);
        #[automatically_derived]
        impl ::core::clone::Clone for NewType {
            #[inline]
            fn clone(&self) -> NewType {
                NewType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NewType { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NewType {
            #[inline]
            fn eq(&self, other: &NewType) -> bool { self.0 == other.0 }
        }
        impl ::prost::Message for NewType {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.0 != BasicEnumeration::default() as i32 {
                        ::prost::encoding::int32::encode(5u32, &self.0, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "NewType";
                match tag {
                    5u32 => {
                        let mut value = &mut self.0;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "0"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    if self.0 != BasicEnumeration::default() as i32 {
                            ::prost::encoding::int32::encoded_len(5u32, &self.0)
                        } else { 0 }
            }
            fn clear(&mut self) {
                self.0 = BasicEnumeration::default() as i32;
            }
        }
        impl ::core::default::Default for NewType {
            fn default() -> Self {
                NewType(BasicEnumeration::default() as i32)
            }
        }
        impl ::core::fmt::Debug for NewType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_tuple("NewType");
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.0)
                            };
                        builder.field(&wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl NewType {
            #[doc =
            "Returns the enum value of `0`, or the default if the field is set to an invalid enum value."]
            pub fn get_0(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.0).unwrap_or(BasicEnumeration::default())
            }
            #[doc = "Sets `0` to the provided enum value."]
            pub fn set_0(&mut self, value: BasicEnumeration) {
                self.0 = value as i32;
            }
        }
        match (&::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?}",
                                        NewType(BasicEnumeration::TWO.into())));
                            res
                        }), &"NewType(TWO)") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?}",
                                        NewType(OpenEnum::from_raw(42))));
                            res
                        }), &"NewType(Unknown(42))") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    pub enum OneofWithEnum {

        #[prost(int32, tag = "8")]
        Int(i32),

        #[prost(string, tag = "9")]
        String(String),

        #[prost(enumeration = "BasicEnumeration", tag = "10")]
        Enumeration(OpenEnum<BasicEnumeration>),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OneofWithEnum {
        #[inline]
        fn clone(&self) -> OneofWithEnum {
            match self {
                OneofWithEnum::Int(__self_0) =>
                    OneofWithEnum::Int(::core::clone::Clone::clone(__self_0)),
                OneofWithEnum::String(__self_0) =>
                    OneofWithEnum::String(::core::clone::Clone::clone(__self_0)),
                OneofWithEnum::Enumeration(__self_0) =>
                    OneofWithEnum::Enumeration(::core::clone::Clone::clone(__self_0)),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OneofWithEnum { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OneofWithEnum {
        #[inline]
        fn eq(&self, other: &OneofWithEnum) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr &&
                match (self, other) {
                    (OneofWithEnum::Int(__self_0), OneofWithEnum::Int(__arg1_0))
                        => __self_0 == __arg1_0,
                    (OneofWithEnum::String(__self_0),
                        OneofWithEnum::String(__arg1_0)) => __self_0 == __arg1_0,
                    (OneofWithEnum::Enumeration(__self_0),
                        OneofWithEnum::Enumeration(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl OneofWithEnum {
        #[doc = r" Encodes the message to a buffer."]
        pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
            match *self {
                OneofWithEnum::Int(ref value) => {
                    ::prost::encoding::int32::encode(8u32, &*value, buf);
                }
                OneofWithEnum::String(ref value) => {
                    ::prost::encoding::string::encode(9u32, &*value, buf);
                }
                OneofWithEnum::Enumeration(ref value) => {
                    ::prost::encoding::int32::encode(10u32, &*value, buf);
                }
            }
        }
        #[doc =
        r" Decodes an instance of the message from a buffer, and merges it into self."]
        pub fn merge(field: &mut ::core::option::Option<OneofWithEnum>,
            tag: u32, wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                8u32 => {
                    match field {
                        ::core::option::Option::Some(OneofWithEnum::Int(ref mut value))
                            => {
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int32::merge(wire_type, value, buf,
                                    ctx).map(|_|
                                    *field =
                                        ::core::option::Option::Some(OneofWithEnum::Int(owned_value)))
                        }
                    }
                }
                9u32 => {
                    match field {
                        ::core::option::Option::Some(OneofWithEnum::String(ref mut value))
                            => {
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::string::merge(wire_type, value, buf,
                                    ctx).map(|_|
                                    *field =
                                        ::core::option::Option::Some(OneofWithEnum::String(owned_value)))
                        }
                    }
                }
                10u32 => {
                    match field {
                        ::core::option::Option::Some(OneofWithEnum::Enumeration(ref mut value))
                            => {
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int32::merge(wire_type, value, buf,
                                    ctx).map(|_|
                                    *field =
                                        ::core::option::Option::Some(OneofWithEnum::Enumeration(owned_value)))
                        }
                    }
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("invalid OneofWithEnum tag: {0}", tag)));
                }
            }
        }
        #[doc =
        r" Returns the encoded length of the message without a length delimiter."]
        #[inline]
        pub fn encoded_len(&self) -> usize {
            match *self {
                OneofWithEnum::Int(ref value) =>
                    ::prost::encoding::int32::encoded_len(8u32, &*value),
                OneofWithEnum::String(ref value) =>
                    ::prost::encoding::string::encoded_len(9u32, &*value),
                OneofWithEnum::Enumeration(ref value) =>
                    ::prost::encoding::int32::encoded_len(10u32, &*value),
            }
        }
    }
    impl ::core::fmt::Debug for OneofWithEnum {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                OneofWithEnum::Int(ref value) => {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&*value)
                        };
                    f.debug_tuple("Int").field(&wrapper).finish()
                }
                OneofWithEnum::String(ref value) => {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&*value)
                        };
                    f.debug_tuple("String").field(&wrapper).finish()
                }
                OneofWithEnum::Enumeration(ref value) => {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let res: ::core::result::Result<BasicEnumeration, _> =
                                        ::core::convert::TryFrom::try_from(*self.0);
                                    match res {
                                        Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                        Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&*value)
                        };
                    f.debug_tuple("Enumeration").field(&wrapper).finish()
                }
            }
        }
    }
    struct MessageWithOneof {
        #[prost(oneof = "OneofWithEnum", tags = "8, 9, 10")]
        of: Option<OneofWithEnum>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MessageWithOneof {
        #[inline]
        fn clone(&self) -> MessageWithOneof {
            MessageWithOneof { of: ::core::clone::Clone::clone(&self.of) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MessageWithOneof { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MessageWithOneof {
        #[inline]
        fn eq(&self, other: &MessageWithOneof) -> bool { self.of == other.of }
    }
    impl ::prost::Message for MessageWithOneof {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref oneof) = self.of { oneof.encode(buf) }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "MessageWithOneof";
            match tag {
                8u32 | 9u32 | 10u32 => {
                    let mut value = &mut self.of;
                    OneofWithEnum::merge(value, tag, wire_type, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "of"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.of.as_ref().map_or(0, OneofWithEnum::encoded_len)
        }
        fn clear(&mut self) { self.of = ::core::option::Option::None; }
    }
    impl ::core::default::Default for MessageWithOneof {
        fn default() -> Self {
            MessageWithOneof { of: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for MessageWithOneof {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("MessageWithOneof");
            let builder =
                { let wrapper = &self.of; builder.field("of", &wrapper) };
            ;
            builder.finish()
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "debug::oneof_with_enum"]
    #[doc(hidden)]
    pub const oneof_with_enum: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("debug::oneof_with_enum"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/debug.rs",
                start_line: 97usize,
                start_col: 4usize,
                end_line: 97usize,
                end_col: 19usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(oneof_with_enum())),
        };
    /// Enumerations inside oneofs
    fn oneof_with_enum() {
        let msg =
            MessageWithOneof {
                of: Some(OneofWithEnum::Enumeration(BasicEnumeration::TWO.into())),
            };
        match (&::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0:?}", msg));
                            res
                        }), &"MessageWithOneof { of: Some(Enumeration(TWO)) }") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
#[cfg(test)]
mod deprecated_field {
    mod deprecated_field {
        pub struct Test {
            #[prost(string, tag = "1")]
            pub not_outdated: ::prost::alloc::string::String,
            #[deprecated]
            #[prost(string, tag = "2")]
            pub outdated: ::prost::alloc::string::String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Test {
            #[inline]
            fn clone(&self) -> Test {
                Test {
                    not_outdated: ::core::clone::Clone::clone(&self.not_outdated),
                    outdated: ::core::clone::Clone::clone(&self.outdated),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Test { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Test {
            #[inline]
            fn eq(&self, other: &Test) -> bool {
                self.not_outdated == other.not_outdated &&
                    self.outdated == other.outdated
            }
        }
        impl ::prost::Message for Test {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.not_outdated != "" {
                        ::prost::encoding::string::encode(1u32, &self.not_outdated,
                            buf);
                    }
                if self.outdated != "" {
                        ::prost::encoding::string::encode(2u32, &self.outdated,
                            buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "Test";
                match tag {
                    1u32 => {
                        let mut value = &mut self.not_outdated;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "not_outdated"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.outdated;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "outdated"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                        if self.not_outdated != "" {
                                ::prost::encoding::string::encoded_len(1u32,
                                    &self.not_outdated)
                            } else { 0 } +
                    if self.outdated != "" {
                            ::prost::encoding::string::encoded_len(2u32, &self.outdated)
                        } else { 0 }
            }
            fn clear(&mut self) {
                self.not_outdated.clear();
                self.outdated.clear();
            }
        }
        impl ::core::default::Default for Test {
            fn default() -> Self {
                Test {
                    not_outdated: ::prost::alloc::string::String::new(),
                    outdated: ::prost::alloc::string::String::new(),
                }
            }
        }
        impl ::core::fmt::Debug for Test {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Test");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.not_outdated)
                            };
                        builder.field("not_outdated", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.outdated)
                            };
                        builder.field("outdated", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker =
    "deprecated_field::test_warns_when_using_fields_with_deprecated_field"]
    #[doc(hidden)]
    pub const test_warns_when_using_fields_with_deprecated_field:
        test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("deprecated_field::test_warns_when_using_fields_with_deprecated_field"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/deprecated_field.rs",
                start_line: 10usize,
                start_col: 4usize,
                end_line: 10usize,
                end_col: 54usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_warns_when_using_fields_with_deprecated_field())),
        };
    fn test_warns_when_using_fields_with_deprecated_field() {
        #[allow(deprecated)]
        let message =
            deprecated_field::Test {
                not_outdated: ".ogg".to_string(),
                outdated: ".wav".to_string(),
            };
        drop(message);
    }
}
#[cfg(test)]
mod derive_copy {
    pub struct EmptyMsg {}
    #[automatically_derived]
    impl ::core::clone::Clone for EmptyMsg {
        #[inline]
        fn clone(&self) -> EmptyMsg { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EmptyMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EmptyMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EmptyMsg {
        #[inline]
        fn eq(&self, other: &EmptyMsg) -> bool { true }
    }
    impl ::prost::Message for EmptyMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for EmptyMsg {
        fn default() -> Self { EmptyMsg {} }
    }
    impl ::core::fmt::Debug for EmptyMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("EmptyMsg");
            builder.finish()
        }
    }
    pub struct IntegerMsg {
        #[prost(int32, tag = "1")]
        pub field1: i32,
        #[prost(int64, tag = "2")]
        pub field2: i64,
        #[prost(uint32, tag = "3")]
        pub field3: u32,
        #[prost(uint64, tag = "4")]
        pub field4: u64,
        #[prost(sint32, tag = "5")]
        pub field5: i32,
        #[prost(sint64, tag = "6")]
        pub field6: i64,
        #[prost(fixed32, tag = "7")]
        pub field7: u32,
        #[prost(fixed64, tag = "8")]
        pub field8: u64,
        #[prost(sfixed32, tag = "9")]
        pub field9: i32,
        #[prost(sfixed64, tag = "10")]
        pub field10: i64,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IntegerMsg {
        #[inline]
        fn clone(&self) -> IntegerMsg {
            let _: ::core::clone::AssertParamIsClone<i32>;
            let _: ::core::clone::AssertParamIsClone<i64>;
            let _: ::core::clone::AssertParamIsClone<u32>;
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for IntegerMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IntegerMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IntegerMsg {
        #[inline]
        fn eq(&self, other: &IntegerMsg) -> bool {
            self.field1 == other.field1 && self.field2 == other.field2 &&
                                            self.field3 == other.field3 && self.field4 == other.field4
                                    && self.field5 == other.field5 &&
                                self.field6 == other.field6 && self.field7 == other.field7
                        && self.field8 == other.field8 &&
                    self.field9 == other.field9 && self.field10 == other.field10
        }
    }
    impl ::prost::Message for IntegerMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.field1 != 0i32 {
                    ::prost::encoding::int32::encode(1u32, &self.field1, buf);
                }
            if self.field2 != 0i64 {
                    ::prost::encoding::int64::encode(2u32, &self.field2, buf);
                }
            if self.field3 != 0u32 {
                    ::prost::encoding::uint32::encode(3u32, &self.field3, buf);
                }
            if self.field4 != 0u64 {
                    ::prost::encoding::uint64::encode(4u32, &self.field4, buf);
                }
            if self.field5 != 0i32 {
                    ::prost::encoding::sint32::encode(5u32, &self.field5, buf);
                }
            if self.field6 != 0i64 {
                    ::prost::encoding::sint64::encode(6u32, &self.field6, buf);
                }
            if self.field7 != 0u32 {
                    ::prost::encoding::fixed32::encode(7u32, &self.field7, buf);
                }
            if self.field8 != 0u64 {
                    ::prost::encoding::fixed64::encode(8u32, &self.field8, buf);
                }
            if self.field9 != 0i32 {
                    ::prost::encoding::sfixed32::encode(9u32, &self.field9,
                        buf);
                }
            if self.field10 != 0i64 {
                    ::prost::encoding::sfixed64::encode(10u32, &self.field10,
                        buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "IntegerMsg";
            match tag {
                1u32 => {
                    let mut value = &mut self.field1;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field1"); error })
                }
                2u32 => {
                    let mut value = &mut self.field2;
                    ::prost::encoding::int64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field2"); error })
                }
                3u32 => {
                    let mut value = &mut self.field3;
                    ::prost::encoding::uint32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field3"); error })
                }
                4u32 => {
                    let mut value = &mut self.field4;
                    ::prost::encoding::uint64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field4"); error })
                }
                5u32 => {
                    let mut value = &mut self.field5;
                    ::prost::encoding::sint32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field5"); error })
                }
                6u32 => {
                    let mut value = &mut self.field6;
                    ::prost::encoding::sint64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field6"); error })
                }
                7u32 => {
                    let mut value = &mut self.field7;
                    ::prost::encoding::fixed32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field7"); error })
                }
                8u32 => {
                    let mut value = &mut self.field8;
                    ::prost::encoding::fixed64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field8"); error })
                }
                9u32 => {
                    let mut value = &mut self.field9;
                    ::prost::encoding::sfixed32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field9"); error })
                }
                10u32 => {
                    let mut value = &mut self.field10;
                    ::prost::encoding::sfixed64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field10"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                                                    if self.field1 != 0i32 {
                                                            ::prost::encoding::int32::encoded_len(1u32, &self.field1)
                                                        } else { 0 } +
                                                if self.field2 != 0i64 {
                                                        ::prost::encoding::int64::encoded_len(2u32, &self.field2)
                                                    } else { 0 } +
                                            if self.field3 != 0u32 {
                                                    ::prost::encoding::uint32::encoded_len(3u32, &self.field3)
                                                } else { 0 } +
                                        if self.field4 != 0u64 {
                                                ::prost::encoding::uint64::encoded_len(4u32, &self.field4)
                                            } else { 0 } +
                                    if self.field5 != 0i32 {
                                            ::prost::encoding::sint32::encoded_len(5u32, &self.field5)
                                        } else { 0 } +
                                if self.field6 != 0i64 {
                                        ::prost::encoding::sint64::encoded_len(6u32, &self.field6)
                                    } else { 0 } +
                            if self.field7 != 0u32 {
                                    ::prost::encoding::fixed32::encoded_len(7u32, &self.field7)
                                } else { 0 } +
                        if self.field8 != 0u64 {
                                ::prost::encoding::fixed64::encoded_len(8u32, &self.field8)
                            } else { 0 } +
                    if self.field9 != 0i32 {
                            ::prost::encoding::sfixed32::encoded_len(9u32, &self.field9)
                        } else { 0 } +
                if self.field10 != 0i64 {
                        ::prost::encoding::sfixed64::encoded_len(10u32,
                            &self.field10)
                    } else { 0 }
        }
        fn clear(&mut self) {
            self.field1 = 0i32;
            self.field2 = 0i64;
            self.field3 = 0u32;
            self.field4 = 0u64;
            self.field5 = 0i32;
            self.field6 = 0i64;
            self.field7 = 0u32;
            self.field8 = 0u64;
            self.field9 = 0i32;
            self.field10 = 0i64;
        }
    }
    impl ::core::default::Default for IntegerMsg {
        fn default() -> Self {
            IntegerMsg {
                field1: 0i32,
                field2: 0i64,
                field3: 0u32,
                field4: 0u64,
                field5: 0i32,
                field6: 0i64,
                field7: 0u32,
                field8: 0u64,
                field9: 0i32,
                field10: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for IntegerMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("IntegerMsg");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field1)
                        };
                    builder.field("field1", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field2)
                        };
                    builder.field("field2", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field3)
                        };
                    builder.field("field3", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field4)
                        };
                    builder.field("field4", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field5)
                        };
                    builder.field("field5", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field6)
                        };
                    builder.field("field6", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field7)
                        };
                    builder.field("field7", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field8)
                        };
                    builder.field("field8", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field9)
                        };
                    builder.field("field9", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field10)
                        };
                    builder.field("field10", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    pub struct FloatMsg {
        #[prost(double, tag = "1")]
        pub field1: f64,
        #[prost(float, tag = "2")]
        pub field2: f32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FloatMsg {
        #[inline]
        fn clone(&self) -> FloatMsg {
            let _: ::core::clone::AssertParamIsClone<f64>;
            let _: ::core::clone::AssertParamIsClone<f32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FloatMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FloatMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FloatMsg {
        #[inline]
        fn eq(&self, other: &FloatMsg) -> bool {
            self.field1 == other.field1 && self.field2 == other.field2
        }
    }
    impl ::prost::Message for FloatMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.field1 != 0f64 {
                    ::prost::encoding::double::encode(1u32, &self.field1, buf);
                }
            if self.field2 != 0f32 {
                    ::prost::encoding::float::encode(2u32, &self.field2, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "FloatMsg";
            match tag {
                1u32 => {
                    let mut value = &mut self.field1;
                    ::prost::encoding::double::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field1"); error })
                }
                2u32 => {
                    let mut value = &mut self.field2;
                    ::prost::encoding::float::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field2"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                    if self.field1 != 0f64 {
                            ::prost::encoding::double::encoded_len(1u32, &self.field1)
                        } else { 0 } +
                if self.field2 != 0f32 {
                        ::prost::encoding::float::encoded_len(2u32, &self.field2)
                    } else { 0 }
        }
        fn clear(&mut self) { self.field1 = 0f64; self.field2 = 0f32; }
    }
    impl ::core::default::Default for FloatMsg {
        fn default() -> Self { FloatMsg { field1: 0f64, field2: 0f32 } }
    }
    impl ::core::fmt::Debug for FloatMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FloatMsg");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field1)
                        };
                    builder.field("field1", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field2)
                        };
                    builder.field("field2", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    pub struct BoolMsg {
        #[prost(bool, tag = "1")]
        pub field1: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BoolMsg {
        #[inline]
        fn clone(&self) -> BoolMsg {
            let _: ::core::clone::AssertParamIsClone<bool>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BoolMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BoolMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BoolMsg {
        #[inline]
        fn eq(&self, other: &BoolMsg) -> bool { self.field1 == other.field1 }
    }
    impl ::prost::Message for BoolMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.field1 != false {
                    ::prost::encoding::bool::encode(1u32, &self.field1, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "BoolMsg";
            match tag {
                1u32 => {
                    let mut value = &mut self.field1;
                    ::prost::encoding::bool::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field1"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                if self.field1 != false {
                        ::prost::encoding::bool::encoded_len(1u32, &self.field1)
                    } else { 0 }
        }
        fn clear(&mut self) { self.field1 = false; }
    }
    impl ::core::default::Default for BoolMsg {
        fn default() -> Self { BoolMsg { field1: false } }
    }
    impl ::core::fmt::Debug for BoolMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BoolMsg");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.field1)
                        };
                    builder.field("field1", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    pub struct EnumMsg {
        #[prost(enumeration = "AnEnum", tag = "1")]
        pub field1: i32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EnumMsg {
        #[inline]
        fn clone(&self) -> EnumMsg {
            let _: ::core::clone::AssertParamIsClone<i32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EnumMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EnumMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EnumMsg {
        #[inline]
        fn eq(&self, other: &EnumMsg) -> bool { self.field1 == other.field1 }
    }
    impl ::prost::Message for EnumMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.field1 != AnEnum::default() as i32 {
                    ::prost::encoding::int32::encode(1u32, &self.field1, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "EnumMsg";
            match tag {
                1u32 => {
                    let mut value = &mut self.field1;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field1"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                if self.field1 != AnEnum::default() as i32 {
                        ::prost::encoding::int32::encoded_len(1u32, &self.field1)
                    } else { 0 }
        }
        fn clear(&mut self) { self.field1 = AnEnum::default() as i32; }
    }
    impl ::core::default::Default for EnumMsg {
        fn default() -> Self { EnumMsg { field1: AnEnum::default() as i32 } }
    }
    impl ::core::fmt::Debug for EnumMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("EnumMsg");
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let res: ::core::result::Result<AnEnum, _> =
                                        ::core::convert::TryFrom::try_from(*self.0);
                                    match res {
                                        Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                        Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.field1)
                        };
                    builder.field("field1", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl EnumMsg {
        #[doc =
        "Returns the enum value of `field1`, or the default if the field is set to an invalid enum value."]
        pub fn field1(&self) -> AnEnum {
            ::core::convert::TryFrom::try_from(self.field1).unwrap_or(AnEnum::default())
        }
        #[doc = "Sets `field1` to the provided enum value."]
        pub fn set_field1(&mut self, value: AnEnum) {
            self.field1 = value as i32;
        }
    }
    pub struct OneOfMsg {
        #[prost(oneof = "one_of_msg::Data", tags = "1, 2")]
        pub data: ::core::option::Option<one_of_msg::Data>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OneOfMsg {
        #[inline]
        fn clone(&self) -> OneOfMsg {
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<one_of_msg::Data>>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for OneOfMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OneOfMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OneOfMsg {
        #[inline]
        fn eq(&self, other: &OneOfMsg) -> bool { self.data == other.data }
    }
    impl ::prost::Message for OneOfMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref oneof) = self.data { oneof.encode(buf) }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "OneOfMsg";
            match tag {
                1u32 | 2u32 => {
                    let mut value = &mut self.data;
                    one_of_msg::Data::merge(value, tag, wire_type, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "data"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.data.as_ref().map_or(0, one_of_msg::Data::encoded_len)
        }
        fn clear(&mut self) { self.data = ::core::option::Option::None; }
    }
    impl ::core::default::Default for OneOfMsg {
        fn default() -> Self {
            OneOfMsg { data: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for OneOfMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("OneOfMsg");
            let builder =
                { let wrapper = &self.data; builder.field("data", &wrapper) };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `OneOfMsg`.
    pub mod one_of_msg {
        pub enum Data {

            #[prost(int32, tag = "1")]
            Field1(i32),

            #[prost(int64, tag = "2")]
            Field2(i64),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Data {
            #[inline]
            fn clone(&self) -> Data {
                let _: ::core::clone::AssertParamIsClone<i32>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Data { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Data { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Data {
            #[inline]
            fn eq(&self, other: &Data) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (Data::Field1(__self_0), Data::Field1(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (Data::Field2(__self_0), Data::Field2(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl Data {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    Data::Field1(ref value) => {
                        ::prost::encoding::int32::encode(1u32, &*value, buf);
                    }
                    Data::Field2(ref value) => {
                        ::prost::encoding::int64::encode(2u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field: &mut ::core::option::Option<Data>, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(Data::Field1(ref mut value)) =>
                                {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(Data::Field1(owned_value)))
                            }
                        }
                    }
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(Data::Field2(ref mut value)) =>
                                {
                                ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int64::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(Data::Field2(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid Data tag: {0}", tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Data::Field1(ref value) =>
                        ::prost::encoding::int32::encoded_len(1u32, &*value),
                    Data::Field2(ref value) =>
                        ::prost::encoding::int64::encoded_len(2u32, &*value),
                }
            }
        }
        impl ::core::fmt::Debug for Data {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match *self {
                    Data::Field1(ref value) => {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&*value)
                            };
                        f.debug_tuple("Field1").field(&wrapper).finish()
                    }
                    Data::Field2(ref value) => {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&*value)
                            };
                        f.debug_tuple("Field2").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    pub struct ComposedMsg {
        #[prost(message, optional, tag = "1")]
        pub field1: ::core::option::Option<IntegerMsg>,
        #[prost(message, optional, tag = "2")]
        pub field2: ::core::option::Option<EnumMsg>,
        #[prost(message, optional, tag = "3")]
        pub field3: ::core::option::Option<OneOfMsg>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ComposedMsg {
        #[inline]
        fn clone(&self) -> ComposedMsg {
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<IntegerMsg>>;
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<EnumMsg>>;
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<OneOfMsg>>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ComposedMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ComposedMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ComposedMsg {
        #[inline]
        fn eq(&self, other: &ComposedMsg) -> bool {
            self.field1 == other.field1 && self.field2 == other.field2 &&
                self.field3 == other.field3
        }
    }
    impl ::prost::Message for ComposedMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.field1 {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
            if let Some(ref msg) = self.field2 {
                    ::prost::encoding::message::encode(2u32, msg, buf);
                }
            if let Some(ref msg) = self.field3 {
                    ::prost::encoding::message::encode(3u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "ComposedMsg";
            match tag {
                1u32 => {
                    let mut value = &mut self.field1;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field1"); error })
                }
                2u32 => {
                    let mut value = &mut self.field2;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field2"); error })
                }
                3u32 => {
                    let mut value = &mut self.field3;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field3"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                        self.field1.as_ref().map_or(0,
                            |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                    self.field2.as_ref().map_or(0,
                        |msg| ::prost::encoding::message::encoded_len(2u32, msg)) +
                self.field3.as_ref().map_or(0,
                    |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.field1 = ::core::option::Option::None;
            self.field2 = ::core::option::Option::None;
            self.field3 = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ComposedMsg {
        fn default() -> Self {
            ComposedMsg {
                field1: ::core::default::Default::default(),
                field2: ::core::default::Default::default(),
                field3: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ComposedMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ComposedMsg");
            let builder =
                {
                    let wrapper = &self.field1;
                    builder.field("field1", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper = &self.field2;
                    builder.field("field2", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper = &self.field3;
                    builder.field("field3", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    pub struct WellKnownMsg {
        #[prost(message, optional, tag = "1")]
        pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for WellKnownMsg {
        #[inline]
        fn clone(&self) -> WellKnownMsg {
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<::prost_types::Timestamp>>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for WellKnownMsg { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for WellKnownMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for WellKnownMsg {
        #[inline]
        fn eq(&self, other: &WellKnownMsg) -> bool {
            self.timestamp == other.timestamp
        }
    }
    impl ::prost::Message for WellKnownMsg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.timestamp {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "WellKnownMsg";
            match tag {
                1u32 => {
                    let mut value = &mut self.timestamp;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "timestamp"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.timestamp.as_ref().map_or(0,
                    |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) { self.timestamp = ::core::option::Option::None; }
    }
    impl ::core::default::Default for WellKnownMsg {
        fn default() -> Self {
            WellKnownMsg { timestamp: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for WellKnownMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("WellKnownMsg");
            let builder =
                {
                    let wrapper = &self.timestamp;
                    builder.field("timestamp", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[repr(i32)]
    pub enum AnEnum { A = 0, B = 1, }
    #[automatically_derived]
    impl ::core::clone::Clone for AnEnum {
        #[inline]
        fn clone(&self) -> AnEnum { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AnEnum { }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnEnum {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self { AnEnum::A => "A", AnEnum::B => "B", })
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnEnum { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnEnum {
        #[inline]
        fn eq(&self, other: &AnEnum) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for AnEnum {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for AnEnum {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for AnEnum {
        #[inline]
        fn partial_cmp(&self, other: &AnEnum)
            -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for AnEnum {
        #[inline]
        fn cmp(&self, other: &AnEnum) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl AnEnum {
        #[doc = "Returns `true` if `value` is a variant of `AnEnum`."]
        pub fn is_valid(value: i32) -> bool {
            match value { 0 => true, 1 => true, _ => false, }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `AnEnum`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32) -> ::core::option::Option<AnEnum> {
            match value {
                0 => ::core::option::Option::Some(AnEnum::A),
                1 => ::core::option::Option::Some(AnEnum::B),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for AnEnum {
        fn default() -> AnEnum { AnEnum::A }
    }
    impl ::core::convert::From<AnEnum> for i32 {
        fn from(value: AnEnum) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for AnEnum {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            -> ::core::result::Result<AnEnum, ::prost::UnknownEnumValue> {
            match value {
                0 => ::core::result::Result::Ok(AnEnum::A),
                1 => ::core::result::Result::Ok(AnEnum::B),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl AnEnum {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self { Self::A => "A", Self::B => "B", }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "A" => Some(Self::A),
                "B" => Some(Self::B),
                _ => None,
            }
        }
    }
    #[allow(dead_code)]
    trait TestCopyIsImplemented: Copy { }
    impl TestCopyIsImplemented for EmptyMsg {}
    impl TestCopyIsImplemented for IntegerMsg {}
    impl TestCopyIsImplemented for FloatMsg {}
    impl TestCopyIsImplemented for BoolMsg {}
    impl TestCopyIsImplemented for AnEnum {}
    impl TestCopyIsImplemented for EnumMsg {}
    impl TestCopyIsImplemented for OneOfMsg {}
    impl TestCopyIsImplemented for ComposedMsg {}
    impl TestCopyIsImplemented for WellKnownMsg {}
}
#[cfg(test)]
mod enum_keyword_variant {
    mod enum_keyword_variant {
        #[repr(i32)]
        pub enum Feeding {
            Unspecified = 0,
            Assisted = 1,

            /// Careful: code generation resulted in "Self". Now it is "Self_".
            Self_ = 2,
            Else = 3,
            Error = 4,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Feeding {
            #[inline]
            fn clone(&self) -> Feeding { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Feeding { }
        #[automatically_derived]
        impl ::core::fmt::Debug for Feeding {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        Feeding::Unspecified => "Unspecified",
                        Feeding::Assisted => "Assisted",
                        Feeding::Self_ => "Self_",
                        Feeding::Else => "Else",
                        Feeding::Error => "Error",
                    })
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Feeding { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Feeding {
            #[inline]
            fn eq(&self, other: &Feeding) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Feeding {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Feeding {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Feeding {
            #[inline]
            fn partial_cmp(&self, other: &Feeding)
                -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                    &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Feeding {
            #[inline]
            fn cmp(&self, other: &Feeding) -> ::core::cmp::Ordering {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        impl Feeding {
            #[doc = "Returns `true` if `value` is a variant of `Feeding`."]
            pub fn is_valid(value: i32) -> bool {
                match value {
                    0 => true,
                    1 => true,
                    2 => true,
                    3 => true,
                    4 => true,
                    _ => false,
                }
            }
            #[deprecated = "Use the TryFrom<i32> implementation instead"]
            #[doc =
            "Converts an `i32` to a `Feeding`, or `None` if `value` is not a valid variant."]
            pub fn from_i32(value: i32) -> ::core::option::Option<Feeding> {
                match value {
                    0 => ::core::option::Option::Some(Feeding::Unspecified),
                    1 => ::core::option::Option::Some(Feeding::Assisted),
                    2 => ::core::option::Option::Some(Feeding::Self_),
                    3 => ::core::option::Option::Some(Feeding::Else),
                    4 => ::core::option::Option::Some(Feeding::Error),
                    _ => ::core::option::Option::None,
                }
            }
        }
        impl ::core::default::Default for Feeding {
            fn default() -> Feeding { Feeding::Unspecified }
        }
        impl ::core::convert::From<Feeding> for i32 {
            fn from(value: Feeding) -> i32 { value as i32 }
        }
        impl ::core::convert::TryFrom<i32> for Feeding {
            type Error = ::prost::UnknownEnumValue;
            fn try_from(value: i32)
                ->
                    ::core::result::Result<Feeding, ::prost::UnknownEnumValue> {
                match value {
                    0 => ::core::result::Result::Ok(Feeding::Unspecified),
                    1 => ::core::result::Result::Ok(Feeding::Assisted),
                    2 => ::core::result::Result::Ok(Feeding::Self_),
                    3 => ::core::result::Result::Ok(Feeding::Else),
                    4 => ::core::result::Result::Ok(Feeding::Error),
                    _ =>
                        ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                }
            }
        }
        impl Feeding {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FEEDING_UNSPECIFIED",
                    Self::Assisted => "FEEDING_ASSISTED",
                    Self::Self_ => "FEEDING_SELF",
                    Self::Else => "FEEDING_ELSE",
                    Self::Error => "FEEDING_ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str)
                -> ::core::option::Option<Self> {
                match value {
                    "FEEDING_UNSPECIFIED" => Some(Self::Unspecified),
                    "FEEDING_ASSISTED" => Some(Self::Assisted),
                    "FEEDING_SELF" => Some(Self::Self_),
                    "FEEDING_ELSE" => Some(Self::Else),
                    "FEEDING_ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
        #[repr(i32)]
        pub enum Grooming {
            Unspecified = 0,
            Assisted = 1,
            Self_ = 2,
            Else = 3,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Grooming {
            #[inline]
            fn clone(&self) -> Grooming { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Grooming { }
        #[automatically_derived]
        impl ::core::fmt::Debug for Grooming {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        Grooming::Unspecified => "Unspecified",
                        Grooming::Assisted => "Assisted",
                        Grooming::Self_ => "Self_",
                        Grooming::Else => "Else",
                    })
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Grooming { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Grooming {
            #[inline]
            fn eq(&self, other: &Grooming) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Grooming {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Grooming {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Grooming {
            #[inline]
            fn partial_cmp(&self, other: &Grooming)
                -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                    &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Grooming {
            #[inline]
            fn cmp(&self, other: &Grooming) -> ::core::cmp::Ordering {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        impl Grooming {
            #[doc = "Returns `true` if `value` is a variant of `Grooming`."]
            pub fn is_valid(value: i32) -> bool {
                match value {
                    0 => true,
                    1 => true,
                    2 => true,
                    3 => true,
                    _ => false,
                }
            }
            #[deprecated = "Use the TryFrom<i32> implementation instead"]
            #[doc =
            "Converts an `i32` to a `Grooming`, or `None` if `value` is not a valid variant."]
            pub fn from_i32(value: i32) -> ::core::option::Option<Grooming> {
                match value {
                    0 => ::core::option::Option::Some(Grooming::Unspecified),
                    1 => ::core::option::Option::Some(Grooming::Assisted),
                    2 => ::core::option::Option::Some(Grooming::Self_),
                    3 => ::core::option::Option::Some(Grooming::Else),
                    _ => ::core::option::Option::None,
                }
            }
        }
        impl ::core::default::Default for Grooming {
            fn default() -> Grooming { Grooming::Unspecified }
        }
        impl ::core::convert::From<Grooming> for i32 {
            fn from(value: Grooming) -> i32 { value as i32 }
        }
        impl ::core::convert::TryFrom<i32> for Grooming {
            type Error = ::prost::UnknownEnumValue;
            fn try_from(value: i32)
                ->
                    ::core::result::Result<Grooming,
                    ::prost::UnknownEnumValue> {
                match value {
                    0 => ::core::result::Result::Ok(Grooming::Unspecified),
                    1 => ::core::result::Result::Ok(Grooming::Assisted),
                    2 => ::core::result::Result::Ok(Grooming::Self_),
                    3 => ::core::result::Result::Ok(Grooming::Else),
                    _ =>
                        ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                }
            }
        }
        impl Grooming {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Assisted => "ASSISTED",
                    Self::Self_ => "SELF",
                    Self::Else => "ELSE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str)
                -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ASSISTED" => Some(Self::Assisted),
                    "SELF" => Some(Self::Self_),
                    "ELSE" => Some(Self::Else),
                    _ => None,
                }
            }
        }
        #[repr(i32)]
        pub enum Number { Unspecified = 0, Number1 = 1, }
        #[automatically_derived]
        impl ::core::clone::Clone for Number {
            #[inline]
            fn clone(&self) -> Number { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Number { }
        #[automatically_derived]
        impl ::core::fmt::Debug for Number {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        Number::Unspecified => "Unspecified",
                        Number::Number1 => "Number1",
                    })
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Number { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Number {
            #[inline]
            fn eq(&self, other: &Number) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Number {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Number {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Number {
            #[inline]
            fn partial_cmp(&self, other: &Number)
                -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                    &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Number {
            #[inline]
            fn cmp(&self, other: &Number) -> ::core::cmp::Ordering {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        impl Number {
            #[doc = "Returns `true` if `value` is a variant of `Number`."]
            pub fn is_valid(value: i32) -> bool {
                match value { 0 => true, 1 => true, _ => false, }
            }
            #[deprecated = "Use the TryFrom<i32> implementation instead"]
            #[doc =
            "Converts an `i32` to a `Number`, or `None` if `value` is not a valid variant."]
            pub fn from_i32(value: i32) -> ::core::option::Option<Number> {
                match value {
                    0 => ::core::option::Option::Some(Number::Unspecified),
                    1 => ::core::option::Option::Some(Number::Number1),
                    _ => ::core::option::Option::None,
                }
            }
        }
        impl ::core::default::Default for Number {
            fn default() -> Number { Number::Unspecified }
        }
        impl ::core::convert::From<Number> for i32 {
            fn from(value: Number) -> i32 { value as i32 }
        }
        impl ::core::convert::TryFrom<i32> for Number {
            type Error = ::prost::UnknownEnumValue;
            fn try_from(value: i32)
                -> ::core::result::Result<Number, ::prost::UnknownEnumValue> {
                match value {
                    0 => ::core::result::Result::Ok(Number::Unspecified),
                    1 => ::core::result::Result::Ok(Number::Number1),
                    _ =>
                        ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                }
            }
        }
        impl Number {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "NUMBER_UNSPECIFIED",
                    Self::Number1 => "NUMBER_1",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str)
                -> ::core::option::Option<Self> {
                match value {
                    "NUMBER_UNSPECIFIED" => Some(Self::Unspecified),
                    "NUMBER_1" => Some(Self::Number1),
                    _ => None,
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "enum_keyword_variant::dummy"]
    #[doc(hidden)]
    pub const dummy: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("enum_keyword_variant::dummy"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/enum_keyword_variant.rs",
                start_line: 6usize,
                start_col: 4usize,
                end_line: 6usize,
                end_col: 9usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(dummy())),
        };
    fn dummy() {}
}
#[cfg(test)]
mod generic_derive {
    pub trait CustomType: prost::Message + Default {}
    impl CustomType for u64 {}
    enum GenericEnum<A: CustomType> {

        #[prost(message, tag = "1")]
        Data(GenericMessage<A>),

        #[prost(uint64, tag = "2")]
        #[allow(dead_code)]
        Number(u64),
    }
    #[automatically_derived]
    impl<A: ::core::clone::Clone + CustomType> ::core::clone::Clone for
        GenericEnum<A> {
        #[inline]
        fn clone(&self) -> GenericEnum<A> {
            match self {
                GenericEnum::Data(__self_0) =>
                    GenericEnum::Data(::core::clone::Clone::clone(__self_0)),
                GenericEnum::Number(__self_0) =>
                    GenericEnum::Number(::core::clone::Clone::clone(__self_0)),
            }
        }
    }
    impl<A: CustomType> GenericEnum<A> {
        #[doc = r" Encodes the message to a buffer."]
        pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
            match *self {
                GenericEnum::Data(ref value) => {
                    ::prost::encoding::message::encode(1u32, &*value, buf);
                }
                GenericEnum::Number(ref value) => {
                    ::prost::encoding::uint64::encode(2u32, &*value, buf);
                }
            }
        }
        #[doc =
        r" Decodes an instance of the message from a buffer, and merges it into self."]
        pub fn merge(field: &mut ::core::option::Option<GenericEnum<A>>,
            tag: u32, wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                1u32 => {
                    match field {
                        ::core::option::Option::Some(GenericEnum::Data(ref mut value))
                            => {
                            ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf,
                                    ctx).map(|_|
                                    *field =
                                        ::core::option::Option::Some(GenericEnum::Data(owned_value)))
                        }
                    }
                }
                2u32 => {
                    match field {
                        ::core::option::Option::Some(GenericEnum::Number(ref mut value))
                            => {
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map(|_|
                                    *field =
                                        ::core::option::Option::Some(GenericEnum::Number(owned_value)))
                        }
                    }
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("invalid GenericEnum tag: {0}", tag)));
                }
            }
        }
        #[doc =
        r" Returns the encoded length of the message without a length delimiter."]
        #[inline]
        pub fn encoded_len(&self) -> usize {
            match *self {
                GenericEnum::Data(ref value) =>
                    ::prost::encoding::message::encoded_len(1u32, &*value),
                GenericEnum::Number(ref value) =>
                    ::prost::encoding::uint64::encoded_len(2u32, &*value),
            }
        }
    }
    impl<A: CustomType> ::core::fmt::Debug for GenericEnum<A> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                GenericEnum::Data(ref value) => {
                    let wrapper = &*value;
                    f.debug_tuple("Data").field(&wrapper).finish()
                }
                GenericEnum::Number(ref value) => {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&*value)
                        };
                    f.debug_tuple("Number").field(&wrapper).finish()
                }
            }
        }
    }
    struct GenericMessage<A: CustomType> {
        #[prost(message, tag = "1")]
        data: Option<A>,
    }
    #[automatically_derived]
    impl<A: ::core::clone::Clone + CustomType> ::core::clone::Clone for
        GenericMessage<A> {
        #[inline]
        fn clone(&self) -> GenericMessage<A> {
            GenericMessage { data: ::core::clone::Clone::clone(&self.data) }
        }
    }
    impl<A: CustomType> ::prost::Message for GenericMessage<A> {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.data {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "GenericMessage";
            match tag {
                1u32 => {
                    let mut value = &mut self.data;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "data"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.data.as_ref().map_or(0,
                    |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) { self.data = ::core::option::Option::None; }
    }
    impl<A: CustomType> ::core::default::Default for GenericMessage<A> {
        fn default() -> Self {
            GenericMessage { data: ::core::default::Default::default() }
        }
    }
    impl<A: CustomType> ::core::fmt::Debug for GenericMessage<A> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GenericMessage");
            let builder =
                { let wrapper = &self.data; builder.field("data", &wrapper) };
            ;
            builder.finish()
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "generic_derive::generic_enum"]
    #[doc(hidden)]
    pub const generic_enum: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("generic_derive::generic_enum"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/generic_derive.rs",
                start_line: 21usize,
                start_col: 4usize,
                end_line: 21usize,
                end_col: 16usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(generic_enum())),
        };
    fn generic_enum() {
        let msg = GenericMessage { data: Some(100u64) };
        let enumeration = GenericEnum::Data(msg);
        match enumeration {
            GenericEnum::Data(d) =>
                match (&100, &d.data.unwrap()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(kind, &*left_val,
                                    &*right_val, ::core::option::Option::None);
                            }
                    }
                },
            GenericEnum::Number(_) => {
                ::core::panicking::panic_fmt(format_args!("Not supposed to reach"));
            }
        }
    }
}
#[cfg(test)]
mod message_encoding {
    use prost::alloc::vec;
    use prost::bytes::Bytes;
    use prost::OpenEnum;
    use prost::{Enumeration, Message, Oneof};
    use crate::check_message;
    use crate::check_serialize_equivalent;
    pub struct RepeatedFloats {
        #[prost(float, tag = "11")]
        pub single_float: f32,
        #[prost(float, repeated, packed = "true", tag = "41")]
        pub repeated_float: Vec<f32>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RepeatedFloats {
        #[inline]
        fn clone(&self) -> RepeatedFloats {
            RepeatedFloats {
                single_float: ::core::clone::Clone::clone(&self.single_float),
                repeated_float: ::core::clone::Clone::clone(&self.repeated_float),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RepeatedFloats { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RepeatedFloats {
        #[inline]
        fn eq(&self, other: &RepeatedFloats) -> bool {
            self.single_float == other.single_float &&
                self.repeated_float == other.repeated_float
        }
    }
    impl ::prost::Message for RepeatedFloats {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.single_float != 0f32 {
                    ::prost::encoding::float::encode(11u32, &self.single_float,
                        buf);
                }
            ::prost::encoding::float::encode_packed(41u32,
                &self.repeated_float, buf);
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "RepeatedFloats";
            match tag {
                11u32 => {
                    let mut value = &mut self.single_float;
                    ::prost::encoding::float::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "single_float"); error })
                }
                41u32 => {
                    let mut value = &mut self.repeated_float;
                    ::prost::encoding::float::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_float"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                    if self.single_float != 0f32 {
                            ::prost::encoding::float::encoded_len(11u32,
                                &self.single_float)
                        } else { 0 } +
                ::prost::encoding::float::encoded_len_packed(41u32,
                    &self.repeated_float)
        }
        fn clear(&mut self) {
            self.single_float = 0f32;
            self.repeated_float.clear();
        }
    }
    impl ::core::default::Default for RepeatedFloats {
        fn default() -> Self {
            RepeatedFloats {
                single_float: 0f32,
                repeated_float: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for RepeatedFloats {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RepeatedFloats");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.single_float)
                        };
                    builder.field("single_float", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_float)
                        };
                    builder.field("repeated_float", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "message_encoding::check_repeated_floats"]
    #[doc(hidden)]
    pub const check_repeated_floats: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("message_encoding::check_repeated_floats"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/message_encoding.rs",
                start_line: 21usize,
                start_col: 4usize,
                end_line: 21usize,
                end_col: 25usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(check_repeated_floats())),
        };
    fn check_repeated_floats() {
        check_message(&RepeatedFloats {
                    single_float: 0.0,
                    repeated_float: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.1,
                                    340282300000000000000000000000000000000.0,
                                    0.000000000000000000000000000000000000011754944])),
                });
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "message_encoding::check_scalar_types"]
    #[doc(hidden)]
    pub const check_scalar_types: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("message_encoding::check_scalar_types"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/message_encoding.rs",
                start_line: 33usize,
                start_col: 4usize,
                end_line: 33usize,
                end_col: 22usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(check_scalar_types())),
        };
    fn check_scalar_types() { check_message(&ScalarTypes::default()); }
    /// A protobuf message which contains all scalar types.
    pub struct ScalarTypes {
        #[prost(int32, tag = "001")]
        pub int32: i32,
        #[prost(int64, tag = "002")]
        pub int64: i64,
        #[prost(uint32, tag = "003")]
        pub uint32: u32,
        #[prost(uint64, tag = "004")]
        pub uint64: u64,
        #[prost(sint32, tag = "005")]
        pub sint32: i32,
        #[prost(sint64, tag = "006")]
        pub sint64: i64,
        #[prost(fixed32, tag = "007")]
        pub fixed32: u32,
        #[prost(fixed64, tag = "008")]
        pub fixed64: u64,
        #[prost(sfixed32, tag = "009")]
        pub sfixed32: i32,
        #[prost(sfixed64, tag = "010")]
        pub sfixed64: i64,
        #[prost(float, tag = "011")]
        pub float: f32,
        #[prost(double, tag = "012")]
        pub double: f64,
        #[prost(bool, tag = "013")]
        pub _bool: bool,
        #[prost(string, tag = "014")]
        pub string: String,
        #[prost(bytes = "vec", tag = "015")]
        pub bytes_vec: Vec<u8>,
        #[prost(bytes = "bytes", tag = "016")]
        pub bytes_buf: Bytes,
        #[prost(int32, required, tag = "101")]
        pub required_int32: i32,
        #[prost(int64, required, tag = "102")]
        pub required_int64: i64,
        #[prost(uint32, required, tag = "103")]
        pub required_uint32: u32,
        #[prost(uint64, required, tag = "104")]
        pub required_uint64: u64,
        #[prost(sint32, required, tag = "105")]
        pub required_sint32: i32,
        #[prost(sint64, required, tag = "106")]
        pub required_sint64: i64,
        #[prost(fixed32, required, tag = "107")]
        pub required_fixed32: u32,
        #[prost(fixed64, required, tag = "108")]
        pub required_fixed64: u64,
        #[prost(sfixed32, required, tag = "109")]
        pub required_sfixed32: i32,
        #[prost(sfixed64, required, tag = "110")]
        pub required_sfixed64: i64,
        #[prost(float, required, tag = "111")]
        pub required_float: f32,
        #[prost(double, required, tag = "112")]
        pub required_double: f64,
        #[prost(bool, required, tag = "113")]
        pub required_bool: bool,
        #[prost(string, required, tag = "114")]
        pub required_string: String,
        #[prost(bytes = "vec", required, tag = "115")]
        pub required_bytes_vec: Vec<u8>,
        #[prost(bytes = "bytes", required, tag = "116")]
        pub required_bytes_buf: Bytes,
        #[prost(int32, optional, tag = "201")]
        pub optional_int32: Option<i32>,
        #[prost(int64, optional, tag = "202")]
        pub optional_int64: Option<i64>,
        #[prost(uint32, optional, tag = "203")]
        pub optional_uint32: Option<u32>,
        #[prost(uint64, optional, tag = "204")]
        pub optional_uint64: Option<u64>,
        #[prost(sint32, optional, tag = "205")]
        pub optional_sint32: Option<i32>,
        #[prost(sint64, optional, tag = "206")]
        pub optional_sint64: Option<i64>,
        #[prost(fixed32, optional, tag = "207")]
        pub optional_fixed32: Option<u32>,
        #[prost(fixed64, optional, tag = "208")]
        pub optional_fixed64: Option<u64>,
        #[prost(sfixed32, optional, tag = "209")]
        pub optional_sfixed32: Option<i32>,
        #[prost(sfixed64, optional, tag = "210")]
        pub optional_sfixed64: Option<i64>,
        #[prost(float, optional, tag = "211")]
        pub optional_float: Option<f32>,
        #[prost(double, optional, tag = "212")]
        pub optional_double: Option<f64>,
        #[prost(bool, optional, tag = "213")]
        pub optional_bool: Option<bool>,
        #[prost(string, optional, tag = "214")]
        pub optional_string: Option<String>,
        #[prost(bytes = "vec", optional, tag = "215")]
        pub optional_bytes_vec: Option<Vec<u8>>,
        #[prost(bytes = "bytes", optional, tag = "216")]
        pub optional_bytes_buf: Option<Bytes>,
        #[prost(int32, repeated, packed = "false", tag = "301")]
        pub repeated_int32: Vec<i32>,
        #[prost(int64, repeated, packed = "false", tag = "302")]
        pub repeated_int64: Vec<i64>,
        #[prost(uint32, repeated, packed = "false", tag = "303")]
        pub repeated_uint32: Vec<u32>,
        #[prost(uint64, repeated, packed = "false", tag = "304")]
        pub repeated_uint64: Vec<u64>,
        #[prost(sint32, repeated, packed = "false", tag = "305")]
        pub repeated_sint32: Vec<i32>,
        #[prost(sint64, repeated, packed = "false", tag = "306")]
        pub repeated_sint64: Vec<i64>,
        #[prost(fixed32, repeated, packed = "false", tag = "307")]
        pub repeated_fixed32: Vec<u32>,
        #[prost(fixed64, repeated, packed = "false", tag = "308")]
        pub repeated_fixed64: Vec<u64>,
        #[prost(sfixed32, repeated, packed = "false", tag = "309")]
        pub repeated_sfixed32: Vec<i32>,
        #[prost(sfixed64, repeated, packed = "false", tag = "310")]
        pub repeated_sfixed64: Vec<i64>,
        #[prost(float, repeated, packed = "false", tag = "311")]
        pub repeated_float: Vec<f32>,
        #[prost(double, repeated, packed = "false", tag = "312")]
        pub repeated_double: Vec<f64>,
        #[prost(bool, repeated, packed = "false", tag = "313")]
        pub repeated_bool: Vec<bool>,
        #[prost(string, repeated, packed = "false", tag = "315")]
        pub repeated_string: Vec<String>,
        #[prost(bytes = "vec", repeated, packed = "false", tag = "316")]
        pub repeated_bytes_vec: Vec<Vec<u8>>,
        #[prost(bytes = "bytes", repeated, packed = "false", tag = "317")]
        pub repeated_bytes_buf: Vec<Bytes>,
        #[prost(int32, repeated, tag = "401")]
        pub packed_int32: Vec<i32>,
        #[prost(int64, repeated, tag = "402")]
        pub packed_int64: Vec<i64>,
        #[prost(uint32, repeated, tag = "403")]
        pub packed_uint32: Vec<u32>,
        #[prost(uint64, repeated, tag = "404")]
        pub packed_uint64: Vec<u64>,
        #[prost(sint32, repeated, tag = "405")]
        pub packed_sint32: Vec<i32>,
        #[prost(sint64, repeated, tag = "406")]
        pub packed_sint64: Vec<i64>,
        #[prost(fixed32, repeated, tag = "407")]
        pub packed_fixed32: Vec<u32>,
        #[prost(fixed64, repeated, tag = "408")]
        pub packed_fixed64: Vec<u64>,
        #[prost(sfixed32, repeated, tag = "409")]
        pub packed_sfixed32: Vec<i32>,
        #[prost(sfixed64, repeated, tag = "410")]
        pub packed_sfixed64: Vec<i64>,
        #[prost(float, repeated, tag = "411")]
        pub packed_float: Vec<f32>,
        #[prost(double, repeated, tag = "412")]
        pub packed_double: Vec<f64>,
        #[prost(bool, repeated, tag = "413")]
        pub packed_bool: Vec<bool>,
        #[prost(string, repeated, tag = "415")]
        pub packed_string: Vec<String>,
        #[prost(bytes = "vec", repeated, tag = "416")]
        pub packed_bytes_vec: Vec<Vec<u8>>,
        #[prost(bytes = "bytes", repeated, tag = "417")]
        pub packed_bytes_buf: Vec<Bytes>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ScalarTypes {
        #[inline]
        fn clone(&self) -> ScalarTypes {
            ScalarTypes {
                int32: ::core::clone::Clone::clone(&self.int32),
                int64: ::core::clone::Clone::clone(&self.int64),
                uint32: ::core::clone::Clone::clone(&self.uint32),
                uint64: ::core::clone::Clone::clone(&self.uint64),
                sint32: ::core::clone::Clone::clone(&self.sint32),
                sint64: ::core::clone::Clone::clone(&self.sint64),
                fixed32: ::core::clone::Clone::clone(&self.fixed32),
                fixed64: ::core::clone::Clone::clone(&self.fixed64),
                sfixed32: ::core::clone::Clone::clone(&self.sfixed32),
                sfixed64: ::core::clone::Clone::clone(&self.sfixed64),
                float: ::core::clone::Clone::clone(&self.float),
                double: ::core::clone::Clone::clone(&self.double),
                _bool: ::core::clone::Clone::clone(&self._bool),
                string: ::core::clone::Clone::clone(&self.string),
                bytes_vec: ::core::clone::Clone::clone(&self.bytes_vec),
                bytes_buf: ::core::clone::Clone::clone(&self.bytes_buf),
                required_int32: ::core::clone::Clone::clone(&self.required_int32),
                required_int64: ::core::clone::Clone::clone(&self.required_int64),
                required_uint32: ::core::clone::Clone::clone(&self.required_uint32),
                required_uint64: ::core::clone::Clone::clone(&self.required_uint64),
                required_sint32: ::core::clone::Clone::clone(&self.required_sint32),
                required_sint64: ::core::clone::Clone::clone(&self.required_sint64),
                required_fixed32: ::core::clone::Clone::clone(&self.required_fixed32),
                required_fixed64: ::core::clone::Clone::clone(&self.required_fixed64),
                required_sfixed32: ::core::clone::Clone::clone(&self.required_sfixed32),
                required_sfixed64: ::core::clone::Clone::clone(&self.required_sfixed64),
                required_float: ::core::clone::Clone::clone(&self.required_float),
                required_double: ::core::clone::Clone::clone(&self.required_double),
                required_bool: ::core::clone::Clone::clone(&self.required_bool),
                required_string: ::core::clone::Clone::clone(&self.required_string),
                required_bytes_vec: ::core::clone::Clone::clone(&self.required_bytes_vec),
                required_bytes_buf: ::core::clone::Clone::clone(&self.required_bytes_buf),
                optional_int32: ::core::clone::Clone::clone(&self.optional_int32),
                optional_int64: ::core::clone::Clone::clone(&self.optional_int64),
                optional_uint32: ::core::clone::Clone::clone(&self.optional_uint32),
                optional_uint64: ::core::clone::Clone::clone(&self.optional_uint64),
                optional_sint32: ::core::clone::Clone::clone(&self.optional_sint32),
                optional_sint64: ::core::clone::Clone::clone(&self.optional_sint64),
                optional_fixed32: ::core::clone::Clone::clone(&self.optional_fixed32),
                optional_fixed64: ::core::clone::Clone::clone(&self.optional_fixed64),
                optional_sfixed32: ::core::clone::Clone::clone(&self.optional_sfixed32),
                optional_sfixed64: ::core::clone::Clone::clone(&self.optional_sfixed64),
                optional_float: ::core::clone::Clone::clone(&self.optional_float),
                optional_double: ::core::clone::Clone::clone(&self.optional_double),
                optional_bool: ::core::clone::Clone::clone(&self.optional_bool),
                optional_string: ::core::clone::Clone::clone(&self.optional_string),
                optional_bytes_vec: ::core::clone::Clone::clone(&self.optional_bytes_vec),
                optional_bytes_buf: ::core::clone::Clone::clone(&self.optional_bytes_buf),
                repeated_int32: ::core::clone::Clone::clone(&self.repeated_int32),
                repeated_int64: ::core::clone::Clone::clone(&self.repeated_int64),
                repeated_uint32: ::core::clone::Clone::clone(&self.repeated_uint32),
                repeated_uint64: ::core::clone::Clone::clone(&self.repeated_uint64),
                repeated_sint32: ::core::clone::Clone::clone(&self.repeated_sint32),
                repeated_sint64: ::core::clone::Clone::clone(&self.repeated_sint64),
                repeated_fixed32: ::core::clone::Clone::clone(&self.repeated_fixed32),
                repeated_fixed64: ::core::clone::Clone::clone(&self.repeated_fixed64),
                repeated_sfixed32: ::core::clone::Clone::clone(&self.repeated_sfixed32),
                repeated_sfixed64: ::core::clone::Clone::clone(&self.repeated_sfixed64),
                repeated_float: ::core::clone::Clone::clone(&self.repeated_float),
                repeated_double: ::core::clone::Clone::clone(&self.repeated_double),
                repeated_bool: ::core::clone::Clone::clone(&self.repeated_bool),
                repeated_string: ::core::clone::Clone::clone(&self.repeated_string),
                repeated_bytes_vec: ::core::clone::Clone::clone(&self.repeated_bytes_vec),
                repeated_bytes_buf: ::core::clone::Clone::clone(&self.repeated_bytes_buf),
                packed_int32: ::core::clone::Clone::clone(&self.packed_int32),
                packed_int64: ::core::clone::Clone::clone(&self.packed_int64),
                packed_uint32: ::core::clone::Clone::clone(&self.packed_uint32),
                packed_uint64: ::core::clone::Clone::clone(&self.packed_uint64),
                packed_sint32: ::core::clone::Clone::clone(&self.packed_sint32),
                packed_sint64: ::core::clone::Clone::clone(&self.packed_sint64),
                packed_fixed32: ::core::clone::Clone::clone(&self.packed_fixed32),
                packed_fixed64: ::core::clone::Clone::clone(&self.packed_fixed64),
                packed_sfixed32: ::core::clone::Clone::clone(&self.packed_sfixed32),
                packed_sfixed64: ::core::clone::Clone::clone(&self.packed_sfixed64),
                packed_float: ::core::clone::Clone::clone(&self.packed_float),
                packed_double: ::core::clone::Clone::clone(&self.packed_double),
                packed_bool: ::core::clone::Clone::clone(&self.packed_bool),
                packed_string: ::core::clone::Clone::clone(&self.packed_string),
                packed_bytes_vec: ::core::clone::Clone::clone(&self.packed_bytes_vec),
                packed_bytes_buf: ::core::clone::Clone::clone(&self.packed_bytes_buf),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ScalarTypes { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ScalarTypes {
        #[inline]
        fn eq(&self, other: &ScalarTypes) -> bool {
            self.int32 == other.int32 && self.int64 == other.int64 &&
                                                                                                                                                                                                                                                                                                                                    self.uint32 == other.uint32 && self.uint64 == other.uint64
                                                                                                                                                                                                                                                                                                                            && self.sint32 == other.sint32 &&
                                                                                                                                                                                                                                                                                                                        self.sint64 == other.sint64 && self.fixed32 == other.fixed32
                                                                                                                                                                                                                                                                                                                && self.fixed64 == other.fixed64 &&
                                                                                                                                                                                                                                                                                                            self.sfixed32 == other.sfixed32 &&
                                                                                                                                                                                                                                                                                                        self.sfixed64 == other.sfixed64 && self.float == other.float
                                                                                                                                                                                                                                                                                                && self.double == other.double && self._bool == other._bool
                                                                                                                                                                                                                                                                                        && self.string == other.string &&
                                                                                                                                                                                                                                                                                    self.bytes_vec == other.bytes_vec &&
                                                                                                                                                                                                                                                                                self.bytes_buf == other.bytes_buf &&
                                                                                                                                                                                                                                                                            self.required_int32 == other.required_int32 &&
                                                                                                                                                                                                                                                                        self.required_int64 == other.required_int64 &&
                                                                                                                                                                                                                                                                    self.required_uint32 == other.required_uint32 &&
                                                                                                                                                                                                                                                                self.required_uint64 == other.required_uint64 &&
                                                                                                                                                                                                                                                            self.required_sint32 == other.required_sint32 &&
                                                                                                                                                                                                                                                        self.required_sint64 == other.required_sint64 &&
                                                                                                                                                                                                                                                    self.required_fixed32 == other.required_fixed32 &&
                                                                                                                                                                                                                                                self.required_fixed64 == other.required_fixed64 &&
                                                                                                                                                                                                                                            self.required_sfixed32 == other.required_sfixed32 &&
                                                                                                                                                                                                                                        self.required_sfixed64 == other.required_sfixed64 &&
                                                                                                                                                                                                                                    self.required_float == other.required_float &&
                                                                                                                                                                                                                                self.required_double == other.required_double &&
                                                                                                                                                                                                                            self.required_bool == other.required_bool &&
                                                                                                                                                                                                                        self.required_string == other.required_string &&
                                                                                                                                                                                                                    self.required_bytes_vec == other.required_bytes_vec &&
                                                                                                                                                                                                                self.required_bytes_buf == other.required_bytes_buf &&
                                                                                                                                                                                                            self.optional_int32 == other.optional_int32 &&
                                                                                                                                                                                                        self.optional_int64 == other.optional_int64 &&
                                                                                                                                                                                                    self.optional_uint32 == other.optional_uint32 &&
                                                                                                                                                                                                self.optional_uint64 == other.optional_uint64 &&
                                                                                                                                                                                            self.optional_sint32 == other.optional_sint32 &&
                                                                                                                                                                                        self.optional_sint64 == other.optional_sint64 &&
                                                                                                                                                                                    self.optional_fixed32 == other.optional_fixed32 &&
                                                                                                                                                                                self.optional_fixed64 == other.optional_fixed64 &&
                                                                                                                                                                            self.optional_sfixed32 == other.optional_sfixed32 &&
                                                                                                                                                                        self.optional_sfixed64 == other.optional_sfixed64 &&
                                                                                                                                                                    self.optional_float == other.optional_float &&
                                                                                                                                                                self.optional_double == other.optional_double &&
                                                                                                                                                            self.optional_bool == other.optional_bool &&
                                                                                                                                                        self.optional_string == other.optional_string &&
                                                                                                                                                    self.optional_bytes_vec == other.optional_bytes_vec &&
                                                                                                                                                self.optional_bytes_buf == other.optional_bytes_buf &&
                                                                                                                                            self.repeated_int32 == other.repeated_int32 &&
                                                                                                                                        self.repeated_int64 == other.repeated_int64 &&
                                                                                                                                    self.repeated_uint32 == other.repeated_uint32 &&
                                                                                                                                self.repeated_uint64 == other.repeated_uint64 &&
                                                                                                                            self.repeated_sint32 == other.repeated_sint32 &&
                                                                                                                        self.repeated_sint64 == other.repeated_sint64 &&
                                                                                                                    self.repeated_fixed32 == other.repeated_fixed32 &&
                                                                                                                self.repeated_fixed64 == other.repeated_fixed64 &&
                                                                                                            self.repeated_sfixed32 == other.repeated_sfixed32 &&
                                                                                                        self.repeated_sfixed64 == other.repeated_sfixed64 &&
                                                                                                    self.repeated_float == other.repeated_float &&
                                                                                                self.repeated_double == other.repeated_double &&
                                                                                            self.repeated_bool == other.repeated_bool &&
                                                                                        self.repeated_string == other.repeated_string &&
                                                                                    self.repeated_bytes_vec == other.repeated_bytes_vec &&
                                                                                self.repeated_bytes_buf == other.repeated_bytes_buf &&
                                                                            self.packed_int32 == other.packed_int32 &&
                                                                        self.packed_int64 == other.packed_int64 &&
                                                                    self.packed_uint32 == other.packed_uint32 &&
                                                                self.packed_uint64 == other.packed_uint64 &&
                                                            self.packed_sint32 == other.packed_sint32 &&
                                                        self.packed_sint64 == other.packed_sint64 &&
                                                    self.packed_fixed32 == other.packed_fixed32 &&
                                                self.packed_fixed64 == other.packed_fixed64 &&
                                            self.packed_sfixed32 == other.packed_sfixed32 &&
                                        self.packed_sfixed64 == other.packed_sfixed64 &&
                                    self.packed_float == other.packed_float &&
                                self.packed_double == other.packed_double &&
                            self.packed_bool == other.packed_bool &&
                        self.packed_string == other.packed_string &&
                    self.packed_bytes_vec == other.packed_bytes_vec &&
                self.packed_bytes_buf == other.packed_bytes_buf
        }
    }
    impl ::prost::Message for ScalarTypes {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.int32 != 0i32 {
                    ::prost::encoding::int32::encode(1u32, &self.int32, buf);
                }
            if self.int64 != 0i64 {
                    ::prost::encoding::int64::encode(2u32, &self.int64, buf);
                }
            if self.uint32 != 0u32 {
                    ::prost::encoding::uint32::encode(3u32, &self.uint32, buf);
                }
            if self.uint64 != 0u64 {
                    ::prost::encoding::uint64::encode(4u32, &self.uint64, buf);
                }
            if self.sint32 != 0i32 {
                    ::prost::encoding::sint32::encode(5u32, &self.sint32, buf);
                }
            if self.sint64 != 0i64 {
                    ::prost::encoding::sint64::encode(6u32, &self.sint64, buf);
                }
            if self.fixed32 != 0u32 {
                    ::prost::encoding::fixed32::encode(7u32, &self.fixed32,
                        buf);
                }
            if self.fixed64 != 0u64 {
                    ::prost::encoding::fixed64::encode(8u32, &self.fixed64,
                        buf);
                }
            if self.sfixed32 != 0i32 {
                    ::prost::encoding::sfixed32::encode(9u32, &self.sfixed32,
                        buf);
                }
            if self.sfixed64 != 0i64 {
                    ::prost::encoding::sfixed64::encode(10u32, &self.sfixed64,
                        buf);
                }
            if self.float != 0f32 {
                    ::prost::encoding::float::encode(11u32, &self.float, buf);
                }
            if self.double != 0f64 {
                    ::prost::encoding::double::encode(12u32, &self.double, buf);
                }
            if self._bool != false {
                    ::prost::encoding::bool::encode(13u32, &self._bool, buf);
                }
            if self.string != "" {
                    ::prost::encoding::string::encode(14u32, &self.string, buf);
                }
            if self.bytes_vec != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(15u32, &self.bytes_vec,
                        buf);
                }
            if self.bytes_buf != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(16u32, &self.bytes_buf,
                        buf);
                }
            ::prost::encoding::int32::encode(101u32, &self.required_int32,
                buf);
            ::prost::encoding::int64::encode(102u32, &self.required_int64,
                buf);
            ::prost::encoding::uint32::encode(103u32, &self.required_uint32,
                buf);
            ::prost::encoding::uint64::encode(104u32, &self.required_uint64,
                buf);
            ::prost::encoding::sint32::encode(105u32, &self.required_sint32,
                buf);
            ::prost::encoding::sint64::encode(106u32, &self.required_sint64,
                buf);
            ::prost::encoding::fixed32::encode(107u32, &self.required_fixed32,
                buf);
            ::prost::encoding::fixed64::encode(108u32, &self.required_fixed64,
                buf);
            ::prost::encoding::sfixed32::encode(109u32,
                &self.required_sfixed32, buf);
            ::prost::encoding::sfixed64::encode(110u32,
                &self.required_sfixed64, buf);
            ::prost::encoding::float::encode(111u32, &self.required_float,
                buf);
            ::prost::encoding::double::encode(112u32, &self.required_double,
                buf);
            ::prost::encoding::bool::encode(113u32, &self.required_bool, buf);
            ::prost::encoding::string::encode(114u32, &self.required_string,
                buf);
            ::prost::encoding::bytes::encode(115u32, &self.required_bytes_vec,
                buf);
            ::prost::encoding::bytes::encode(116u32, &self.required_bytes_buf,
                buf);
            if let ::core::option::Option::Some(ref value) =
                        self.optional_int32 {
                    ::prost::encoding::int32::encode(201u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_int64 {
                    ::prost::encoding::int64::encode(202u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_uint32 {
                    ::prost::encoding::uint32::encode(203u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_uint64 {
                    ::prost::encoding::uint64::encode(204u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_sint32 {
                    ::prost::encoding::sint32::encode(205u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_sint64 {
                    ::prost::encoding::sint64::encode(206u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_fixed32 {
                    ::prost::encoding::fixed32::encode(207u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_fixed64 {
                    ::prost::encoding::fixed64::encode(208u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_sfixed32 {
                    ::prost::encoding::sfixed32::encode(209u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_sfixed64 {
                    ::prost::encoding::sfixed64::encode(210u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_float {
                    ::prost::encoding::float::encode(211u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_double {
                    ::prost::encoding::double::encode(212u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_bool {
                    ::prost::encoding::bool::encode(213u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_string {
                    ::prost::encoding::string::encode(214u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_bytes_vec {
                    ::prost::encoding::bytes::encode(215u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.optional_bytes_buf {
                    ::prost::encoding::bytes::encode(216u32, value, buf);
                }
            ::prost::encoding::int32::encode_repeated(301u32,
                &self.repeated_int32, buf);
            ::prost::encoding::int64::encode_repeated(302u32,
                &self.repeated_int64, buf);
            ::prost::encoding::uint32::encode_repeated(303u32,
                &self.repeated_uint32, buf);
            ::prost::encoding::uint64::encode_repeated(304u32,
                &self.repeated_uint64, buf);
            ::prost::encoding::sint32::encode_repeated(305u32,
                &self.repeated_sint32, buf);
            ::prost::encoding::sint64::encode_repeated(306u32,
                &self.repeated_sint64, buf);
            ::prost::encoding::fixed32::encode_repeated(307u32,
                &self.repeated_fixed32, buf);
            ::prost::encoding::fixed64::encode_repeated(308u32,
                &self.repeated_fixed64, buf);
            ::prost::encoding::sfixed32::encode_repeated(309u32,
                &self.repeated_sfixed32, buf);
            ::prost::encoding::sfixed64::encode_repeated(310u32,
                &self.repeated_sfixed64, buf);
            ::prost::encoding::float::encode_repeated(311u32,
                &self.repeated_float, buf);
            ::prost::encoding::double::encode_repeated(312u32,
                &self.repeated_double, buf);
            ::prost::encoding::bool::encode_repeated(313u32,
                &self.repeated_bool, buf);
            ::prost::encoding::string::encode_repeated(315u32,
                &self.repeated_string, buf);
            ::prost::encoding::bytes::encode_repeated(316u32,
                &self.repeated_bytes_vec, buf);
            ::prost::encoding::bytes::encode_repeated(317u32,
                &self.repeated_bytes_buf, buf);
            ::prost::encoding::int32::encode_packed(401u32,
                &self.packed_int32, buf);
            ::prost::encoding::int64::encode_packed(402u32,
                &self.packed_int64, buf);
            ::prost::encoding::uint32::encode_packed(403u32,
                &self.packed_uint32, buf);
            ::prost::encoding::uint64::encode_packed(404u32,
                &self.packed_uint64, buf);
            ::prost::encoding::sint32::encode_packed(405u32,
                &self.packed_sint32, buf);
            ::prost::encoding::sint64::encode_packed(406u32,
                &self.packed_sint64, buf);
            ::prost::encoding::fixed32::encode_packed(407u32,
                &self.packed_fixed32, buf);
            ::prost::encoding::fixed64::encode_packed(408u32,
                &self.packed_fixed64, buf);
            ::prost::encoding::sfixed32::encode_packed(409u32,
                &self.packed_sfixed32, buf);
            ::prost::encoding::sfixed64::encode_packed(410u32,
                &self.packed_sfixed64, buf);
            ::prost::encoding::float::encode_packed(411u32,
                &self.packed_float, buf);
            ::prost::encoding::double::encode_packed(412u32,
                &self.packed_double, buf);
            ::prost::encoding::bool::encode_packed(413u32, &self.packed_bool,
                buf);
            ::prost::encoding::string::encode_repeated(415u32,
                &self.packed_string, buf);
            ::prost::encoding::bytes::encode_repeated(416u32,
                &self.packed_bytes_vec, buf);
            ::prost::encoding::bytes::encode_repeated(417u32,
                &self.packed_bytes_buf, buf);
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "ScalarTypes";
            match tag {
                1u32 => {
                    let mut value = &mut self.int32;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "int32"); error })
                }
                2u32 => {
                    let mut value = &mut self.int64;
                    ::prost::encoding::int64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "int64"); error })
                }
                3u32 => {
                    let mut value = &mut self.uint32;
                    ::prost::encoding::uint32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "uint32"); error })
                }
                4u32 => {
                    let mut value = &mut self.uint64;
                    ::prost::encoding::uint64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "uint64"); error })
                }
                5u32 => {
                    let mut value = &mut self.sint32;
                    ::prost::encoding::sint32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "sint32"); error })
                }
                6u32 => {
                    let mut value = &mut self.sint64;
                    ::prost::encoding::sint64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "sint64"); error })
                }
                7u32 => {
                    let mut value = &mut self.fixed32;
                    ::prost::encoding::fixed32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "fixed32"); error })
                }
                8u32 => {
                    let mut value = &mut self.fixed64;
                    ::prost::encoding::fixed64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "fixed64"); error })
                }
                9u32 => {
                    let mut value = &mut self.sfixed32;
                    ::prost::encoding::sfixed32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "sfixed32"); error })
                }
                10u32 => {
                    let mut value = &mut self.sfixed64;
                    ::prost::encoding::sfixed64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "sfixed64"); error })
                }
                11u32 => {
                    let mut value = &mut self.float;
                    ::prost::encoding::float::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "float"); error })
                }
                12u32 => {
                    let mut value = &mut self.double;
                    ::prost::encoding::double::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "double"); error })
                }
                13u32 => {
                    let mut value = &mut self._bool;
                    ::prost::encoding::bool::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "_bool"); error })
                }
                14u32 => {
                    let mut value = &mut self.string;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "string"); error })
                }
                15u32 => {
                    let mut value = &mut self.bytes_vec;
                    ::prost::encoding::bytes::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "bytes_vec"); error })
                }
                16u32 => {
                    let mut value = &mut self.bytes_buf;
                    ::prost::encoding::bytes::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "bytes_buf"); error })
                }
                101u32 => {
                    let mut value = &mut self.required_int32;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_int32"); error })
                }
                102u32 => {
                    let mut value = &mut self.required_int64;
                    ::prost::encoding::int64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_int64"); error })
                }
                103u32 => {
                    let mut value = &mut self.required_uint32;
                    ::prost::encoding::uint32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_uint32"); error })
                }
                104u32 => {
                    let mut value = &mut self.required_uint64;
                    ::prost::encoding::uint64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_uint64"); error })
                }
                105u32 => {
                    let mut value = &mut self.required_sint32;
                    ::prost::encoding::sint32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_sint32"); error })
                }
                106u32 => {
                    let mut value = &mut self.required_sint64;
                    ::prost::encoding::sint64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_sint64"); error })
                }
                107u32 => {
                    let mut value = &mut self.required_fixed32;
                    ::prost::encoding::fixed32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_fixed32"); error })
                }
                108u32 => {
                    let mut value = &mut self.required_fixed64;
                    ::prost::encoding::fixed64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_fixed64"); error })
                }
                109u32 => {
                    let mut value = &mut self.required_sfixed32;
                    ::prost::encoding::sfixed32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_sfixed32"); error })
                }
                110u32 => {
                    let mut value = &mut self.required_sfixed64;
                    ::prost::encoding::sfixed64::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_sfixed64"); error })
                }
                111u32 => {
                    let mut value = &mut self.required_float;
                    ::prost::encoding::float::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_float"); error })
                }
                112u32 => {
                    let mut value = &mut self.required_double;
                    ::prost::encoding::double::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_double"); error })
                }
                113u32 => {
                    let mut value = &mut self.required_bool;
                    ::prost::encoding::bool::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_bool"); error })
                }
                114u32 => {
                    let mut value = &mut self.required_string;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_string"); error })
                }
                115u32 => {
                    let mut value = &mut self.required_bytes_vec;
                    ::prost::encoding::bytes::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_bytes_vec"); error })
                }
                116u32 => {
                    let mut value = &mut self.required_bytes_buf;
                    ::prost::encoding::bytes::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "required_bytes_buf"); error })
                }
                201u32 => {
                    let mut value = &mut self.optional_int32;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_int32"); error })
                }
                202u32 => {
                    let mut value = &mut self.optional_int64;
                    ::prost::encoding::int64::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_int64"); error })
                }
                203u32 => {
                    let mut value = &mut self.optional_uint32;
                    ::prost::encoding::uint32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_uint32"); error })
                }
                204u32 => {
                    let mut value = &mut self.optional_uint64;
                    ::prost::encoding::uint64::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_uint64"); error })
                }
                205u32 => {
                    let mut value = &mut self.optional_sint32;
                    ::prost::encoding::sint32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_sint32"); error })
                }
                206u32 => {
                    let mut value = &mut self.optional_sint64;
                    ::prost::encoding::sint64::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_sint64"); error })
                }
                207u32 => {
                    let mut value = &mut self.optional_fixed32;
                    ::prost::encoding::fixed32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_fixed32"); error })
                }
                208u32 => {
                    let mut value = &mut self.optional_fixed64;
                    ::prost::encoding::fixed64::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_fixed64"); error })
                }
                209u32 => {
                    let mut value = &mut self.optional_sfixed32;
                    ::prost::encoding::sfixed32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_sfixed32"); error })
                }
                210u32 => {
                    let mut value = &mut self.optional_sfixed64;
                    ::prost::encoding::sfixed64::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_sfixed64"); error })
                }
                211u32 => {
                    let mut value = &mut self.optional_float;
                    ::prost::encoding::float::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_float"); error })
                }
                212u32 => {
                    let mut value = &mut self.optional_double;
                    ::prost::encoding::double::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_double"); error })
                }
                213u32 => {
                    let mut value = &mut self.optional_bool;
                    ::prost::encoding::bool::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_bool"); error })
                }
                214u32 => {
                    let mut value = &mut self.optional_string;
                    ::prost::encoding::string::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_string"); error })
                }
                215u32 => {
                    let mut value = &mut self.optional_bytes_vec;
                    ::prost::encoding::bytes::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_bytes_vec"); error })
                }
                216u32 => {
                    let mut value = &mut self.optional_bytes_buf;
                    ::prost::encoding::bytes::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optional_bytes_buf"); error })
                }
                301u32 => {
                    let mut value = &mut self.repeated_int32;
                    ::prost::encoding::int32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_int32"); error })
                }
                302u32 => {
                    let mut value = &mut self.repeated_int64;
                    ::prost::encoding::int64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_int64"); error })
                }
                303u32 => {
                    let mut value = &mut self.repeated_uint32;
                    ::prost::encoding::uint32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_uint32"); error })
                }
                304u32 => {
                    let mut value = &mut self.repeated_uint64;
                    ::prost::encoding::uint64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_uint64"); error })
                }
                305u32 => {
                    let mut value = &mut self.repeated_sint32;
                    ::prost::encoding::sint32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_sint32"); error })
                }
                306u32 => {
                    let mut value = &mut self.repeated_sint64;
                    ::prost::encoding::sint64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_sint64"); error })
                }
                307u32 => {
                    let mut value = &mut self.repeated_fixed32;
                    ::prost::encoding::fixed32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_fixed32"); error })
                }
                308u32 => {
                    let mut value = &mut self.repeated_fixed64;
                    ::prost::encoding::fixed64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_fixed64"); error })
                }
                309u32 => {
                    let mut value = &mut self.repeated_sfixed32;
                    ::prost::encoding::sfixed32::merge_repeated(wire_type,
                            value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_sfixed32"); error })
                }
                310u32 => {
                    let mut value = &mut self.repeated_sfixed64;
                    ::prost::encoding::sfixed64::merge_repeated(wire_type,
                            value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_sfixed64"); error })
                }
                311u32 => {
                    let mut value = &mut self.repeated_float;
                    ::prost::encoding::float::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_float"); error })
                }
                312u32 => {
                    let mut value = &mut self.repeated_double;
                    ::prost::encoding::double::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_double"); error })
                }
                313u32 => {
                    let mut value = &mut self.repeated_bool;
                    ::prost::encoding::bool::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_bool"); error })
                }
                315u32 => {
                    let mut value = &mut self.repeated_string;
                    ::prost::encoding::string::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_string"); error })
                }
                316u32 => {
                    let mut value = &mut self.repeated_bytes_vec;
                    ::prost::encoding::bytes::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_bytes_vec"); error })
                }
                317u32 => {
                    let mut value = &mut self.repeated_bytes_buf;
                    ::prost::encoding::bytes::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_bytes_buf"); error })
                }
                401u32 => {
                    let mut value = &mut self.packed_int32;
                    ::prost::encoding::int32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_int32"); error })
                }
                402u32 => {
                    let mut value = &mut self.packed_int64;
                    ::prost::encoding::int64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_int64"); error })
                }
                403u32 => {
                    let mut value = &mut self.packed_uint32;
                    ::prost::encoding::uint32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_uint32"); error })
                }
                404u32 => {
                    let mut value = &mut self.packed_uint64;
                    ::prost::encoding::uint64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_uint64"); error })
                }
                405u32 => {
                    let mut value = &mut self.packed_sint32;
                    ::prost::encoding::sint32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_sint32"); error })
                }
                406u32 => {
                    let mut value = &mut self.packed_sint64;
                    ::prost::encoding::sint64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_sint64"); error })
                }
                407u32 => {
                    let mut value = &mut self.packed_fixed32;
                    ::prost::encoding::fixed32::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_fixed32"); error })
                }
                408u32 => {
                    let mut value = &mut self.packed_fixed64;
                    ::prost::encoding::fixed64::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_fixed64"); error })
                }
                409u32 => {
                    let mut value = &mut self.packed_sfixed32;
                    ::prost::encoding::sfixed32::merge_repeated(wire_type,
                            value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_sfixed32"); error })
                }
                410u32 => {
                    let mut value = &mut self.packed_sfixed64;
                    ::prost::encoding::sfixed64::merge_repeated(wire_type,
                            value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_sfixed64"); error })
                }
                411u32 => {
                    let mut value = &mut self.packed_float;
                    ::prost::encoding::float::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_float"); error })
                }
                412u32 => {
                    let mut value = &mut self.packed_double;
                    ::prost::encoding::double::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_double"); error })
                }
                413u32 => {
                    let mut value = &mut self.packed_bool;
                    ::prost::encoding::bool::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_bool"); error })
                }
                415u32 => {
                    let mut value = &mut self.packed_string;
                    ::prost::encoding::string::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_string"); error })
                }
                416u32 => {
                    let mut value = &mut self.packed_bytes_vec;
                    ::prost::encoding::bytes::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_bytes_vec"); error })
                }
                417u32 => {
                    let mut value = &mut self.packed_bytes_buf;
                    ::prost::encoding::bytes::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "packed_bytes_buf"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                                                                                                                                                                                                                                                                                                                                            if self.int32 != 0i32 {
                                                                                                                                                                                                                                                                                                                                                    ::prost::encoding::int32::encoded_len(1u32, &self.int32)
                                                                                                                                                                                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                                                                                                                                                                                        if self.int64 != 0i64 {
                                                                                                                                                                                                                                                                                                                                                ::prost::encoding::int64::encoded_len(2u32, &self.int64)
                                                                                                                                                                                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                                                                                                                                                                                    if self.uint32 != 0u32 {
                                                                                                                                                                                                                                                                                                                                            ::prost::encoding::uint32::encoded_len(3u32, &self.uint32)
                                                                                                                                                                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                                                                                                                                                                if self.uint64 != 0u64 {
                                                                                                                                                                                                                                                                                                                                        ::prost::encoding::uint64::encoded_len(4u32, &self.uint64)
                                                                                                                                                                                                                                                                                                                                    } else { 0 } +
                                                                                                                                                                                                                                                                                                                            if self.sint32 != 0i32 {
                                                                                                                                                                                                                                                                                                                                    ::prost::encoding::sint32::encoded_len(5u32, &self.sint32)
                                                                                                                                                                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                                                                                                                                                                        if self.sint64 != 0i64 {
                                                                                                                                                                                                                                                                                                                                ::prost::encoding::sint64::encoded_len(6u32, &self.sint64)
                                                                                                                                                                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                                                                                                                                                                    if self.fixed32 != 0u32 {
                                                                                                                                                                                                                                                                                                                            ::prost::encoding::fixed32::encoded_len(7u32, &self.fixed32)
                                                                                                                                                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                                                                                                                                                if self.fixed64 != 0u64 {
                                                                                                                                                                                                                                                                                                                        ::prost::encoding::fixed64::encoded_len(8u32, &self.fixed64)
                                                                                                                                                                                                                                                                                                                    } else { 0 } +
                                                                                                                                                                                                                                                                                                            if self.sfixed32 != 0i32 {
                                                                                                                                                                                                                                                                                                                    ::prost::encoding::sfixed32::encoded_len(9u32,
                                                                                                                                                                                                                                                                                                                        &self.sfixed32)
                                                                                                                                                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                                                                                                                                                        if self.sfixed64 != 0i64 {
                                                                                                                                                                                                                                                                                                                ::prost::encoding::sfixed64::encoded_len(10u32,
                                                                                                                                                                                                                                                                                                                    &self.sfixed64)
                                                                                                                                                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                                                                                                                                                    if self.float != 0f32 {
                                                                                                                                                                                                                                                                                                            ::prost::encoding::float::encoded_len(11u32, &self.float)
                                                                                                                                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                                                                                                                                if self.double != 0f64 {
                                                                                                                                                                                                                                                                                                        ::prost::encoding::double::encoded_len(12u32, &self.double)
                                                                                                                                                                                                                                                                                                    } else { 0 } +
                                                                                                                                                                                                                                                                                            if self._bool != false {
                                                                                                                                                                                                                                                                                                    ::prost::encoding::bool::encoded_len(13u32, &self._bool)
                                                                                                                                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                                                                                                                                        if self.string != "" {
                                                                                                                                                                                                                                                                                                ::prost::encoding::string::encoded_len(14u32, &self.string)
                                                                                                                                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                                                                                                                                    if self.bytes_vec != b"" as &[u8] {
                                                                                                                                                                                                                                                                                            ::prost::encoding::bytes::encoded_len(15u32,
                                                                                                                                                                                                                                                                                                &self.bytes_vec)
                                                                                                                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                                                                                                                if self.bytes_buf != b"" as &[u8] {
                                                                                                                                                                                                                                                                                        ::prost::encoding::bytes::encoded_len(16u32,
                                                                                                                                                                                                                                                                                            &self.bytes_buf)
                                                                                                                                                                                                                                                                                    } else { 0 } +
                                                                                                                                                                                                                                                                            ::prost::encoding::int32::encoded_len(101u32,
                                                                                                                                                                                                                                                                                &self.required_int32) +
                                                                                                                                                                                                                                                                        ::prost::encoding::int64::encoded_len(102u32,
                                                                                                                                                                                                                                                                            &self.required_int64) +
                                                                                                                                                                                                                                                                    ::prost::encoding::uint32::encoded_len(103u32,
                                                                                                                                                                                                                                                                        &self.required_uint32) +
                                                                                                                                                                                                                                                                ::prost::encoding::uint64::encoded_len(104u32,
                                                                                                                                                                                                                                                                    &self.required_uint64) +
                                                                                                                                                                                                                                                            ::prost::encoding::sint32::encoded_len(105u32,
                                                                                                                                                                                                                                                                &self.required_sint32) +
                                                                                                                                                                                                                                                        ::prost::encoding::sint64::encoded_len(106u32,
                                                                                                                                                                                                                                                            &self.required_sint64) +
                                                                                                                                                                                                                                                    ::prost::encoding::fixed32::encoded_len(107u32,
                                                                                                                                                                                                                                                        &self.required_fixed32) +
                                                                                                                                                                                                                                                ::prost::encoding::fixed64::encoded_len(108u32,
                                                                                                                                                                                                                                                    &self.required_fixed64) +
                                                                                                                                                                                                                                            ::prost::encoding::sfixed32::encoded_len(109u32,
                                                                                                                                                                                                                                                &self.required_sfixed32) +
                                                                                                                                                                                                                                        ::prost::encoding::sfixed64::encoded_len(110u32,
                                                                                                                                                                                                                                            &self.required_sfixed64) +
                                                                                                                                                                                                                                    ::prost::encoding::float::encoded_len(111u32,
                                                                                                                                                                                                                                        &self.required_float) +
                                                                                                                                                                                                                                ::prost::encoding::double::encoded_len(112u32,
                                                                                                                                                                                                                                    &self.required_double) +
                                                                                                                                                                                                                            ::prost::encoding::bool::encoded_len(113u32,
                                                                                                                                                                                                                                &self.required_bool) +
                                                                                                                                                                                                                        ::prost::encoding::string::encoded_len(114u32,
                                                                                                                                                                                                                            &self.required_string) +
                                                                                                                                                                                                                    ::prost::encoding::bytes::encoded_len(115u32,
                                                                                                                                                                                                                        &self.required_bytes_vec) +
                                                                                                                                                                                                                ::prost::encoding::bytes::encoded_len(116u32,
                                                                                                                                                                                                                    &self.required_bytes_buf) +
                                                                                                                                                                                                            self.optional_int32.as_ref().map_or(0,
                                                                                                                                                                                                                |value|
                                                                                                                                                                                                                    ::prost::encoding::int32::encoded_len(201u32, value)) +
                                                                                                                                                                                                        self.optional_int64.as_ref().map_or(0,
                                                                                                                                                                                                            |value|
                                                                                                                                                                                                                ::prost::encoding::int64::encoded_len(202u32, value)) +
                                                                                                                                                                                                    self.optional_uint32.as_ref().map_or(0,
                                                                                                                                                                                                        |value|
                                                                                                                                                                                                            ::prost::encoding::uint32::encoded_len(203u32, value)) +
                                                                                                                                                                                                self.optional_uint64.as_ref().map_or(0,
                                                                                                                                                                                                    |value|
                                                                                                                                                                                                        ::prost::encoding::uint64::encoded_len(204u32, value)) +
                                                                                                                                                                                            self.optional_sint32.as_ref().map_or(0,
                                                                                                                                                                                                |value|
                                                                                                                                                                                                    ::prost::encoding::sint32::encoded_len(205u32, value)) +
                                                                                                                                                                                        self.optional_sint64.as_ref().map_or(0,
                                                                                                                                                                                            |value|
                                                                                                                                                                                                ::prost::encoding::sint64::encoded_len(206u32, value)) +
                                                                                                                                                                                    self.optional_fixed32.as_ref().map_or(0,
                                                                                                                                                                                        |value|
                                                                                                                                                                                            ::prost::encoding::fixed32::encoded_len(207u32, value)) +
                                                                                                                                                                                self.optional_fixed64.as_ref().map_or(0,
                                                                                                                                                                                    |value|
                                                                                                                                                                                        ::prost::encoding::fixed64::encoded_len(208u32, value)) +
                                                                                                                                                                            self.optional_sfixed32.as_ref().map_or(0,
                                                                                                                                                                                |value|
                                                                                                                                                                                    ::prost::encoding::sfixed32::encoded_len(209u32, value)) +
                                                                                                                                                                        self.optional_sfixed64.as_ref().map_or(0,
                                                                                                                                                                            |value|
                                                                                                                                                                                ::prost::encoding::sfixed64::encoded_len(210u32, value)) +
                                                                                                                                                                    self.optional_float.as_ref().map_or(0,
                                                                                                                                                                        |value|
                                                                                                                                                                            ::prost::encoding::float::encoded_len(211u32, value)) +
                                                                                                                                                                self.optional_double.as_ref().map_or(0,
                                                                                                                                                                    |value|
                                                                                                                                                                        ::prost::encoding::double::encoded_len(212u32, value)) +
                                                                                                                                                            self.optional_bool.as_ref().map_or(0,
                                                                                                                                                                |value| ::prost::encoding::bool::encoded_len(213u32, value))
                                                                                                                                                        +
                                                                                                                                                        self.optional_string.as_ref().map_or(0,
                                                                                                                                                            |value|
                                                                                                                                                                ::prost::encoding::string::encoded_len(214u32, value)) +
                                                                                                                                                    self.optional_bytes_vec.as_ref().map_or(0,
                                                                                                                                                        |value|
                                                                                                                                                            ::prost::encoding::bytes::encoded_len(215u32, value)) +
                                                                                                                                                self.optional_bytes_buf.as_ref().map_or(0,
                                                                                                                                                    |value|
                                                                                                                                                        ::prost::encoding::bytes::encoded_len(216u32, value)) +
                                                                                                                                            ::prost::encoding::int32::encoded_len_repeated(301u32,
                                                                                                                                                &self.repeated_int32) +
                                                                                                                                        ::prost::encoding::int64::encoded_len_repeated(302u32,
                                                                                                                                            &self.repeated_int64) +
                                                                                                                                    ::prost::encoding::uint32::encoded_len_repeated(303u32,
                                                                                                                                        &self.repeated_uint32) +
                                                                                                                                ::prost::encoding::uint64::encoded_len_repeated(304u32,
                                                                                                                                    &self.repeated_uint64) +
                                                                                                                            ::prost::encoding::sint32::encoded_len_repeated(305u32,
                                                                                                                                &self.repeated_sint32) +
                                                                                                                        ::prost::encoding::sint64::encoded_len_repeated(306u32,
                                                                                                                            &self.repeated_sint64) +
                                                                                                                    ::prost::encoding::fixed32::encoded_len_repeated(307u32,
                                                                                                                        &self.repeated_fixed32) +
                                                                                                                ::prost::encoding::fixed64::encoded_len_repeated(308u32,
                                                                                                                    &self.repeated_fixed64) +
                                                                                                            ::prost::encoding::sfixed32::encoded_len_repeated(309u32,
                                                                                                                &self.repeated_sfixed32) +
                                                                                                        ::prost::encoding::sfixed64::encoded_len_repeated(310u32,
                                                                                                            &self.repeated_sfixed64) +
                                                                                                    ::prost::encoding::float::encoded_len_repeated(311u32,
                                                                                                        &self.repeated_float) +
                                                                                                ::prost::encoding::double::encoded_len_repeated(312u32,
                                                                                                    &self.repeated_double) +
                                                                                            ::prost::encoding::bool::encoded_len_repeated(313u32,
                                                                                                &self.repeated_bool) +
                                                                                        ::prost::encoding::string::encoded_len_repeated(315u32,
                                                                                            &self.repeated_string) +
                                                                                    ::prost::encoding::bytes::encoded_len_repeated(316u32,
                                                                                        &self.repeated_bytes_vec) +
                                                                                ::prost::encoding::bytes::encoded_len_repeated(317u32,
                                                                                    &self.repeated_bytes_buf) +
                                                                            ::prost::encoding::int32::encoded_len_packed(401u32,
                                                                                &self.packed_int32) +
                                                                        ::prost::encoding::int64::encoded_len_packed(402u32,
                                                                            &self.packed_int64) +
                                                                    ::prost::encoding::uint32::encoded_len_packed(403u32,
                                                                        &self.packed_uint32) +
                                                                ::prost::encoding::uint64::encoded_len_packed(404u32,
                                                                    &self.packed_uint64) +
                                                            ::prost::encoding::sint32::encoded_len_packed(405u32,
                                                                &self.packed_sint32) +
                                                        ::prost::encoding::sint64::encoded_len_packed(406u32,
                                                            &self.packed_sint64) +
                                                    ::prost::encoding::fixed32::encoded_len_packed(407u32,
                                                        &self.packed_fixed32) +
                                                ::prost::encoding::fixed64::encoded_len_packed(408u32,
                                                    &self.packed_fixed64) +
                                            ::prost::encoding::sfixed32::encoded_len_packed(409u32,
                                                &self.packed_sfixed32) +
                                        ::prost::encoding::sfixed64::encoded_len_packed(410u32,
                                            &self.packed_sfixed64) +
                                    ::prost::encoding::float::encoded_len_packed(411u32,
                                        &self.packed_float) +
                                ::prost::encoding::double::encoded_len_packed(412u32,
                                    &self.packed_double) +
                            ::prost::encoding::bool::encoded_len_packed(413u32,
                                &self.packed_bool) +
                        ::prost::encoding::string::encoded_len_repeated(415u32,
                            &self.packed_string) +
                    ::prost::encoding::bytes::encoded_len_repeated(416u32,
                        &self.packed_bytes_vec) +
                ::prost::encoding::bytes::encoded_len_repeated(417u32,
                    &self.packed_bytes_buf)
        }
        fn clear(&mut self) {
            self.int32 = 0i32;
            self.int64 = 0i64;
            self.uint32 = 0u32;
            self.uint64 = 0u64;
            self.sint32 = 0i32;
            self.sint64 = 0i64;
            self.fixed32 = 0u32;
            self.fixed64 = 0u64;
            self.sfixed32 = 0i32;
            self.sfixed64 = 0i64;
            self.float = 0f32;
            self.double = 0f64;
            self._bool = false;
            self.string.clear();
            self.bytes_vec.clear();
            self.bytes_buf.clear();
            self.required_int32 = 0i32;
            self.required_int64 = 0i64;
            self.required_uint32 = 0u32;
            self.required_uint64 = 0u64;
            self.required_sint32 = 0i32;
            self.required_sint64 = 0i64;
            self.required_fixed32 = 0u32;
            self.required_fixed64 = 0u64;
            self.required_sfixed32 = 0i32;
            self.required_sfixed64 = 0i64;
            self.required_float = 0f32;
            self.required_double = 0f64;
            self.required_bool = false;
            self.required_string.clear();
            self.required_bytes_vec.clear();
            self.required_bytes_buf.clear();
            self.optional_int32 = ::core::option::Option::None;
            self.optional_int64 = ::core::option::Option::None;
            self.optional_uint32 = ::core::option::Option::None;
            self.optional_uint64 = ::core::option::Option::None;
            self.optional_sint32 = ::core::option::Option::None;
            self.optional_sint64 = ::core::option::Option::None;
            self.optional_fixed32 = ::core::option::Option::None;
            self.optional_fixed64 = ::core::option::Option::None;
            self.optional_sfixed32 = ::core::option::Option::None;
            self.optional_sfixed64 = ::core::option::Option::None;
            self.optional_float = ::core::option::Option::None;
            self.optional_double = ::core::option::Option::None;
            self.optional_bool = ::core::option::Option::None;
            self.optional_string = ::core::option::Option::None;
            self.optional_bytes_vec = ::core::option::Option::None;
            self.optional_bytes_buf = ::core::option::Option::None;
            self.repeated_int32.clear();
            self.repeated_int64.clear();
            self.repeated_uint32.clear();
            self.repeated_uint64.clear();
            self.repeated_sint32.clear();
            self.repeated_sint64.clear();
            self.repeated_fixed32.clear();
            self.repeated_fixed64.clear();
            self.repeated_sfixed32.clear();
            self.repeated_sfixed64.clear();
            self.repeated_float.clear();
            self.repeated_double.clear();
            self.repeated_bool.clear();
            self.repeated_string.clear();
            self.repeated_bytes_vec.clear();
            self.repeated_bytes_buf.clear();
            self.packed_int32.clear();
            self.packed_int64.clear();
            self.packed_uint32.clear();
            self.packed_uint64.clear();
            self.packed_sint32.clear();
            self.packed_sint64.clear();
            self.packed_fixed32.clear();
            self.packed_fixed64.clear();
            self.packed_sfixed32.clear();
            self.packed_sfixed64.clear();
            self.packed_float.clear();
            self.packed_double.clear();
            self.packed_bool.clear();
            self.packed_string.clear();
            self.packed_bytes_vec.clear();
            self.packed_bytes_buf.clear();
        }
    }
    impl ::core::default::Default for ScalarTypes {
        fn default() -> Self {
            ScalarTypes {
                int32: 0i32,
                int64: 0i64,
                uint32: 0u32,
                uint64: 0u64,
                sint32: 0i32,
                sint64: 0i64,
                fixed32: 0u32,
                fixed64: 0u64,
                sfixed32: 0i32,
                sfixed64: 0i64,
                float: 0f32,
                double: 0f64,
                _bool: false,
                string: ::prost::alloc::string::String::new(),
                bytes_vec: ::core::default::Default::default(),
                bytes_buf: ::core::default::Default::default(),
                required_int32: 0i32,
                required_int64: 0i64,
                required_uint32: 0u32,
                required_uint64: 0u64,
                required_sint32: 0i32,
                required_sint64: 0i64,
                required_fixed32: 0u32,
                required_fixed64: 0u64,
                required_sfixed32: 0i32,
                required_sfixed64: 0i64,
                required_float: 0f32,
                required_double: 0f64,
                required_bool: false,
                required_string: ::prost::alloc::string::String::new(),
                required_bytes_vec: ::core::default::Default::default(),
                required_bytes_buf: ::core::default::Default::default(),
                optional_int32: ::core::option::Option::None,
                optional_int64: ::core::option::Option::None,
                optional_uint32: ::core::option::Option::None,
                optional_uint64: ::core::option::Option::None,
                optional_sint32: ::core::option::Option::None,
                optional_sint64: ::core::option::Option::None,
                optional_fixed32: ::core::option::Option::None,
                optional_fixed64: ::core::option::Option::None,
                optional_sfixed32: ::core::option::Option::None,
                optional_sfixed64: ::core::option::Option::None,
                optional_float: ::core::option::Option::None,
                optional_double: ::core::option::Option::None,
                optional_bool: ::core::option::Option::None,
                optional_string: ::core::option::Option::None,
                optional_bytes_vec: ::core::option::Option::None,
                optional_bytes_buf: ::core::option::Option::None,
                repeated_int32: ::prost::alloc::vec::Vec::new(),
                repeated_int64: ::prost::alloc::vec::Vec::new(),
                repeated_uint32: ::prost::alloc::vec::Vec::new(),
                repeated_uint64: ::prost::alloc::vec::Vec::new(),
                repeated_sint32: ::prost::alloc::vec::Vec::new(),
                repeated_sint64: ::prost::alloc::vec::Vec::new(),
                repeated_fixed32: ::prost::alloc::vec::Vec::new(),
                repeated_fixed64: ::prost::alloc::vec::Vec::new(),
                repeated_sfixed32: ::prost::alloc::vec::Vec::new(),
                repeated_sfixed64: ::prost::alloc::vec::Vec::new(),
                repeated_float: ::prost::alloc::vec::Vec::new(),
                repeated_double: ::prost::alloc::vec::Vec::new(),
                repeated_bool: ::prost::alloc::vec::Vec::new(),
                repeated_string: ::prost::alloc::vec::Vec::new(),
                repeated_bytes_vec: ::prost::alloc::vec::Vec::new(),
                repeated_bytes_buf: ::prost::alloc::vec::Vec::new(),
                packed_int32: ::prost::alloc::vec::Vec::new(),
                packed_int64: ::prost::alloc::vec::Vec::new(),
                packed_uint32: ::prost::alloc::vec::Vec::new(),
                packed_uint64: ::prost::alloc::vec::Vec::new(),
                packed_sint32: ::prost::alloc::vec::Vec::new(),
                packed_sint64: ::prost::alloc::vec::Vec::new(),
                packed_fixed32: ::prost::alloc::vec::Vec::new(),
                packed_fixed64: ::prost::alloc::vec::Vec::new(),
                packed_sfixed32: ::prost::alloc::vec::Vec::new(),
                packed_sfixed64: ::prost::alloc::vec::Vec::new(),
                packed_float: ::prost::alloc::vec::Vec::new(),
                packed_double: ::prost::alloc::vec::Vec::new(),
                packed_bool: ::prost::alloc::vec::Vec::new(),
                packed_string: ::prost::alloc::vec::Vec::new(),
                packed_bytes_vec: ::prost::alloc::vec::Vec::new(),
                packed_bytes_buf: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for ScalarTypes {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScalarTypes");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.int32)
                        };
                    builder.field("int32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.int64)
                        };
                    builder.field("int64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.uint32)
                        };
                    builder.field("uint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.uint64)
                        };
                    builder.field("uint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.sint32)
                        };
                    builder.field("sint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.sint64)
                        };
                    builder.field("sint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.fixed32)
                        };
                    builder.field("fixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.fixed64)
                        };
                    builder.field("fixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.sfixed32)
                        };
                    builder.field("sfixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.sfixed64)
                        };
                    builder.field("sfixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.float)
                        };
                    builder.field("float", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.double)
                        };
                    builder.field("double", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self._bool)
                        };
                    builder.field("_bool", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.string)
                        };
                    builder.field("string", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.bytes_vec)
                        };
                    builder.field("bytes_vec", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.bytes_buf)
                        };
                    builder.field("bytes_buf", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_int32)
                        };
                    builder.field("required_int32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_int64)
                        };
                    builder.field("required_int64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_uint32)
                        };
                    builder.field("required_uint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_uint64)
                        };
                    builder.field("required_uint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_sint32)
                        };
                    builder.field("required_sint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_sint64)
                        };
                    builder.field("required_sint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_fixed32)
                        };
                    builder.field("required_fixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_fixed64)
                        };
                    builder.field("required_fixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_sfixed32)
                        };
                    builder.field("required_sfixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_sfixed64)
                        };
                    builder.field("required_sfixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_float)
                        };
                    builder.field("required_float", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_double)
                        };
                    builder.field("required_double", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_bool)
                        };
                    builder.field("required_bool", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_string)
                        };
                    builder.field("required_string", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_bytes_vec)
                        };
                    builder.field("required_bytes_vec", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.required_bytes_buf)
                        };
                    builder.field("required_bytes_buf", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_int32)
                        };
                    builder.field("optional_int32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_int64)
                        };
                    builder.field("optional_int64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_uint32)
                        };
                    builder.field("optional_uint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_uint64)
                        };
                    builder.field("optional_uint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_sint32)
                        };
                    builder.field("optional_sint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_sint64)
                        };
                    builder.field("optional_sint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_fixed32)
                        };
                    builder.field("optional_fixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_fixed64)
                        };
                    builder.field("optional_fixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_sfixed32)
                        };
                    builder.field("optional_sfixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_sfixed64)
                        };
                    builder.field("optional_sfixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<f32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_float)
                        };
                    builder.field("optional_float", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<f64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_double)
                        };
                    builder.field("optional_double", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_bool)
                        };
                    builder.field("optional_bool", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<::prost::alloc::string::String>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_string)
                        };
                    builder.field("optional_string", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_bytes_vec)
                        };
                    builder.field("optional_bytes_vec", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<::prost::bytes::Bytes>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.optional_bytes_buf)
                        };
                    builder.field("optional_bytes_buf", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_int32)
                        };
                    builder.field("repeated_int32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_int64)
                        };
                    builder.field("repeated_int64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_uint32)
                        };
                    builder.field("repeated_uint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_uint64)
                        };
                    builder.field("repeated_uint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_sint32)
                        };
                    builder.field("repeated_sint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_sint64)
                        };
                    builder.field("repeated_sint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_fixed32)
                        };
                    builder.field("repeated_fixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_fixed64)
                        };
                    builder.field("repeated_fixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_sfixed32)
                        };
                    builder.field("repeated_sfixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_sfixed64)
                        };
                    builder.field("repeated_sfixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_float)
                        };
                    builder.field("repeated_float", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_double)
                        };
                    builder.field("repeated_double", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_bool)
                        };
                    builder.field("repeated_bool", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_string)
                        };
                    builder.field("repeated_string", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_bytes_vec)
                        };
                    builder.field("repeated_bytes_vec", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<::prost::bytes::Bytes>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.repeated_bytes_buf)
                        };
                    builder.field("repeated_bytes_buf", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_int32)
                        };
                    builder.field("packed_int32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_int64)
                        };
                    builder.field("packed_int64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_uint32)
                        };
                    builder.field("packed_uint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_uint64)
                        };
                    builder.field("packed_uint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_sint32)
                        };
                    builder.field("packed_sint32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_sint64)
                        };
                    builder.field("packed_sint64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_fixed32)
                        };
                    builder.field("packed_fixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_fixed64)
                        };
                    builder.field("packed_fixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_sfixed32)
                        };
                    builder.field("packed_sfixed32", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_sfixed64)
                        };
                    builder.field("packed_sfixed64", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_float)
                        };
                    builder.field("packed_float", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_double)
                        };
                    builder.field("packed_double", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_bool)
                        };
                    builder.field("packed_bool", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_string)
                        };
                    builder.field("packed_string", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_bytes_vec)
                        };
                    builder.field("packed_bytes_vec", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<::prost::bytes::Bytes>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.packed_bytes_buf)
                        };
                    builder.field("packed_bytes_buf", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl ScalarTypes {
        #[doc =
        "Returns the value of `optional_int32`, or the default value if `optional_int32` is unset."]
        pub fn optional_int32(&self) -> i32 {
            match self.optional_int32 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i32,
            }
        }
        #[doc =
        "Returns the value of `optional_int64`, or the default value if `optional_int64` is unset."]
        pub fn optional_int64(&self) -> i64 {
            match self.optional_int64 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i64,
            }
        }
        #[doc =
        "Returns the value of `optional_uint32`, or the default value if `optional_uint32` is unset."]
        pub fn optional_uint32(&self) -> u32 {
            match self.optional_uint32 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0u32,
            }
        }
        #[doc =
        "Returns the value of `optional_uint64`, or the default value if `optional_uint64` is unset."]
        pub fn optional_uint64(&self) -> u64 {
            match self.optional_uint64 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0u64,
            }
        }
        #[doc =
        "Returns the value of `optional_sint32`, or the default value if `optional_sint32` is unset."]
        pub fn optional_sint32(&self) -> i32 {
            match self.optional_sint32 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i32,
            }
        }
        #[doc =
        "Returns the value of `optional_sint64`, or the default value if `optional_sint64` is unset."]
        pub fn optional_sint64(&self) -> i64 {
            match self.optional_sint64 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i64,
            }
        }
        #[doc =
        "Returns the value of `optional_fixed32`, or the default value if `optional_fixed32` is unset."]
        pub fn optional_fixed32(&self) -> u32 {
            match self.optional_fixed32 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0u32,
            }
        }
        #[doc =
        "Returns the value of `optional_fixed64`, or the default value if `optional_fixed64` is unset."]
        pub fn optional_fixed64(&self) -> u64 {
            match self.optional_fixed64 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0u64,
            }
        }
        #[doc =
        "Returns the value of `optional_sfixed32`, or the default value if `optional_sfixed32` is unset."]
        pub fn optional_sfixed32(&self) -> i32 {
            match self.optional_sfixed32 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i32,
            }
        }
        #[doc =
        "Returns the value of `optional_sfixed64`, or the default value if `optional_sfixed64` is unset."]
        pub fn optional_sfixed64(&self) -> i64 {
            match self.optional_sfixed64 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i64,
            }
        }
        #[doc =
        "Returns the value of `optional_float`, or the default value if `optional_float` is unset."]
        pub fn optional_float(&self) -> f32 {
            match self.optional_float {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0f32,
            }
        }
        #[doc =
        "Returns the value of `optional_double`, or the default value if `optional_double` is unset."]
        pub fn optional_double(&self) -> f64 {
            match self.optional_double {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0f64,
            }
        }
        #[doc =
        "Returns the value of `optional_bool`, or the default value if `optional_bool` is unset."]
        pub fn optional_bool(&self) -> bool {
            match self.optional_bool {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => false,
            }
        }
        #[doc =
        "Returns the value of `optional_string`, or the default value if `optional_string` is unset."]
        pub fn optional_string(&self) -> &str {
            match self.optional_string {
                ::core::option::Option::Some(ref val) => &val[..],
                ::core::option::Option::None => "",
            }
        }
        #[doc =
        "Returns the value of `optional_bytes_vec`, or the default value if `optional_bytes_vec` is unset."]
        pub fn optional_bytes_vec(&self) -> &[u8] {
            match self.optional_bytes_vec {
                ::core::option::Option::Some(ref val) => &val[..],
                ::core::option::Option::None => b"" as &[u8],
            }
        }
        #[doc =
        "Returns the value of `optional_bytes_buf`, or the default value if `optional_bytes_buf` is unset."]
        pub fn optional_bytes_buf(&self) -> &[u8] {
            match self.optional_bytes_buf {
                ::core::option::Option::Some(ref val) => &val[..],
                ::core::option::Option::None => b"" as &[u8],
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "message_encoding::check_tags_inferred"]
    #[doc(hidden)]
    pub const check_tags_inferred: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("message_encoding::check_tags_inferred"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/message_encoding.rs",
                start_line: 209usize,
                start_col: 4usize,
                end_line: 209usize,
                end_col: 23usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(check_tags_inferred())),
        };
    fn check_tags_inferred() {
        check_message(&TagsInferred::default());
        check_serialize_equivalent(&TagsInferred::default(),
            &TagsQualified::default());
        let tags_inferred =
            TagsInferred {
                one: true,
                two: Some(42),
                three: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0,
                                1.0, 1.0])),
                skip_to_nine: "nine".to_owned(),
                ten: BasicEnumeration::ZERO.into(),
                eleven: ::alloc::collections::BTreeMap::new(),
                back_to_five: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1,
                                0, 1])),
                six: Basic::default(),
            };
        check_message(&tags_inferred);
        let tags_qualified =
            TagsQualified {
                one: true,
                two: Some(42),
                three: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0,
                                1.0, 1.0])),
                five: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1,
                                0, 1])),
                six: Basic::default(),
                nine: "nine".to_owned(),
                ten: BasicEnumeration::ZERO.into(),
                eleven: ::alloc::collections::BTreeMap::new(),
            };
        check_serialize_equivalent(&tags_inferred, &tags_qualified);
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "message_encoding::check_default_values"]
    #[doc(hidden)]
    pub const check_default_values: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("message_encoding::check_default_values"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/message_encoding.rs",
                start_line: 239usize,
                start_col: 4usize,
                end_line: 239usize,
                end_col: 24usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(check_default_values())),
        };
    fn check_default_values() {
        let default = DefaultValues::default();
        match (&default.int32, &42) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&default.optional_int32, &None) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&&default.string, &"forty two") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&&default.bytes_vec.as_ref(), &b"foo\0bar") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&&default.bytes_buf.as_ref(), &b"foo\0bar") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&default.enumeration, &BasicEnumeration::ONE.into()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&default.optional_enumeration, &None) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&&default.repeated_enumeration, &&[]) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&0, &default.encoded_len()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    /// A protobuf enum.
    #[allow(clippy::upper_case_acronyms)]
    pub enum BasicEnumeration { ZERO = 0, ONE = 1, TWO = 2, THREE = 3, }
    #[automatically_derived]
    #[allow(clippy::upper_case_acronyms)]
    impl ::core::clone::Clone for BasicEnumeration {
        #[inline]
        fn clone(&self) -> BasicEnumeration { *self }
    }
    #[automatically_derived]
    #[allow(clippy::upper_case_acronyms)]
    impl ::core::marker::Copy for BasicEnumeration { }
    #[automatically_derived]
    #[allow(clippy::upper_case_acronyms)]
    impl ::core::fmt::Debug for BasicEnumeration {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self {
                    BasicEnumeration::ZERO => "ZERO",
                    BasicEnumeration::ONE => "ONE",
                    BasicEnumeration::TWO => "TWO",
                    BasicEnumeration::THREE => "THREE",
                })
        }
    }
    #[automatically_derived]
    #[allow(clippy::upper_case_acronyms)]
    impl ::core::marker::StructuralPartialEq for BasicEnumeration { }
    #[automatically_derived]
    #[allow(clippy::upper_case_acronyms)]
    impl ::core::cmp::PartialEq for BasicEnumeration {
        #[inline]
        fn eq(&self, other: &BasicEnumeration) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    impl BasicEnumeration {
        #[doc =
        "Returns `true` if `value` is a variant of `BasicEnumeration`."]
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                3 => true,
                _ => false,
            }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `BasicEnumeration`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32)
            -> ::core::option::Option<BasicEnumeration> {
            match value {
                0 => ::core::option::Option::Some(BasicEnumeration::ZERO),
                1 => ::core::option::Option::Some(BasicEnumeration::ONE),
                2 => ::core::option::Option::Some(BasicEnumeration::TWO),
                3 => ::core::option::Option::Some(BasicEnumeration::THREE),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for BasicEnumeration {
        fn default() -> BasicEnumeration { BasicEnumeration::ZERO }
    }
    impl ::core::convert::From<BasicEnumeration> for i32 {
        fn from(value: BasicEnumeration) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for BasicEnumeration {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            ->
                ::core::result::Result<BasicEnumeration,
                ::prost::UnknownEnumValue> {
            match value {
                0 => ::core::result::Result::Ok(BasicEnumeration::ZERO),
                1 => ::core::result::Result::Ok(BasicEnumeration::ONE),
                2 => ::core::result::Result::Ok(BasicEnumeration::TWO),
                3 => ::core::result::Result::Ok(BasicEnumeration::THREE),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    pub enum BasicOneof {

        #[prost(int32, tag = "8")]
        Int(i32),

        #[prost(string, tag = "9")]
        String(String),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BasicOneof {
        #[inline]
        fn clone(&self) -> BasicOneof {
            match self {
                BasicOneof::Int(__self_0) =>
                    BasicOneof::Int(::core::clone::Clone::clone(__self_0)),
                BasicOneof::String(__self_0) =>
                    BasicOneof::String(::core::clone::Clone::clone(__self_0)),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BasicOneof { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BasicOneof {
        #[inline]
        fn eq(&self, other: &BasicOneof) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr &&
                match (self, other) {
                    (BasicOneof::Int(__self_0), BasicOneof::Int(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (BasicOneof::String(__self_0), BasicOneof::String(__arg1_0))
                        => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl BasicOneof {
        #[doc = r" Encodes the message to a buffer."]
        pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
            match *self {
                BasicOneof::Int(ref value) => {
                    ::prost::encoding::int32::encode(8u32, &*value, buf);
                }
                BasicOneof::String(ref value) => {
                    ::prost::encoding::string::encode(9u32, &*value, buf);
                }
            }
        }
        #[doc =
        r" Decodes an instance of the message from a buffer, and merges it into self."]
        pub fn merge(field: &mut ::core::option::Option<BasicOneof>, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                8u32 => {
                    match field {
                        ::core::option::Option::Some(BasicOneof::Int(ref mut value))
                            => {
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int32::merge(wire_type, value, buf,
                                    ctx).map(|_|
                                    *field =
                                        ::core::option::Option::Some(BasicOneof::Int(owned_value)))
                        }
                    }
                }
                9u32 => {
                    match field {
                        ::core::option::Option::Some(BasicOneof::String(ref mut value))
                            => {
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::string::merge(wire_type, value, buf,
                                    ctx).map(|_|
                                    *field =
                                        ::core::option::Option::Some(BasicOneof::String(owned_value)))
                        }
                    }
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("invalid BasicOneof tag: {0}", tag)));
                }
            }
        }
        #[doc =
        r" Returns the encoded length of the message without a length delimiter."]
        #[inline]
        pub fn encoded_len(&self) -> usize {
            match *self {
                BasicOneof::Int(ref value) =>
                    ::prost::encoding::int32::encoded_len(8u32, &*value),
                BasicOneof::String(ref value) =>
                    ::prost::encoding::string::encoded_len(9u32, &*value),
            }
        }
    }
    impl ::core::fmt::Debug for BasicOneof {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicOneof::Int(ref value) => {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&*value)
                        };
                    f.debug_tuple("Int").field(&wrapper).finish()
                }
                BasicOneof::String(ref value) => {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&*value)
                        };
                    f.debug_tuple("String").field(&wrapper).finish()
                }
            }
        }
    }
    mod int_enum {
        use super::*;
        pub struct Basic {
            #[prost(int32, tag = "1")]
            pub int32: i32,
            #[prost(bool, repeated, packed = "false", tag = "2")]
            pub bools: Vec<bool>,
            #[prost(string, tag = "3")]
            pub string: String,
            #[prost(string, optional, tag = "4")]
            pub optional_string: Option<String>,
            #[prost(enumeration = "BasicEnumeration", tag = "5")]
            pub enumeration: i32,
            #[prost(map = "int32, enumeration(BasicEnumeration)", tag = "6")]
            #[cfg(feature = "std")]
            pub enumeration_map: ::std::collections::HashMap<i32, i32>,
            #[prost(hash_map = "string, string", tag = "7")]
            #[cfg(feature = "std")]
            pub string_map: ::std::collections::HashMap<String, String>,
            #[prost(btree_map = "int32, enumeration(BasicEnumeration)", tag =
            "10")]
            pub enumeration_btree_map: prost::alloc::collections::BTreeMap<i32,
            i32>,
            #[prost(btree_map = "string, string", tag = "11")]
            pub string_btree_map: prost::alloc::collections::BTreeMap<String,
            String>,
            #[prost(oneof = "BasicOneof", tags = "8, 9")]
            pub oneof: Option<BasicOneof>,
            #[prost(map = "string, bytes", tag = "12")]
            #[cfg(feature = "std")]
            pub bytes_map: ::std::collections::HashMap<String, Vec<u8>>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Basic {
            #[inline]
            fn clone(&self) -> Basic {
                Basic {
                    int32: ::core::clone::Clone::clone(&self.int32),
                    bools: ::core::clone::Clone::clone(&self.bools),
                    string: ::core::clone::Clone::clone(&self.string),
                    optional_string: ::core::clone::Clone::clone(&self.optional_string),
                    enumeration: ::core::clone::Clone::clone(&self.enumeration),
                    enumeration_map: ::core::clone::Clone::clone(&self.enumeration_map),
                    string_map: ::core::clone::Clone::clone(&self.string_map),
                    enumeration_btree_map: ::core::clone::Clone::clone(&self.enumeration_btree_map),
                    string_btree_map: ::core::clone::Clone::clone(&self.string_btree_map),
                    oneof: ::core::clone::Clone::clone(&self.oneof),
                    bytes_map: ::core::clone::Clone::clone(&self.bytes_map),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Basic { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Basic {
            #[inline]
            fn eq(&self, other: &Basic) -> bool {
                self.int32 == other.int32 && self.bools == other.bools &&
                                                    self.string == other.string &&
                                                self.optional_string == other.optional_string &&
                                            self.enumeration == other.enumeration &&
                                        self.enumeration_map == other.enumeration_map &&
                                    self.string_map == other.string_map &&
                                self.enumeration_btree_map == other.enumeration_btree_map &&
                            self.string_btree_map == other.string_btree_map &&
                        self.oneof == other.oneof &&
                    self.bytes_map == other.bytes_map
            }
        }
        impl ::prost::Message for Basic {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.int32 != 0i32 {
                        ::prost::encoding::int32::encode(1u32, &self.int32, buf);
                    }
                ::prost::encoding::bool::encode_repeated(2u32, &self.bools,
                    buf);
                if self.string != "" {
                        ::prost::encoding::string::encode(3u32, &self.string, buf);
                    }
                if let ::core::option::Option::Some(ref value) =
                            self.optional_string {
                        ::prost::encoding::string::encode(4u32, value, buf);
                    }
                if self.enumeration != BasicEnumeration::default() as i32 {
                        ::prost::encoding::int32::encode(5u32, &self.enumeration,
                            buf);
                    }
                ::prost::encoding::hash_map::encode_with_default(::prost::encoding::int32::encode,
                    ::prost::encoding::int32::encoded_len,
                    ::prost::encoding::int32::encode,
                    ::prost::encoding::int32::encoded_len,
                    &(BasicEnumeration::default() as i32), 6u32,
                    &self.enumeration_map, buf);
                ::prost::encoding::hash_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 7u32,
                    &self.string_map, buf);
                if let Some(ref oneof) = self.oneof { oneof.encode(buf) }
                ::prost::encoding::btree_map::encode_with_default(::prost::encoding::int32::encode,
                    ::prost::encoding::int32::encoded_len,
                    ::prost::encoding::int32::encode,
                    ::prost::encoding::int32::encoded_len,
                    &(BasicEnumeration::default() as i32), 10u32,
                    &self.enumeration_btree_map, buf);
                ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 11u32,
                    &self.string_btree_map, buf);
                ::prost::encoding::hash_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::bytes::encode,
                    ::prost::encoding::bytes::encoded_len, 12u32,
                    &self.bytes_map, buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "Basic";
                match tag {
                    1u32 => {
                        let mut value = &mut self.int32;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "int32"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.bools;
                        ::prost::encoding::bool::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bools"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.string;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string"); error })
                    }
                    4u32 => {
                        let mut value = &mut self.optional_string;
                        ::prost::encoding::string::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_string"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.enumeration;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.enumeration_map;
                        ::prost::encoding::hash_map::merge_with_default(::prost::encoding::int32::merge,
                                ::prost::encoding::int32::merge,
                                BasicEnumeration::default() as i32, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration_map"); error })
                    }
                    7u32 => {
                        let mut value = &mut self.string_map;
                        ::prost::encoding::hash_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string_map"); error })
                    }
                    8u32 | 9u32 => {
                        let mut value = &mut self.oneof;
                        BasicOneof::merge(value, tag, wire_type, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "oneof"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.enumeration_btree_map;
                        ::prost::encoding::btree_map::merge_with_default(::prost::encoding::int32::merge,
                                ::prost::encoding::int32::merge,
                                BasicEnumeration::default() as i32, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration_btree_map"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.string_btree_map;
                        ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string_btree_map"); error })
                    }
                    12u32 => {
                        let mut value = &mut self.bytes_map;
                        ::prost::encoding::hash_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::bytes::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bytes_map"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                            if self.int32 != 0i32 {
                                                                    ::prost::encoding::int32::encoded_len(1u32, &self.int32)
                                                                } else { 0 } +
                                                        ::prost::encoding::bool::encoded_len_repeated(2u32,
                                                            &self.bools) +
                                                    if self.string != "" {
                                                            ::prost::encoding::string::encoded_len(3u32, &self.string)
                                                        } else { 0 } +
                                                self.optional_string.as_ref().map_or(0,
                                                    |value| ::prost::encoding::string::encoded_len(4u32, value))
                                            +
                                            if self.enumeration != BasicEnumeration::default() as i32 {
                                                    ::prost::encoding::int32::encoded_len(5u32,
                                                        &self.enumeration)
                                                } else { 0 } +
                                        ::prost::encoding::hash_map::encoded_len_with_default(::prost::encoding::int32::encoded_len,
                                            ::prost::encoding::int32::encoded_len,
                                            &(BasicEnumeration::default() as i32), 6u32,
                                            &self.enumeration_map) +
                                    ::prost::encoding::hash_map::encoded_len(::prost::encoding::string::encoded_len,
                                        ::prost::encoding::string::encoded_len, 7u32,
                                        &self.string_map) +
                                self.oneof.as_ref().map_or(0, BasicOneof::encoded_len) +
                            ::prost::encoding::btree_map::encoded_len_with_default(::prost::encoding::int32::encoded_len,
                                ::prost::encoding::int32::encoded_len,
                                &(BasicEnumeration::default() as i32), 10u32,
                                &self.enumeration_btree_map) +
                        ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                            ::prost::encoding::string::encoded_len, 11u32,
                            &self.string_btree_map) +
                    ::prost::encoding::hash_map::encoded_len(::prost::encoding::string::encoded_len,
                        ::prost::encoding::bytes::encoded_len, 12u32,
                        &self.bytes_map)
            }
            fn clear(&mut self) {
                self.int32 = 0i32;
                self.bools.clear();
                self.string.clear();
                self.optional_string = ::core::option::Option::None;
                self.enumeration = BasicEnumeration::default() as i32;
                self.enumeration_map.clear();
                self.string_map.clear();
                self.oneof = ::core::option::Option::None;
                self.enumeration_btree_map.clear();
                self.string_btree_map.clear();
                self.bytes_map.clear();
            }
        }
        impl ::core::default::Default for Basic {
            fn default() -> Self {
                Basic {
                    int32: 0i32,
                    bools: ::prost::alloc::vec::Vec::new(),
                    string: ::prost::alloc::string::String::new(),
                    optional_string: ::core::option::Option::None,
                    enumeration: BasicEnumeration::default() as i32,
                    enumeration_map: ::core::default::Default::default(),
                    string_map: ::core::default::Default::default(),
                    oneof: ::core::default::Default::default(),
                    enumeration_btree_map: ::core::default::Default::default(),
                    string_btree_map: ::core::default::Default::default(),
                    bytes_map: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for Basic {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Basic");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.int32)
                            };
                        builder.field("int32", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<bool>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            #[allow(non_snake_case)]
                                            fn Inner<T>(v: T) -> T { v }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.bools)
                            };
                        builder.field("bools", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.string)
                            };
                        builder.field("string", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.optional_string)
                            };
                        builder.field("optional_string", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.enumeration)
                            };
                        builder.field("enumeration", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::std::collections::HashMap<i32,
                                    i32>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        struct ValueWrapper<'a>(&'a i32);
                                        impl<'a> ::core::fmt::Debug for ValueWrapper<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                let res: ::core::result::Result<BasicEnumeration, _> =
                                                    ::core::convert::TryFrom::try_from(*self.0);
                                                match res {
                                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                                }
                                            }
                                        }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.enumeration_map)
                            };
                        builder.field("enumeration_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::std::collections::HashMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.string_map)
                            };
                        builder.field("string_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<i32,
                                    i32>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        struct ValueWrapper<'a>(&'a i32);
                                        impl<'a> ::core::fmt::Debug for ValueWrapper<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                let res: ::core::result::Result<BasicEnumeration, _> =
                                                    ::core::convert::TryFrom::try_from(*self.0);
                                                match res {
                                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                                }
                                            }
                                        }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.enumeration_btree_map)
                            };
                        builder.field("enumeration_btree_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.string_btree_map)
                            };
                        builder.field("string_btree_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper = &self.oneof;
                        builder.field("oneof", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a dyn ::core::fmt::Debug);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        self.0.fmt(f)
                                    }
                                }
                                MapWrapper(&self.bytes_map)
                            };
                        builder.field("bytes_map", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl Basic {
            #[doc =
            "Returns the value of `optional_string`, or the default value if `optional_string` is unset."]
            pub fn optional_string(&self) -> &str {
                match self.optional_string {
                    ::core::option::Option::Some(ref val) => &val[..],
                    ::core::option::Option::None => "",
                }
            }
            #[doc =
            "Returns the enum value of `enumeration`, or the default if the field is set to an invalid enum value."]
            pub fn enumeration(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.enumeration).unwrap_or(BasicEnumeration::default())
            }
            #[doc = "Sets `enumeration` to the provided enum value."]
            pub fn set_enumeration(&mut self, value: BasicEnumeration) {
                self.enumeration = value as i32;
            }
            #[doc =
            "Returns the enum value for the corresponding key in `enumeration_map`, or `None` if the entry does not exist or it is not a valid enum value."]
            pub fn get_enumeration_map(&self, key: i32)
                -> ::core::option::Option<BasicEnumeration> {
                self.enumeration_map.get(&key).cloned().and_then(|x|
                        {
                            let result: ::core::result::Result<BasicEnumeration, _> =
                                ::core::convert::TryFrom::try_from(x);
                            result.ok()
                        })
            }
            #[doc = "Inserts a key value pair into `enumeration_map`."]
            pub fn insert_enumeration_map(&mut self, key: i32,
                value: BasicEnumeration)
                -> ::core::option::Option<BasicEnumeration> {
                self.enumeration_map.insert(key,
                        value as
                            i32).and_then(|x|
                        {
                            let result: ::core::result::Result<BasicEnumeration, _> =
                                ::core::convert::TryFrom::try_from(x);
                            result.ok()
                        })
            }
            #[doc =
            "Returns the enum value for the corresponding key in `enumeration_btree_map`, or `None` if the entry does not exist or it is not a valid enum value."]
            pub fn get_enumeration_btree_map(&self, key: i32)
                -> ::core::option::Option<BasicEnumeration> {
                self.enumeration_btree_map.get(&key).cloned().and_then(|x|
                        {
                            let result: ::core::result::Result<BasicEnumeration, _> =
                                ::core::convert::TryFrom::try_from(x);
                            result.ok()
                        })
            }
            #[doc = "Inserts a key value pair into `enumeration_btree_map`."]
            pub fn insert_enumeration_btree_map(&mut self, key: i32,
                value: BasicEnumeration)
                -> ::core::option::Option<BasicEnumeration> {
                self.enumeration_btree_map.insert(key,
                        value as
                            i32).and_then(|x|
                        {
                            let result: ::core::result::Result<BasicEnumeration, _> =
                                ::core::convert::TryFrom::try_from(x);
                            result.ok()
                        })
            }
        }
        pub struct Compound {
            #[prost(message, optional, tag = "1")]
            pub optional_message: Option<Basic>,
            #[prost(message, required, tag = "2")]
            pub required_message: Basic,
            #[prost(message, repeated, tag = "3")]
            pub repeated_message: Vec<Basic>,
            #[prost(map = "sint32, message", tag = "4")]
            #[cfg(feature = "std")]
            pub message_map: ::std::collections::HashMap<i32, Basic>,
            #[prost(btree_map = "sint32, message", tag = "5")]
            pub message_btree_map: prost::alloc::collections::BTreeMap<i32,
            Basic>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Compound {
            #[inline]
            fn clone(&self) -> Compound {
                Compound {
                    optional_message: ::core::clone::Clone::clone(&self.optional_message),
                    required_message: ::core::clone::Clone::clone(&self.required_message),
                    repeated_message: ::core::clone::Clone::clone(&self.repeated_message),
                    message_map: ::core::clone::Clone::clone(&self.message_map),
                    message_btree_map: ::core::clone::Clone::clone(&self.message_btree_map),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Compound { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Compound {
            #[inline]
            fn eq(&self, other: &Compound) -> bool {
                self.optional_message == other.optional_message &&
                                self.required_message == other.required_message &&
                            self.repeated_message == other.repeated_message &&
                        self.message_map == other.message_map &&
                    self.message_btree_map == other.message_btree_map
            }
        }
        impl ::prost::Message for Compound {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref msg) = self.optional_message {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                ::prost::encoding::message::encode(2u32,
                    &self.required_message, buf);
                for msg in &self.repeated_message {
                    ::prost::encoding::message::encode(3u32, msg, buf);
                }
                ::prost::encoding::hash_map::encode(::prost::encoding::sint32::encode,
                    ::prost::encoding::sint32::encoded_len,
                    ::prost::encoding::message::encode,
                    ::prost::encoding::message::encoded_len, 4u32,
                    &self.message_map, buf);
                ::prost::encoding::btree_map::encode(::prost::encoding::sint32::encode,
                    ::prost::encoding::sint32::encoded_len,
                    ::prost::encoding::message::encode,
                    ::prost::encoding::message::encoded_len, 5u32,
                    &self.message_btree_map, buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "Compound";
                match tag {
                    1u32 => {
                        let mut value = &mut self.optional_message;
                        ::prost::encoding::message::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_message"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.required_message;
                        ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "required_message"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.repeated_message;
                        ::prost::encoding::message::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "repeated_message"); error })
                    }
                    4u32 => {
                        let mut value = &mut self.message_map;
                        ::prost::encoding::hash_map::merge(::prost::encoding::sint32::merge,
                                ::prost::encoding::message::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "message_map"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.message_btree_map;
                        ::prost::encoding::btree_map::merge(::prost::encoding::sint32::merge,
                                ::prost::encoding::message::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "message_btree_map"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                    self.optional_message.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                ::prost::encoding::message::encoded_len(2u32,
                                    &self.required_message) +
                            ::prost::encoding::message::encoded_len_repeated(3u32,
                                &self.repeated_message) +
                        ::prost::encoding::hash_map::encoded_len(::prost::encoding::sint32::encoded_len,
                            ::prost::encoding::message::encoded_len, 4u32,
                            &self.message_map) +
                    ::prost::encoding::btree_map::encoded_len(::prost::encoding::sint32::encoded_len,
                        ::prost::encoding::message::encoded_len, 5u32,
                        &self.message_btree_map)
            }
            fn clear(&mut self) {
                self.optional_message = ::core::option::Option::None;
                self.required_message.clear();
                self.repeated_message.clear();
                self.message_map.clear();
                self.message_btree_map.clear();
            }
        }
        impl ::core::default::Default for Compound {
            fn default() -> Self {
                Compound {
                    optional_message: ::core::default::Default::default(),
                    required_message: ::core::default::Default::default(),
                    repeated_message: ::core::default::Default::default(),
                    message_map: ::core::default::Default::default(),
                    message_btree_map: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for Compound {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Compound");
                let builder =
                    {
                        let wrapper = &self.optional_message;
                        builder.field("optional_message", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper = &self.required_message;
                        builder.field("required_message", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper = &self.repeated_message;
                        builder.field("repeated_message", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a,
                                    V: 'a>(&'a ::std::collections::HashMap<i32, V>);
                                impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                    V: ::core::fmt::Debug + 'a {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.message_map)
                            };
                        builder.field("message_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a,
                                    V: 'a>(&'a ::prost::alloc::collections::BTreeMap<i32, V>);
                                impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                    V: ::core::fmt::Debug + 'a {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.message_btree_map)
                            };
                        builder.field("message_btree_map", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        pub struct TagsInferred {
            #[prost(bool)]
            pub one: bool,
            #[prost(int32, optional)]
            pub two: Option<i32>,
            #[prost(float, repeated)]
            pub three: Vec<f32>,
            #[prost(tag = "9", string, required)]
            pub skip_to_nine: String,
            #[prost(enumeration = "BasicEnumeration", default = "ONE")]
            pub ten: i32,
            #[prost(btree_map = "string, string")]
            pub eleven: ::alloc::collections::BTreeMap<String, String>,
            #[prost(tag = "5", bytes)]
            pub back_to_five: Vec<u8>,
            #[prost(message, required)]
            pub six: Basic,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TagsInferred {
            #[inline]
            fn clone(&self) -> TagsInferred {
                TagsInferred {
                    one: ::core::clone::Clone::clone(&self.one),
                    two: ::core::clone::Clone::clone(&self.two),
                    three: ::core::clone::Clone::clone(&self.three),
                    skip_to_nine: ::core::clone::Clone::clone(&self.skip_to_nine),
                    ten: ::core::clone::Clone::clone(&self.ten),
                    eleven: ::core::clone::Clone::clone(&self.eleven),
                    back_to_five: ::core::clone::Clone::clone(&self.back_to_five),
                    six: ::core::clone::Clone::clone(&self.six),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TagsInferred { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TagsInferred {
            #[inline]
            fn eq(&self, other: &TagsInferred) -> bool {
                self.one == other.one && self.two == other.two &&
                                        self.three == other.three &&
                                    self.skip_to_nine == other.skip_to_nine &&
                                self.ten == other.ten && self.eleven == other.eleven &&
                        self.back_to_five == other.back_to_five &&
                    self.six == other.six
            }
        }
        impl ::prost::Message for TagsInferred {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.one != false {
                        ::prost::encoding::bool::encode(1u32, &self.one, buf);
                    }
                if let ::core::option::Option::Some(ref value) = self.two {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                ::prost::encoding::float::encode_packed(3u32, &self.three,
                    buf);
                if self.back_to_five != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(5u32, &self.back_to_five,
                            buf);
                    }
                ::prost::encoding::message::encode(6u32, &self.six, buf);
                ::prost::encoding::string::encode(9u32, &self.skip_to_nine,
                    buf);
                if self.ten != BasicEnumeration::ONE as i32 {
                        ::prost::encoding::int32::encode(10u32, &self.ten, buf);
                    }
                ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 11u32, &self.eleven,
                    buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "TagsInferred";
                match tag {
                    1u32 => {
                        let mut value = &mut self.one;
                        ::prost::encoding::bool::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "one"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.two;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "two"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.three;
                        ::prost::encoding::float::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "three"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.back_to_five;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "back_to_five"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.six;
                        ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "six"); error })
                    }
                    9u32 => {
                        let mut value = &mut self.skip_to_nine;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "skip_to_nine"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.ten;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "ten"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.eleven;
                        ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "eleven"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                if self.one != false {
                                                        ::prost::encoding::bool::encoded_len(1u32, &self.one)
                                                    } else { 0 } +
                                            self.two.as_ref().map_or(0,
                                                |value| ::prost::encoding::int32::encoded_len(2u32, value))
                                        +
                                        ::prost::encoding::float::encoded_len_packed(3u32,
                                            &self.three) +
                                    if self.back_to_five != b"" as &[u8] {
                                            ::prost::encoding::bytes::encoded_len(5u32,
                                                &self.back_to_five)
                                        } else { 0 } +
                                ::prost::encoding::message::encoded_len(6u32, &self.six) +
                            ::prost::encoding::string::encoded_len(9u32,
                                &self.skip_to_nine) +
                        if self.ten != BasicEnumeration::ONE as i32 {
                                ::prost::encoding::int32::encoded_len(10u32, &self.ten)
                            } else { 0 } +
                    ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                        ::prost::encoding::string::encoded_len, 11u32, &self.eleven)
            }
            fn clear(&mut self) {
                self.one = false;
                self.two = ::core::option::Option::None;
                self.three.clear();
                self.back_to_five.clear();
                self.six.clear();
                self.skip_to_nine.clear();
                self.ten = BasicEnumeration::ONE as i32;
                self.eleven.clear();
            }
        }
        impl ::core::default::Default for TagsInferred {
            fn default() -> Self {
                TagsInferred {
                    one: false,
                    two: ::core::option::Option::None,
                    three: ::prost::alloc::vec::Vec::new(),
                    back_to_five: ::core::default::Default::default(),
                    six: ::core::default::Default::default(),
                    skip_to_nine: ::prost::alloc::string::String::new(),
                    ten: BasicEnumeration::ONE as i32,
                    eleven: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for TagsInferred {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("TagsInferred");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.one)
                            };
                        builder.field("one", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.two)
                            };
                        builder.field("two", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            #[allow(non_snake_case)]
                                            fn Inner<T>(v: T) -> T { v }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.three)
                            };
                        builder.field("three", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.skip_to_nine)
                            };
                        builder.field("skip_to_nine", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.ten)
                            };
                        builder.field("ten", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.eleven)
                            };
                        builder.field("eleven", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.back_to_five)
                            };
                        builder.field("back_to_five", &wrapper)
                    };
                ;
                let builder =
                    { let wrapper = &self.six; builder.field("six", &wrapper) };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl TagsInferred {
            #[doc =
            "Returns the value of `two`, or the default value if `two` is unset."]
            pub fn two(&self) -> i32 {
                match self.two {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
            #[doc =
            "Returns the enum value of `ten`, or the default if the field is set to an invalid enum value."]
            pub fn ten(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.ten).unwrap_or(BasicEnumeration::ONE)
            }
            #[doc = "Sets `ten` to the provided enum value."]
            pub fn set_ten(&mut self, value: BasicEnumeration) {
                self.ten = value as i32;
            }
        }
        pub struct TagsQualified {
            #[prost(tag = "1", bool)]
            pub one: bool,
            #[prost(tag = "2", int32, optional)]
            pub two: Option<i32>,
            #[prost(tag = "3", float, repeated)]
            pub three: Vec<f32>,
            #[prost(tag = "5", bytes)]
            pub five: Vec<u8>,
            #[prost(tag = "6", message, required)]
            pub six: Basic,
            #[prost(tag = "9", string, required)]
            pub nine: String,
            #[prost(tag = "10", enumeration = "BasicEnumeration", default =
            "ONE")]
            pub ten: i32,
            #[prost(tag = "11", btree_map = "string, string")]
            pub eleven: ::alloc::collections::BTreeMap<String, String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TagsQualified {
            #[inline]
            fn clone(&self) -> TagsQualified {
                TagsQualified {
                    one: ::core::clone::Clone::clone(&self.one),
                    two: ::core::clone::Clone::clone(&self.two),
                    three: ::core::clone::Clone::clone(&self.three),
                    five: ::core::clone::Clone::clone(&self.five),
                    six: ::core::clone::Clone::clone(&self.six),
                    nine: ::core::clone::Clone::clone(&self.nine),
                    ten: ::core::clone::Clone::clone(&self.ten),
                    eleven: ::core::clone::Clone::clone(&self.eleven),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TagsQualified { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TagsQualified {
            #[inline]
            fn eq(&self, other: &TagsQualified) -> bool {
                self.one == other.one && self.two == other.two &&
                                        self.three == other.three && self.five == other.five &&
                                self.six == other.six && self.nine == other.nine &&
                        self.ten == other.ten && self.eleven == other.eleven
            }
        }
        impl ::prost::Message for TagsQualified {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.one != false {
                        ::prost::encoding::bool::encode(1u32, &self.one, buf);
                    }
                if let ::core::option::Option::Some(ref value) = self.two {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                ::prost::encoding::float::encode_packed(3u32, &self.three,
                    buf);
                if self.five != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(5u32, &self.five, buf);
                    }
                ::prost::encoding::message::encode(6u32, &self.six, buf);
                ::prost::encoding::string::encode(9u32, &self.nine, buf);
                if self.ten != BasicEnumeration::ONE as i32 {
                        ::prost::encoding::int32::encode(10u32, &self.ten, buf);
                    }
                ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 11u32, &self.eleven,
                    buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "TagsQualified";
                match tag {
                    1u32 => {
                        let mut value = &mut self.one;
                        ::prost::encoding::bool::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "one"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.two;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "two"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.three;
                        ::prost::encoding::float::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "three"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.five;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "five"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.six;
                        ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "six"); error })
                    }
                    9u32 => {
                        let mut value = &mut self.nine;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "nine"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.ten;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "ten"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.eleven;
                        ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "eleven"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                if self.one != false {
                                                        ::prost::encoding::bool::encoded_len(1u32, &self.one)
                                                    } else { 0 } +
                                            self.two.as_ref().map_or(0,
                                                |value| ::prost::encoding::int32::encoded_len(2u32, value))
                                        +
                                        ::prost::encoding::float::encoded_len_packed(3u32,
                                            &self.three) +
                                    if self.five != b"" as &[u8] {
                                            ::prost::encoding::bytes::encoded_len(5u32, &self.five)
                                        } else { 0 } +
                                ::prost::encoding::message::encoded_len(6u32, &self.six) +
                            ::prost::encoding::string::encoded_len(9u32, &self.nine) +
                        if self.ten != BasicEnumeration::ONE as i32 {
                                ::prost::encoding::int32::encoded_len(10u32, &self.ten)
                            } else { 0 } +
                    ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                        ::prost::encoding::string::encoded_len, 11u32, &self.eleven)
            }
            fn clear(&mut self) {
                self.one = false;
                self.two = ::core::option::Option::None;
                self.three.clear();
                self.five.clear();
                self.six.clear();
                self.nine.clear();
                self.ten = BasicEnumeration::ONE as i32;
                self.eleven.clear();
            }
        }
        impl ::core::default::Default for TagsQualified {
            fn default() -> Self {
                TagsQualified {
                    one: false,
                    two: ::core::option::Option::None,
                    three: ::prost::alloc::vec::Vec::new(),
                    five: ::core::default::Default::default(),
                    six: ::core::default::Default::default(),
                    nine: ::prost::alloc::string::String::new(),
                    ten: BasicEnumeration::ONE as i32,
                    eleven: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for TagsQualified {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("TagsQualified");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.one)
                            };
                        builder.field("one", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.two)
                            };
                        builder.field("two", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            #[allow(non_snake_case)]
                                            fn Inner<T>(v: T) -> T { v }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.three)
                            };
                        builder.field("three", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.five)
                            };
                        builder.field("five", &wrapper)
                    };
                ;
                let builder =
                    { let wrapper = &self.six; builder.field("six", &wrapper) };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.nine)
                            };
                        builder.field("nine", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.ten)
                            };
                        builder.field("ten", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.eleven)
                            };
                        builder.field("eleven", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl TagsQualified {
            #[doc =
            "Returns the value of `two`, or the default value if `two` is unset."]
            pub fn two(&self) -> i32 {
                match self.two {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
            #[doc =
            "Returns the enum value of `ten`, or the default if the field is set to an invalid enum value."]
            pub fn ten(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.ten).unwrap_or(BasicEnumeration::ONE)
            }
            #[doc = "Sets `ten` to the provided enum value."]
            pub fn set_ten(&mut self, value: BasicEnumeration) {
                self.ten = value as i32;
            }
        }
        /// A prost message with default value.
        pub struct DefaultValues {
            #[prost(int32, tag = "1", default = "42")]
            pub int32: i32,
            #[prost(int32, optional, tag = "2", default = "88")]
            pub optional_int32: Option<i32>,
            #[prost(string, tag = "3", default = "forty two")]
            pub string: String,
            #[prost(bytes = "vec", tag = "7", default = "b\"foo\\x00bar\"")]
            pub bytes_vec: Vec<u8>,
            #[prost(bytes = "bytes", tag = "8", default = "b\"foo\\x00bar\"")]
            pub bytes_buf: Bytes,
            #[prost(enumeration = "BasicEnumeration", tag = "4", default =
            "ONE")]
            pub enumeration: i32,
            #[prost(enumeration = "BasicEnumeration", optional, tag = "5",
            default = "TWO")]
            pub optional_enumeration: Option<i32>,
            #[prost(enumeration = "BasicEnumeration", repeated, tag = "6")]
            pub repeated_enumeration: Vec<i32>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DefaultValues {
            #[inline]
            fn clone(&self) -> DefaultValues {
                DefaultValues {
                    int32: ::core::clone::Clone::clone(&self.int32),
                    optional_int32: ::core::clone::Clone::clone(&self.optional_int32),
                    string: ::core::clone::Clone::clone(&self.string),
                    bytes_vec: ::core::clone::Clone::clone(&self.bytes_vec),
                    bytes_buf: ::core::clone::Clone::clone(&self.bytes_buf),
                    enumeration: ::core::clone::Clone::clone(&self.enumeration),
                    optional_enumeration: ::core::clone::Clone::clone(&self.optional_enumeration),
                    repeated_enumeration: ::core::clone::Clone::clone(&self.repeated_enumeration),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DefaultValues { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DefaultValues {
            #[inline]
            fn eq(&self, other: &DefaultValues) -> bool {
                self.int32 == other.int32 &&
                                            self.optional_int32 == other.optional_int32 &&
                                        self.string == other.string &&
                                    self.bytes_vec == other.bytes_vec &&
                                self.bytes_buf == other.bytes_buf &&
                            self.enumeration == other.enumeration &&
                        self.optional_enumeration == other.optional_enumeration &&
                    self.repeated_enumeration == other.repeated_enumeration
            }
        }
        impl ::prost::Message for DefaultValues {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.int32 != 42i32 {
                        ::prost::encoding::int32::encode(1u32, &self.int32, buf);
                    }
                if let ::core::option::Option::Some(ref value) =
                            self.optional_int32 {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                if self.string != "forty two" {
                        ::prost::encoding::string::encode(3u32, &self.string, buf);
                    }
                if self.enumeration != BasicEnumeration::ONE as i32 {
                        ::prost::encoding::int32::encode(4u32, &self.enumeration,
                            buf);
                    }
                if let ::core::option::Option::Some(ref value) =
                            self.optional_enumeration {
                        ::prost::encoding::int32::encode(5u32, value, buf);
                    }
                ::prost::encoding::int32::encode_packed(6u32,
                    &self.repeated_enumeration, buf);
                if self.bytes_vec != b"foo\0bar" as &[u8] {
                        ::prost::encoding::bytes::encode(7u32, &self.bytes_vec,
                            buf);
                    }
                if self.bytes_buf != b"foo\0bar" as &[u8] {
                        ::prost::encoding::bytes::encode(8u32, &self.bytes_buf,
                            buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "DefaultValues";
                match tag {
                    1u32 => {
                        let mut value = &mut self.int32;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "int32"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.optional_int32;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_int32"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.string;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string"); error })
                    }
                    4u32 => {
                        let mut value = &mut self.enumeration;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.optional_enumeration;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_enumeration"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.repeated_enumeration;
                        ::prost::encoding::int32::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "repeated_enumeration"); error })
                    }
                    7u32 => {
                        let mut value = &mut self.bytes_vec;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bytes_vec"); error })
                    }
                    8u32 => {
                        let mut value = &mut self.bytes_buf;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bytes_buf"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                if self.int32 != 42i32 {
                                                        ::prost::encoding::int32::encoded_len(1u32, &self.int32)
                                                    } else { 0 } +
                                            self.optional_int32.as_ref().map_or(0,
                                                |value| ::prost::encoding::int32::encoded_len(2u32, value))
                                        +
                                        if self.string != "forty two" {
                                                ::prost::encoding::string::encoded_len(3u32, &self.string)
                                            } else { 0 } +
                                    if self.enumeration != BasicEnumeration::ONE as i32 {
                                            ::prost::encoding::int32::encoded_len(4u32,
                                                &self.enumeration)
                                        } else { 0 } +
                                self.optional_enumeration.as_ref().map_or(0,
                                    |value| ::prost::encoding::int32::encoded_len(5u32, value))
                            +
                            ::prost::encoding::int32::encoded_len_packed(6u32,
                                &self.repeated_enumeration) +
                        if self.bytes_vec != b"foo\0bar" as &[u8] {
                                ::prost::encoding::bytes::encoded_len(7u32, &self.bytes_vec)
                            } else { 0 } +
                    if self.bytes_buf != b"foo\0bar" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(8u32, &self.bytes_buf)
                        } else { 0 }
            }
            fn clear(&mut self) {
                self.int32 = 42i32;
                self.optional_int32 = ::core::option::Option::None;
                self.string.clear();
                self.enumeration = BasicEnumeration::ONE as i32;
                self.optional_enumeration = ::core::option::Option::None;
                self.repeated_enumeration.clear();
                self.bytes_vec.clear();
                self.bytes_buf.clear();
            }
        }
        impl ::core::default::Default for DefaultValues {
            fn default() -> Self {
                DefaultValues {
                    int32: 42i32,
                    optional_int32: ::core::option::Option::None,
                    string: "forty two".into(),
                    enumeration: BasicEnumeration::ONE as i32,
                    optional_enumeration: ::core::option::Option::None,
                    repeated_enumeration: ::prost::alloc::vec::Vec::new(),
                    bytes_vec: b"foo\0bar".as_ref().into(),
                    bytes_buf: b"foo\0bar".as_ref().into(),
                }
            }
        }
        impl ::core::fmt::Debug for DefaultValues {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("DefaultValues");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.int32)
                            };
                        builder.field("int32", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.optional_int32)
                            };
                        builder.field("optional_int32", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.string)
                            };
                        builder.field("string", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.bytes_vec)
                            };
                        builder.field("bytes_vec", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.bytes_buf)
                            };
                        builder.field("bytes_buf", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.enumeration)
                            };
                        builder.field("enumeration", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        struct Inner<'a>(&'a i32);
                                        impl<'a> ::core::fmt::Debug for Inner<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                let res: ::core::result::Result<BasicEnumeration, _> =
                                                    ::core::convert::TryFrom::try_from(*self.0);
                                                match res {
                                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                                }
                                            }
                                        }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.optional_enumeration)
                            };
                        builder.field("optional_enumeration", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            struct Inner<'a>(&'a i32);
                                            impl<'a> ::core::fmt::Debug for Inner<'a> {
                                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                    -> ::core::fmt::Result {
                                                    let res: ::core::result::Result<BasicEnumeration, _> =
                                                        ::core::convert::TryFrom::try_from(*self.0);
                                                    match res {
                                                        Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                        Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                                    }
                                                }
                                            }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.repeated_enumeration)
                            };
                        builder.field("repeated_enumeration", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl DefaultValues {
            #[doc =
            "Returns the value of `optional_int32`, or the default value if `optional_int32` is unset."]
            pub fn optional_int32(&self) -> i32 {
                match self.optional_int32 {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 88i32,
                }
            }
            #[doc =
            "Returns the enum value of `enumeration`, or the default if the field is set to an invalid enum value."]
            pub fn enumeration(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.enumeration).unwrap_or(BasicEnumeration::ONE)
            }
            #[doc = "Sets `enumeration` to the provided enum value."]
            pub fn set_enumeration(&mut self, value: BasicEnumeration) {
                self.enumeration = value as i32;
            }
            #[doc =
            "Returns the enum value of `optional_enumeration`, or the default if the field is unset or set to an invalid enum value."]
            pub fn optional_enumeration(&self) -> BasicEnumeration {
                self.optional_enumeration.and_then(|value|
                            {
                                let result: ::core::result::Result<BasicEnumeration, _> =
                                    ::core::convert::TryFrom::try_from(value);
                                result.ok()
                            }).unwrap_or(BasicEnumeration::TWO)
            }
            #[doc = "Sets `optional_enumeration` to the provided enum value."]
            pub fn set_optional_enumeration(&mut self,
                value: BasicEnumeration) {
                self.optional_enumeration =
                    ::core::option::Option::Some(value as i32);
            }
            #[doc =
            "Returns an iterator which yields the valid enum values contained in `repeated_enumeration`."]
            pub fn repeated_enumeration(&self)
                ->
                    ::core::iter::FilterMap<::core::iter::Cloned<::core::slice::Iter<i32>>,
                    fn(i32) -> ::core::option::Option<BasicEnumeration>> {
                self.repeated_enumeration.iter().cloned().filter_map(|x|
                        {
                            let result: ::core::result::Result<BasicEnumeration, _> =
                                ::core::convert::TryFrom::try_from(x);
                            result.ok()
                        })
            }
            #[doc =
            "Appends the provided enum value to `repeated_enumeration`."]
            pub fn push_repeated_enumeration(&mut self,
                value: BasicEnumeration) {
                self.repeated_enumeration.push(value as i32);
            }
        }
    }
    mod open_enum {
        use super::*;
        pub struct Basic {
            #[prost(int32, tag = "1")]
            pub int32: i32,
            #[prost(bool, repeated, packed = "false", tag = "2")]
            pub bools: Vec<bool>,
            #[prost(string, tag = "3")]
            pub string: String,
            #[prost(string, optional, tag = "4")]
            pub optional_string: Option<String>,
            #[prost(enumeration = "BasicEnumeration", enum_type = "open", tag
            = "5")]
            pub enumeration: OpenEnum<BasicEnumeration>,
            #[prost(map = "int32, enumeration(BasicEnumeration)", enum_type =
            "open", tag = "6")]
            #[cfg(feature = "std")]
            pub enumeration_map: ::std::collections::HashMap<i32,
            OpenEnum<BasicEnumeration>>,
            #[prost(hash_map = "string, string", tag = "7")]
            #[cfg(feature = "std")]
            pub string_map: ::std::collections::HashMap<String, String>,
            #[prost(btree_map = "int32, enumeration(BasicEnumeration)",
            enum_type = "open", tag = "10")]
            pub enumeration_btree_map: prost::alloc::collections::BTreeMap<i32,
            OpenEnum<BasicEnumeration>>,
            #[prost(btree_map = "string, string", tag = "11")]
            pub string_btree_map: prost::alloc::collections::BTreeMap<String,
            String>,
            #[prost(oneof = "BasicOneof", tags = "8, 9")]
            pub oneof: Option<BasicOneof>,
            #[prost(map = "string, bytes", tag = "12")]
            #[cfg(feature = "std")]
            pub bytes_map: ::std::collections::HashMap<String, Vec<u8>>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Basic {
            #[inline]
            fn clone(&self) -> Basic {
                Basic {
                    int32: ::core::clone::Clone::clone(&self.int32),
                    bools: ::core::clone::Clone::clone(&self.bools),
                    string: ::core::clone::Clone::clone(&self.string),
                    optional_string: ::core::clone::Clone::clone(&self.optional_string),
                    enumeration: ::core::clone::Clone::clone(&self.enumeration),
                    enumeration_map: ::core::clone::Clone::clone(&self.enumeration_map),
                    string_map: ::core::clone::Clone::clone(&self.string_map),
                    enumeration_btree_map: ::core::clone::Clone::clone(&self.enumeration_btree_map),
                    string_btree_map: ::core::clone::Clone::clone(&self.string_btree_map),
                    oneof: ::core::clone::Clone::clone(&self.oneof),
                    bytes_map: ::core::clone::Clone::clone(&self.bytes_map),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Basic { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Basic {
            #[inline]
            fn eq(&self, other: &Basic) -> bool {
                self.int32 == other.int32 && self.bools == other.bools &&
                                                    self.string == other.string &&
                                                self.optional_string == other.optional_string &&
                                            self.enumeration == other.enumeration &&
                                        self.enumeration_map == other.enumeration_map &&
                                    self.string_map == other.string_map &&
                                self.enumeration_btree_map == other.enumeration_btree_map &&
                            self.string_btree_map == other.string_btree_map &&
                        self.oneof == other.oneof &&
                    self.bytes_map == other.bytes_map
            }
        }
        impl ::prost::Message for Basic {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.int32 != 0i32 {
                        ::prost::encoding::int32::encode(1u32, &self.int32, buf);
                    }
                ::prost::encoding::bool::encode_repeated(2u32, &self.bools,
                    buf);
                if self.string != "" {
                        ::prost::encoding::string::encode(3u32, &self.string, buf);
                    }
                if let ::core::option::Option::Some(ref value) =
                            self.optional_string {
                        ::prost::encoding::string::encode(4u32, value, buf);
                    }
                if self.enumeration !=
                            ::prost::OpenEnum::Known(BasicEnumeration::default()) {
                        ::prost::encoding::open_enum::encode(5u32,
                            &self.enumeration, buf);
                    }
                ::prost::encoding::hash_map::encode(::prost::encoding::int32::encode,
                    ::prost::encoding::int32::encoded_len,
                    ::prost::encoding::open_enum::encode,
                    ::prost::encoding::open_enum::encoded_len, 6u32,
                    &self.enumeration_map, buf);
                ::prost::encoding::hash_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 7u32,
                    &self.string_map, buf);
                if let Some(ref oneof) = self.oneof { oneof.encode(buf) }
                ::prost::encoding::btree_map::encode(::prost::encoding::int32::encode,
                    ::prost::encoding::int32::encoded_len,
                    ::prost::encoding::open_enum::encode,
                    ::prost::encoding::open_enum::encoded_len, 10u32,
                    &self.enumeration_btree_map, buf);
                ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 11u32,
                    &self.string_btree_map, buf);
                ::prost::encoding::hash_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::bytes::encode,
                    ::prost::encoding::bytes::encoded_len, 12u32,
                    &self.bytes_map, buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "Basic";
                match tag {
                    1u32 => {
                        let mut value = &mut self.int32;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "int32"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.bools;
                        ::prost::encoding::bool::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bools"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.string;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string"); error })
                    }
                    4u32 => {
                        let mut value = &mut self.optional_string;
                        ::prost::encoding::string::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_string"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.enumeration;
                        ::prost::encoding::open_enum::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.enumeration_map;
                        ::prost::encoding::hash_map::merge(::prost::encoding::int32::merge,
                                ::prost::encoding::open_enum::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration_map"); error })
                    }
                    7u32 => {
                        let mut value = &mut self.string_map;
                        ::prost::encoding::hash_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string_map"); error })
                    }
                    8u32 | 9u32 => {
                        let mut value = &mut self.oneof;
                        BasicOneof::merge(value, tag, wire_type, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "oneof"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.enumeration_btree_map;
                        ::prost::encoding::btree_map::merge(::prost::encoding::int32::merge,
                                ::prost::encoding::open_enum::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration_btree_map"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.string_btree_map;
                        ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string_btree_map"); error })
                    }
                    12u32 => {
                        let mut value = &mut self.bytes_map;
                        ::prost::encoding::hash_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::bytes::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bytes_map"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                            if self.int32 != 0i32 {
                                                                    ::prost::encoding::int32::encoded_len(1u32, &self.int32)
                                                                } else { 0 } +
                                                        ::prost::encoding::bool::encoded_len_repeated(2u32,
                                                            &self.bools) +
                                                    if self.string != "" {
                                                            ::prost::encoding::string::encoded_len(3u32, &self.string)
                                                        } else { 0 } +
                                                self.optional_string.as_ref().map_or(0,
                                                    |value| ::prost::encoding::string::encoded_len(4u32, value))
                                            +
                                            if self.enumeration !=
                                                        ::prost::OpenEnum::Known(BasicEnumeration::default()) {
                                                    ::prost::encoding::open_enum::encoded_len(5u32,
                                                        &self.enumeration)
                                                } else { 0 } +
                                        ::prost::encoding::hash_map::encoded_len(::prost::encoding::int32::encoded_len,
                                            ::prost::encoding::open_enum::encoded_len, 6u32,
                                            &self.enumeration_map) +
                                    ::prost::encoding::hash_map::encoded_len(::prost::encoding::string::encoded_len,
                                        ::prost::encoding::string::encoded_len, 7u32,
                                        &self.string_map) +
                                self.oneof.as_ref().map_or(0, BasicOneof::encoded_len) +
                            ::prost::encoding::btree_map::encoded_len(::prost::encoding::int32::encoded_len,
                                ::prost::encoding::open_enum::encoded_len, 10u32,
                                &self.enumeration_btree_map) +
                        ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                            ::prost::encoding::string::encoded_len, 11u32,
                            &self.string_btree_map) +
                    ::prost::encoding::hash_map::encoded_len(::prost::encoding::string::encoded_len,
                        ::prost::encoding::bytes::encoded_len, 12u32,
                        &self.bytes_map)
            }
            fn clear(&mut self) {
                self.int32 = 0i32;
                self.bools.clear();
                self.string.clear();
                self.optional_string = ::core::option::Option::None;
                self.enumeration =
                    ::prost::OpenEnum::Known(BasicEnumeration::default());
                self.enumeration_map.clear();
                self.string_map.clear();
                self.oneof = ::core::option::Option::None;
                self.enumeration_btree_map.clear();
                self.string_btree_map.clear();
                self.bytes_map.clear();
            }
        }
        impl ::core::default::Default for Basic {
            fn default() -> Self {
                Basic {
                    int32: 0i32,
                    bools: ::prost::alloc::vec::Vec::new(),
                    string: ::prost::alloc::string::String::new(),
                    optional_string: ::core::option::Option::None,
                    enumeration: ::prost::OpenEnum::Known(BasicEnumeration::default()),
                    enumeration_map: ::core::default::Default::default(),
                    string_map: ::core::default::Default::default(),
                    oneof: ::core::default::Default::default(),
                    enumeration_btree_map: ::core::default::Default::default(),
                    string_btree_map: ::core::default::Default::default(),
                    bytes_map: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for Basic {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Basic");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.int32)
                            };
                        builder.field("int32", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<bool>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            #[allow(non_snake_case)]
                                            fn Inner<T>(v: T) -> T { v }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.bools)
                            };
                        builder.field("bools", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.string)
                            };
                        builder.field("string", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.optional_string)
                            };
                        builder.field("optional_string", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::OpenEnum<BasicEnumeration>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        match &self.0 {
                                            ::prost::OpenEnum::Known(en) =>
                                                ::core::fmt::Debug::fmt(en, f),
                                            ::prost::OpenEnum::Unknown(n) =>
                                                ::core::fmt::Debug::fmt(n, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.enumeration)
                            };
                        builder.field("enumeration", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::std::collections::HashMap<i32,
                                    ::prost::OpenEnum<BasicEnumeration>>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        struct ValueWrapper<'a>(&'a ::prost::OpenEnum<BasicEnumeration>);
                                        impl<'a> ::core::fmt::Debug for ValueWrapper<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                match &self.0 {
                                                    ::prost::OpenEnum::Known(en) =>
                                                        ::core::fmt::Debug::fmt(en, f),
                                                    ::prost::OpenEnum::Unknown(n) =>
                                                        ::core::fmt::Debug::fmt(n, f),
                                                }
                                            }
                                        }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.enumeration_map)
                            };
                        builder.field("enumeration_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::std::collections::HashMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.string_map)
                            };
                        builder.field("string_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<i32,
                                    ::prost::OpenEnum<BasicEnumeration>>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        struct ValueWrapper<'a>(&'a ::prost::OpenEnum<BasicEnumeration>);
                                        impl<'a> ::core::fmt::Debug for ValueWrapper<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                match &self.0 {
                                                    ::prost::OpenEnum::Known(en) =>
                                                        ::core::fmt::Debug::fmt(en, f),
                                                    ::prost::OpenEnum::Unknown(n) =>
                                                        ::core::fmt::Debug::fmt(n, f),
                                                }
                                            }
                                        }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.enumeration_btree_map)
                            };
                        builder.field("enumeration_btree_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.string_btree_map)
                            };
                        builder.field("string_btree_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper = &self.oneof;
                        builder.field("oneof", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a dyn ::core::fmt::Debug);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        self.0.fmt(f)
                                    }
                                }
                                MapWrapper(&self.bytes_map)
                            };
                        builder.field("bytes_map", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl Basic {
            #[doc =
            "Returns the value of `optional_string`, or the default value if `optional_string` is unset."]
            pub fn optional_string(&self) -> &str {
                match self.optional_string {
                    ::core::option::Option::Some(ref val) => &val[..],
                    ::core::option::Option::None => "",
                }
            }
        }
        pub struct Compound {
            #[prost(message, optional, tag = "1")]
            pub optional_message: Option<Basic>,
            #[prost(message, required, tag = "2")]
            pub required_message: Basic,
            #[prost(message, repeated, tag = "3")]
            pub repeated_message: Vec<Basic>,
            #[prost(map = "sint32, message", tag = "4")]
            #[cfg(feature = "std")]
            pub message_map: ::std::collections::HashMap<i32, Basic>,
            #[prost(btree_map = "sint32, message", tag = "5")]
            pub message_btree_map: prost::alloc::collections::BTreeMap<i32,
            Basic>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Compound {
            #[inline]
            fn clone(&self) -> Compound {
                Compound {
                    optional_message: ::core::clone::Clone::clone(&self.optional_message),
                    required_message: ::core::clone::Clone::clone(&self.required_message),
                    repeated_message: ::core::clone::Clone::clone(&self.repeated_message),
                    message_map: ::core::clone::Clone::clone(&self.message_map),
                    message_btree_map: ::core::clone::Clone::clone(&self.message_btree_map),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Compound { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Compound {
            #[inline]
            fn eq(&self, other: &Compound) -> bool {
                self.optional_message == other.optional_message &&
                                self.required_message == other.required_message &&
                            self.repeated_message == other.repeated_message &&
                        self.message_map == other.message_map &&
                    self.message_btree_map == other.message_btree_map
            }
        }
        impl ::prost::Message for Compound {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref msg) = self.optional_message {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                ::prost::encoding::message::encode(2u32,
                    &self.required_message, buf);
                for msg in &self.repeated_message {
                    ::prost::encoding::message::encode(3u32, msg, buf);
                }
                ::prost::encoding::hash_map::encode(::prost::encoding::sint32::encode,
                    ::prost::encoding::sint32::encoded_len,
                    ::prost::encoding::message::encode,
                    ::prost::encoding::message::encoded_len, 4u32,
                    &self.message_map, buf);
                ::prost::encoding::btree_map::encode(::prost::encoding::sint32::encode,
                    ::prost::encoding::sint32::encoded_len,
                    ::prost::encoding::message::encode,
                    ::prost::encoding::message::encoded_len, 5u32,
                    &self.message_btree_map, buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "Compound";
                match tag {
                    1u32 => {
                        let mut value = &mut self.optional_message;
                        ::prost::encoding::message::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_message"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.required_message;
                        ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "required_message"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.repeated_message;
                        ::prost::encoding::message::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "repeated_message"); error })
                    }
                    4u32 => {
                        let mut value = &mut self.message_map;
                        ::prost::encoding::hash_map::merge(::prost::encoding::sint32::merge,
                                ::prost::encoding::message::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "message_map"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.message_btree_map;
                        ::prost::encoding::btree_map::merge(::prost::encoding::sint32::merge,
                                ::prost::encoding::message::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "message_btree_map"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                    self.optional_message.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                ::prost::encoding::message::encoded_len(2u32,
                                    &self.required_message) +
                            ::prost::encoding::message::encoded_len_repeated(3u32,
                                &self.repeated_message) +
                        ::prost::encoding::hash_map::encoded_len(::prost::encoding::sint32::encoded_len,
                            ::prost::encoding::message::encoded_len, 4u32,
                            &self.message_map) +
                    ::prost::encoding::btree_map::encoded_len(::prost::encoding::sint32::encoded_len,
                        ::prost::encoding::message::encoded_len, 5u32,
                        &self.message_btree_map)
            }
            fn clear(&mut self) {
                self.optional_message = ::core::option::Option::None;
                self.required_message.clear();
                self.repeated_message.clear();
                self.message_map.clear();
                self.message_btree_map.clear();
            }
        }
        impl ::core::default::Default for Compound {
            fn default() -> Self {
                Compound {
                    optional_message: ::core::default::Default::default(),
                    required_message: ::core::default::Default::default(),
                    repeated_message: ::core::default::Default::default(),
                    message_map: ::core::default::Default::default(),
                    message_btree_map: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for Compound {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Compound");
                let builder =
                    {
                        let wrapper = &self.optional_message;
                        builder.field("optional_message", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper = &self.required_message;
                        builder.field("required_message", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper = &self.repeated_message;
                        builder.field("repeated_message", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a,
                                    V: 'a>(&'a ::std::collections::HashMap<i32, V>);
                                impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                    V: ::core::fmt::Debug + 'a {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.message_map)
                            };
                        builder.field("message_map", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a,
                                    V: 'a>(&'a ::prost::alloc::collections::BTreeMap<i32, V>);
                                impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                    V: ::core::fmt::Debug + 'a {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.message_btree_map)
                            };
                        builder.field("message_btree_map", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        pub struct TagsInferred {
            #[prost(bool)]
            pub one: bool,
            #[prost(int32, optional)]
            pub two: Option<i32>,
            #[prost(float, repeated)]
            pub three: Vec<f32>,
            #[prost(tag = "9", string, required)]
            pub skip_to_nine: String,
            #[prost(enumeration = "BasicEnumeration", default = "ONE")]
            pub ten: OpenEnum<BasicEnumeration>,
            #[prost(btree_map = "string, string")]
            pub eleven: ::alloc::collections::BTreeMap<String, String>,
            #[prost(tag = "5", bytes)]
            pub back_to_five: Vec<u8>,
            #[prost(message, required)]
            pub six: Basic,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TagsInferred {
            #[inline]
            fn clone(&self) -> TagsInferred {
                TagsInferred {
                    one: ::core::clone::Clone::clone(&self.one),
                    two: ::core::clone::Clone::clone(&self.two),
                    three: ::core::clone::Clone::clone(&self.three),
                    skip_to_nine: ::core::clone::Clone::clone(&self.skip_to_nine),
                    ten: ::core::clone::Clone::clone(&self.ten),
                    eleven: ::core::clone::Clone::clone(&self.eleven),
                    back_to_five: ::core::clone::Clone::clone(&self.back_to_five),
                    six: ::core::clone::Clone::clone(&self.six),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TagsInferred { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TagsInferred {
            #[inline]
            fn eq(&self, other: &TagsInferred) -> bool {
                self.one == other.one && self.two == other.two &&
                                        self.three == other.three &&
                                    self.skip_to_nine == other.skip_to_nine &&
                                self.ten == other.ten && self.eleven == other.eleven &&
                        self.back_to_five == other.back_to_five &&
                    self.six == other.six
            }
        }
        impl ::prost::Message for TagsInferred {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.one != false {
                        ::prost::encoding::bool::encode(1u32, &self.one, buf);
                    }
                if let ::core::option::Option::Some(ref value) = self.two {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                ::prost::encoding::float::encode_packed(3u32, &self.three,
                    buf);
                if self.back_to_five != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(5u32, &self.back_to_five,
                            buf);
                    }
                ::prost::encoding::message::encode(6u32, &self.six, buf);
                ::prost::encoding::string::encode(9u32, &self.skip_to_nine,
                    buf);
                if self.ten != BasicEnumeration::ONE as i32 {
                        ::prost::encoding::int32::encode(10u32, &self.ten, buf);
                    }
                ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 11u32, &self.eleven,
                    buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "TagsInferred";
                match tag {
                    1u32 => {
                        let mut value = &mut self.one;
                        ::prost::encoding::bool::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "one"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.two;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "two"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.three;
                        ::prost::encoding::float::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "three"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.back_to_five;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "back_to_five"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.six;
                        ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "six"); error })
                    }
                    9u32 => {
                        let mut value = &mut self.skip_to_nine;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "skip_to_nine"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.ten;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "ten"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.eleven;
                        ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "eleven"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                if self.one != false {
                                                        ::prost::encoding::bool::encoded_len(1u32, &self.one)
                                                    } else { 0 } +
                                            self.two.as_ref().map_or(0,
                                                |value| ::prost::encoding::int32::encoded_len(2u32, value))
                                        +
                                        ::prost::encoding::float::encoded_len_packed(3u32,
                                            &self.three) +
                                    if self.back_to_five != b"" as &[u8] {
                                            ::prost::encoding::bytes::encoded_len(5u32,
                                                &self.back_to_five)
                                        } else { 0 } +
                                ::prost::encoding::message::encoded_len(6u32, &self.six) +
                            ::prost::encoding::string::encoded_len(9u32,
                                &self.skip_to_nine) +
                        if self.ten != BasicEnumeration::ONE as i32 {
                                ::prost::encoding::int32::encoded_len(10u32, &self.ten)
                            } else { 0 } +
                    ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                        ::prost::encoding::string::encoded_len, 11u32, &self.eleven)
            }
            fn clear(&mut self) {
                self.one = false;
                self.two = ::core::option::Option::None;
                self.three.clear();
                self.back_to_five.clear();
                self.six.clear();
                self.skip_to_nine.clear();
                self.ten = BasicEnumeration::ONE as i32;
                self.eleven.clear();
            }
        }
        impl ::core::default::Default for TagsInferred {
            fn default() -> Self {
                TagsInferred {
                    one: false,
                    two: ::core::option::Option::None,
                    three: ::prost::alloc::vec::Vec::new(),
                    back_to_five: ::core::default::Default::default(),
                    six: ::core::default::Default::default(),
                    skip_to_nine: ::prost::alloc::string::String::new(),
                    ten: BasicEnumeration::ONE as i32,
                    eleven: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for TagsInferred {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("TagsInferred");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.one)
                            };
                        builder.field("one", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.two)
                            };
                        builder.field("two", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            #[allow(non_snake_case)]
                                            fn Inner<T>(v: T) -> T { v }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.three)
                            };
                        builder.field("three", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.skip_to_nine)
                            };
                        builder.field("skip_to_nine", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.ten)
                            };
                        builder.field("ten", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.eleven)
                            };
                        builder.field("eleven", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.back_to_five)
                            };
                        builder.field("back_to_five", &wrapper)
                    };
                ;
                let builder =
                    { let wrapper = &self.six; builder.field("six", &wrapper) };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl TagsInferred {
            #[doc =
            "Returns the value of `two`, or the default value if `two` is unset."]
            pub fn two(&self) -> i32 {
                match self.two {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
            #[doc =
            "Returns the enum value of `ten`, or the default if the field is set to an invalid enum value."]
            pub fn ten(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.ten).unwrap_or(BasicEnumeration::ONE)
            }
            #[doc = "Sets `ten` to the provided enum value."]
            pub fn set_ten(&mut self, value: BasicEnumeration) {
                self.ten = value as i32;
            }
        }
        pub struct TagsQualified {
            #[prost(tag = "1", bool)]
            pub one: bool,
            #[prost(tag = "2", int32, optional)]
            pub two: Option<i32>,
            #[prost(tag = "3", float, repeated)]
            pub three: Vec<f32>,
            #[prost(tag = "5", bytes)]
            pub five: Vec<u8>,
            #[prost(tag = "6", message, required)]
            pub six: Basic,
            #[prost(tag = "9", string, required)]
            pub nine: String,
            #[prost(tag = "10", enumeration = "BasicEnumeration", default =
            "ONE")]
            pub ten: OpenEnum<BasicEnumeration>,
            #[prost(tag = "11", btree_map = "string, string")]
            pub eleven: ::alloc::collections::BTreeMap<String, String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TagsQualified {
            #[inline]
            fn clone(&self) -> TagsQualified {
                TagsQualified {
                    one: ::core::clone::Clone::clone(&self.one),
                    two: ::core::clone::Clone::clone(&self.two),
                    three: ::core::clone::Clone::clone(&self.three),
                    five: ::core::clone::Clone::clone(&self.five),
                    six: ::core::clone::Clone::clone(&self.six),
                    nine: ::core::clone::Clone::clone(&self.nine),
                    ten: ::core::clone::Clone::clone(&self.ten),
                    eleven: ::core::clone::Clone::clone(&self.eleven),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TagsQualified { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TagsQualified {
            #[inline]
            fn eq(&self, other: &TagsQualified) -> bool {
                self.one == other.one && self.two == other.two &&
                                        self.three == other.three && self.five == other.five &&
                                self.six == other.six && self.nine == other.nine &&
                        self.ten == other.ten && self.eleven == other.eleven
            }
        }
        impl ::prost::Message for TagsQualified {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.one != false {
                        ::prost::encoding::bool::encode(1u32, &self.one, buf);
                    }
                if let ::core::option::Option::Some(ref value) = self.two {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                ::prost::encoding::float::encode_packed(3u32, &self.three,
                    buf);
                if self.five != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(5u32, &self.five, buf);
                    }
                ::prost::encoding::message::encode(6u32, &self.six, buf);
                ::prost::encoding::string::encode(9u32, &self.nine, buf);
                if self.ten != BasicEnumeration::ONE as i32 {
                        ::prost::encoding::int32::encode(10u32, &self.ten, buf);
                    }
                ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 11u32, &self.eleven,
                    buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "TagsQualified";
                match tag {
                    1u32 => {
                        let mut value = &mut self.one;
                        ::prost::encoding::bool::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "one"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.two;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "two"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.three;
                        ::prost::encoding::float::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "three"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.five;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "five"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.six;
                        ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "six"); error })
                    }
                    9u32 => {
                        let mut value = &mut self.nine;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "nine"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.ten;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "ten"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.eleven;
                        ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "eleven"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                if self.one != false {
                                                        ::prost::encoding::bool::encoded_len(1u32, &self.one)
                                                    } else { 0 } +
                                            self.two.as_ref().map_or(0,
                                                |value| ::prost::encoding::int32::encoded_len(2u32, value))
                                        +
                                        ::prost::encoding::float::encoded_len_packed(3u32,
                                            &self.three) +
                                    if self.five != b"" as &[u8] {
                                            ::prost::encoding::bytes::encoded_len(5u32, &self.five)
                                        } else { 0 } +
                                ::prost::encoding::message::encoded_len(6u32, &self.six) +
                            ::prost::encoding::string::encoded_len(9u32, &self.nine) +
                        if self.ten != BasicEnumeration::ONE as i32 {
                                ::prost::encoding::int32::encoded_len(10u32, &self.ten)
                            } else { 0 } +
                    ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                        ::prost::encoding::string::encoded_len, 11u32, &self.eleven)
            }
            fn clear(&mut self) {
                self.one = false;
                self.two = ::core::option::Option::None;
                self.three.clear();
                self.five.clear();
                self.six.clear();
                self.nine.clear();
                self.ten = BasicEnumeration::ONE as i32;
                self.eleven.clear();
            }
        }
        impl ::core::default::Default for TagsQualified {
            fn default() -> Self {
                TagsQualified {
                    one: false,
                    two: ::core::option::Option::None,
                    three: ::prost::alloc::vec::Vec::new(),
                    five: ::core::default::Default::default(),
                    six: ::core::default::Default::default(),
                    nine: ::prost::alloc::string::String::new(),
                    ten: BasicEnumeration::ONE as i32,
                    eleven: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for TagsQualified {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("TagsQualified");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.one)
                            };
                        builder.field("one", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.two)
                            };
                        builder.field("two", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<f32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            #[allow(non_snake_case)]
                                            fn Inner<T>(v: T) -> T { v }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.three)
                            };
                        builder.field("three", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.five)
                            };
                        builder.field("five", &wrapper)
                    };
                ;
                let builder =
                    { let wrapper = &self.six; builder.field("six", &wrapper) };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.nine)
                            };
                        builder.field("nine", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.ten)
                            };
                        builder.field("ten", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.eleven)
                            };
                        builder.field("eleven", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl TagsQualified {
            #[doc =
            "Returns the value of `two`, or the default value if `two` is unset."]
            pub fn two(&self) -> i32 {
                match self.two {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
            #[doc =
            "Returns the enum value of `ten`, or the default if the field is set to an invalid enum value."]
            pub fn ten(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.ten).unwrap_or(BasicEnumeration::ONE)
            }
            #[doc = "Sets `ten` to the provided enum value."]
            pub fn set_ten(&mut self, value: BasicEnumeration) {
                self.ten = value as i32;
            }
        }
        /// A prost message with default value.
        pub struct DefaultValues {
            #[prost(int32, tag = "1", default = "42")]
            pub int32: i32,
            #[prost(int32, optional, tag = "2", default = "88")]
            pub optional_int32: Option<i32>,
            #[prost(string, tag = "3", default = "forty two")]
            pub string: String,
            #[prost(bytes = "vec", tag = "7", default = "b\"foo\\x00bar\"")]
            pub bytes_vec: Vec<u8>,
            #[prost(bytes = "bytes", tag = "8", default = "b\"foo\\x00bar\"")]
            pub bytes_buf: Bytes,
            #[prost(enumeration = "BasicEnumeration", tag = "4", default =
            "ONE")]
            pub enumeration: OpenEnum<BasicEnumeration>,
            #[prost(enumeration = "BasicEnumeration", optional, tag = "5",
            default = "TWO")]
            pub optional_enumeration: Option<OpenEnum<BasicEnumeration>>,
            #[prost(enumeration = "BasicEnumeration", repeated, tag = "6")]
            pub repeated_enumeration: Vec<OpenEnum<BasicEnumeration>>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DefaultValues {
            #[inline]
            fn clone(&self) -> DefaultValues {
                DefaultValues {
                    int32: ::core::clone::Clone::clone(&self.int32),
                    optional_int32: ::core::clone::Clone::clone(&self.optional_int32),
                    string: ::core::clone::Clone::clone(&self.string),
                    bytes_vec: ::core::clone::Clone::clone(&self.bytes_vec),
                    bytes_buf: ::core::clone::Clone::clone(&self.bytes_buf),
                    enumeration: ::core::clone::Clone::clone(&self.enumeration),
                    optional_enumeration: ::core::clone::Clone::clone(&self.optional_enumeration),
                    repeated_enumeration: ::core::clone::Clone::clone(&self.repeated_enumeration),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DefaultValues { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DefaultValues {
            #[inline]
            fn eq(&self, other: &DefaultValues) -> bool {
                self.int32 == other.int32 &&
                                            self.optional_int32 == other.optional_int32 &&
                                        self.string == other.string &&
                                    self.bytes_vec == other.bytes_vec &&
                                self.bytes_buf == other.bytes_buf &&
                            self.enumeration == other.enumeration &&
                        self.optional_enumeration == other.optional_enumeration &&
                    self.repeated_enumeration == other.repeated_enumeration
            }
        }
        impl ::prost::Message for DefaultValues {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.int32 != 42i32 {
                        ::prost::encoding::int32::encode(1u32, &self.int32, buf);
                    }
                if let ::core::option::Option::Some(ref value) =
                            self.optional_int32 {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                if self.string != "forty two" {
                        ::prost::encoding::string::encode(3u32, &self.string, buf);
                    }
                if self.enumeration != BasicEnumeration::ONE as i32 {
                        ::prost::encoding::int32::encode(4u32, &self.enumeration,
                            buf);
                    }
                if let ::core::option::Option::Some(ref value) =
                            self.optional_enumeration {
                        ::prost::encoding::int32::encode(5u32, value, buf);
                    }
                ::prost::encoding::int32::encode_packed(6u32,
                    &self.repeated_enumeration, buf);
                if self.bytes_vec != b"foo\0bar" as &[u8] {
                        ::prost::encoding::bytes::encode(7u32, &self.bytes_vec,
                            buf);
                    }
                if self.bytes_buf != b"foo\0bar" as &[u8] {
                        ::prost::encoding::bytes::encode(8u32, &self.bytes_buf,
                            buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "DefaultValues";
                match tag {
                    1u32 => {
                        let mut value = &mut self.int32;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "int32"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.optional_int32;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_int32"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.string;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "string"); error })
                    }
                    4u32 => {
                        let mut value = &mut self.enumeration;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "enumeration"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.optional_enumeration;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "optional_enumeration"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.repeated_enumeration;
                        ::prost::encoding::int32::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "repeated_enumeration"); error })
                    }
                    7u32 => {
                        let mut value = &mut self.bytes_vec;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bytes_vec"); error })
                    }
                    8u32 => {
                        let mut value = &mut self.bytes_buf;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "bytes_buf"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                if self.int32 != 42i32 {
                                                        ::prost::encoding::int32::encoded_len(1u32, &self.int32)
                                                    } else { 0 } +
                                            self.optional_int32.as_ref().map_or(0,
                                                |value| ::prost::encoding::int32::encoded_len(2u32, value))
                                        +
                                        if self.string != "forty two" {
                                                ::prost::encoding::string::encoded_len(3u32, &self.string)
                                            } else { 0 } +
                                    if self.enumeration != BasicEnumeration::ONE as i32 {
                                            ::prost::encoding::int32::encoded_len(4u32,
                                                &self.enumeration)
                                        } else { 0 } +
                                self.optional_enumeration.as_ref().map_or(0,
                                    |value| ::prost::encoding::int32::encoded_len(5u32, value))
                            +
                            ::prost::encoding::int32::encoded_len_packed(6u32,
                                &self.repeated_enumeration) +
                        if self.bytes_vec != b"foo\0bar" as &[u8] {
                                ::prost::encoding::bytes::encoded_len(7u32, &self.bytes_vec)
                            } else { 0 } +
                    if self.bytes_buf != b"foo\0bar" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(8u32, &self.bytes_buf)
                        } else { 0 }
            }
            fn clear(&mut self) {
                self.int32 = 42i32;
                self.optional_int32 = ::core::option::Option::None;
                self.string.clear();
                self.enumeration = BasicEnumeration::ONE as i32;
                self.optional_enumeration = ::core::option::Option::None;
                self.repeated_enumeration.clear();
                self.bytes_vec.clear();
                self.bytes_buf.clear();
            }
        }
        impl ::core::default::Default for DefaultValues {
            fn default() -> Self {
                DefaultValues {
                    int32: 42i32,
                    optional_int32: ::core::option::Option::None,
                    string: "forty two".into(),
                    enumeration: BasicEnumeration::ONE as i32,
                    optional_enumeration: ::core::option::Option::None,
                    repeated_enumeration: ::prost::alloc::vec::Vec::new(),
                    bytes_vec: b"foo\0bar".as_ref().into(),
                    bytes_buf: b"foo\0bar".as_ref().into(),
                }
            }
        }
        impl ::core::fmt::Debug for DefaultValues {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("DefaultValues");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.int32)
                            };
                        builder.field("int32", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.optional_int32)
                            };
                        builder.field("optional_int32", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.string)
                            };
                        builder.field("string", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.bytes_vec)
                            };
                        builder.field("bytes_vec", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.bytes_buf)
                            };
                        builder.field("bytes_buf", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<BasicEnumeration, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.enumeration)
                            };
                        builder.field("enumeration", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        struct Inner<'a>(&'a i32);
                                        impl<'a> ::core::fmt::Debug for Inner<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                let res: ::core::result::Result<BasicEnumeration, _> =
                                                    ::core::convert::TryFrom::try_from(*self.0);
                                                match res {
                                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                                }
                                            }
                                        }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.optional_enumeration)
                            };
                        builder.field("optional_enumeration", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let mut vec_builder = f.debug_list();
                                        for v in self.0 {
                                            struct Inner<'a>(&'a i32);
                                            impl<'a> ::core::fmt::Debug for Inner<'a> {
                                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                    -> ::core::fmt::Result {
                                                    let res: ::core::result::Result<BasicEnumeration, _> =
                                                        ::core::convert::TryFrom::try_from(*self.0);
                                                    match res {
                                                        Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                        Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                                    }
                                                }
                                            }
                                            vec_builder.entry(&Inner(v));
                                        }
                                        vec_builder.finish()
                                    }
                                }
                                ScalarWrapper(&self.repeated_enumeration)
                            };
                        builder.field("repeated_enumeration", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl DefaultValues {
            #[doc =
            "Returns the value of `optional_int32`, or the default value if `optional_int32` is unset."]
            pub fn optional_int32(&self) -> i32 {
                match self.optional_int32 {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 88i32,
                }
            }
            #[doc =
            "Returns the enum value of `enumeration`, or the default if the field is set to an invalid enum value."]
            pub fn enumeration(&self) -> BasicEnumeration {
                ::core::convert::TryFrom::try_from(self.enumeration).unwrap_or(BasicEnumeration::ONE)
            }
            #[doc = "Sets `enumeration` to the provided enum value."]
            pub fn set_enumeration(&mut self, value: BasicEnumeration) {
                self.enumeration = value as i32;
            }
            #[doc =
            "Returns the enum value of `optional_enumeration`, or the default if the field is unset or set to an invalid enum value."]
            pub fn optional_enumeration(&self) -> BasicEnumeration {
                self.optional_enumeration.and_then(|value|
                            {
                                let result: ::core::result::Result<BasicEnumeration, _> =
                                    ::core::convert::TryFrom::try_from(value);
                                result.ok()
                            }).unwrap_or(BasicEnumeration::TWO)
            }
            #[doc = "Sets `optional_enumeration` to the provided enum value."]
            pub fn set_optional_enumeration(&mut self,
                value: BasicEnumeration) {
                self.optional_enumeration =
                    ::core::option::Option::Some(value as i32);
            }
            #[doc =
            "Returns an iterator which yields the valid enum values contained in `repeated_enumeration`."]
            pub fn repeated_enumeration(&self)
                ->
                    ::core::iter::FilterMap<::core::iter::Cloned<::core::slice::Iter<i32>>,
                    fn(i32) -> ::core::option::Option<BasicEnumeration>> {
                self.repeated_enumeration.iter().cloned().filter_map(|x|
                        {
                            let result: ::core::result::Result<BasicEnumeration, _> =
                                ::core::convert::TryFrom::try_from(x);
                            result.ok()
                        })
            }
            #[doc =
            "Appends the provided enum value to `repeated_enumeration`."]
            pub fn push_repeated_enumeration(&mut self,
                value: BasicEnumeration) {
                self.repeated_enumeration.push(value as i32);
            }
        }
    }
}
#[cfg(test)]
mod no_shadowed_types {
    mod should_compile_successfully {
        pub struct A {
            #[prost(enumeration = "B", tag = "1")]
            pub b: i32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for A {
            #[inline]
            fn clone(&self) -> A {
                let _: ::core::clone::AssertParamIsClone<i32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for A { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for A { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for A {
            #[inline]
            fn eq(&self, other: &A) -> bool { self.b == other.b }
        }
        impl ::prost::Message for A {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.b != B::default() as i32 {
                        ::prost::encoding::int32::encode(1u32, &self.b, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "A";
                match tag {
                    1u32 => {
                        let mut value = &mut self.b;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "b"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    if self.b != B::default() as i32 {
                            ::prost::encoding::int32::encoded_len(1u32, &self.b)
                        } else { 0 }
            }
            fn clear(&mut self) { self.b = B::default() as i32; }
        }
        impl ::core::default::Default for A {
            fn default() -> Self { A { b: B::default() as i32 } }
        }
        impl ::core::fmt::Debug for A {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("A");
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res: ::core::result::Result<B, _> =
                                            ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.b)
                            };
                        builder.field("b", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl A {
            #[doc =
            "Returns the enum value of `b`, or the default if the field is set to an invalid enum value."]
            pub fn b(&self) -> B {
                ::core::convert::TryFrom::try_from(self.b).unwrap_or(B::default())
            }
            #[doc = "Sets `b` to the provided enum value."]
            pub fn set_b(&mut self, value: B) { self.b = value as i32; }
        }
        #[repr(i32)]
        pub enum B { Default = 0, NonDefault = 1, }
        #[automatically_derived]
        impl ::core::clone::Clone for B {
            #[inline]
            fn clone(&self) -> B { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for B { }
        #[automatically_derived]
        impl ::core::fmt::Debug for B {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        B::Default => "Default",
                        B::NonDefault => "NonDefault",
                    })
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for B { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for B {
            #[inline]
            fn eq(&self, other: &B) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for B {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for B {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for B {
            #[inline]
            fn partial_cmp(&self, other: &B)
                -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                    &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for B {
            #[inline]
            fn cmp(&self, other: &B) -> ::core::cmp::Ordering {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        impl B {
            #[doc = "Returns `true` if `value` is a variant of `B`."]
            pub fn is_valid(value: i32) -> bool {
                match value { 0 => true, 1 => true, _ => false, }
            }
            #[deprecated = "Use the TryFrom<i32> implementation instead"]
            #[doc =
            "Converts an `i32` to a `B`, or `None` if `value` is not a valid variant."]
            pub fn from_i32(value: i32) -> ::core::option::Option<B> {
                match value {
                    0 => ::core::option::Option::Some(B::Default),
                    1 => ::core::option::Option::Some(B::NonDefault),
                    _ => ::core::option::Option::None,
                }
            }
        }
        impl ::core::default::Default for B {
            fn default() -> B { B::Default }
        }
        impl ::core::convert::From<B> for i32 {
            fn from(value: B) -> i32 { value as i32 }
        }
        impl ::core::convert::TryFrom<i32> for B {
            type Error = ::prost::UnknownEnumValue;
            fn try_from(value: i32)
                -> ::core::result::Result<B, ::prost::UnknownEnumValue> {
                match value {
                    0 => ::core::result::Result::Ok(B::Default),
                    1 => ::core::result::Result::Ok(B::NonDefault),
                    _ =>
                        ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                }
            }
        }
        impl B {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Default => "DEFAULT",
                    Self::NonDefault => "NON_DEFAULT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str)
                -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT" => Some(Self::Default),
                    "NON_DEFAULT" => Some(Self::NonDefault),
                    _ => None,
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "no_shadowed_types::dummy"]
    #[doc(hidden)]
    pub const dummy: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("no_shadowed_types::dummy"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/no_shadowed_types.rs",
                start_line: 6usize,
                start_col: 4usize,
                end_line: 6usize,
                end_col: 9usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(dummy())),
        };
    fn dummy() {}
}
#[cfg(test)]
mod no_unused_results {
    mod should_compile_successfully {
        #![deny(unused_results)]
        pub struct Test {
            #[prost(string, tag = "1")]
            pub dummy_field: ::prost::alloc::string::String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Test {
            #[inline]
            fn clone(&self) -> Test {
                Test {
                    dummy_field: ::core::clone::Clone::clone(&self.dummy_field),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Test { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Test {
            #[inline]
            fn eq(&self, other: &Test) -> bool {
                self.dummy_field == other.dummy_field
            }
        }
        impl ::prost::Message for Test {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.dummy_field != "" {
                        ::prost::encoding::string::encode(1u32, &self.dummy_field,
                            buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "Test";
                match tag {
                    1u32 => {
                        let mut value = &mut self.dummy_field;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "dummy_field"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    if self.dummy_field != "" {
                            ::prost::encoding::string::encoded_len(1u32,
                                &self.dummy_field)
                        } else { 0 }
            }
            fn clear(&mut self) { self.dummy_field.clear(); }
        }
        impl ::core::default::Default for Test {
            fn default() -> Self {
                Test { dummy_field: ::prost::alloc::string::String::new() }
            }
        }
        impl ::core::fmt::Debug for Test {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Test");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.dummy_field)
                            };
                        builder.field("dummy_field", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "no_unused_results::dummy"]
    #[doc(hidden)]
    pub const dummy: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("no_unused_results::dummy"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/no_unused_results.rs",
                start_line: 7usize,
                start_col: 4usize,
                end_line: 7usize,
                end_col: 9usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(dummy())),
        };
    fn dummy() {}
}
#[cfg(test)]
mod submessage_without_package {
    pub struct M {
        #[prost(message, optional, tag = "2")]
        pub reply: ::core::option::Option<m::SubMessage>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for M {
        #[inline]
        fn clone(&self) -> M {
            M { reply: ::core::clone::Clone::clone(&self.reply) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for M { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for M {
        #[inline]
        fn eq(&self, other: &M) -> bool { self.reply == other.reply }
    }
    impl ::prost::Message for M {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.reply {
                    ::prost::encoding::message::encode(2u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "M";
            match tag {
                2u32 => {
                    let mut value = &mut self.reply;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "reply"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.reply.as_ref().map_or(0,
                    |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) { self.reply = ::core::option::Option::None; }
    }
    impl ::core::default::Default for M {
        fn default() -> Self {
            M { reply: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for M {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("M");
            let builder =
                {
                    let wrapper = &self.reply;
                    builder.field("reply", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `M`.
    pub mod m {
        pub struct SubMessage {
            #[prost(btree_map = "string, string", tag = "1")]
            pub item: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
            ::prost::alloc::string::String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SubMessage {
            #[inline]
            fn clone(&self) -> SubMessage {
                SubMessage { item: ::core::clone::Clone::clone(&self.item) }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SubMessage { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SubMessage {
            #[inline]
            fn eq(&self, other: &SubMessage) -> bool {
                self.item == other.item
            }
        }
        impl ::prost::Message for SubMessage {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encode,
                    ::prost::encoding::string::encoded_len, 1u32, &self.item,
                    buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "SubMessage";
                match tag {
                    1u32 => {
                        let mut value = &mut self.item;
                        ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                                ::prost::encoding::string::merge, &mut value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "item"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                        ::prost::encoding::string::encoded_len, 1u32, &self.item)
            }
            fn clear(&mut self) { self.item.clear(); }
        }
        impl ::core::default::Default for SubMessage {
            fn default() -> Self {
                SubMessage { item: ::core::default::Default::default() }
            }
        }
        impl ::core::fmt::Debug for SubMessage {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("SubMessage");
                let builder =
                    {
                        let wrapper =
                            {
                                struct MapWrapper<'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                    ::prost::alloc::string::String>);
                                impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn KeyWrapper<T>(v: T) -> T { v }
                                        #[allow(non_snake_case)]
                                        fn ValueWrapper<T>(v: T) -> T { v }
                                        let mut builder = f.debug_map();
                                        for (k, v) in self.0 {
                                            builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                        }
                                        builder.finish()
                                    }
                                }
                                MapWrapper(&self.item)
                            };
                        builder.field("item", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker =
    "submessage_without_package::test_submessage_without_package"]
    #[doc(hidden)]
    pub const test_submessage_without_package: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("submessage_without_package::test_submessage_without_package"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/submessage_without_package.rs",
                start_line: 4usize,
                start_col: 4usize,
                end_line: 4usize,
                end_col: 35usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_submessage_without_package())),
        };
    fn test_submessage_without_package() { let _msg = M::default(); }
}
#[cfg(test)]
mod type_names {
    use prost::Name;
    pub struct Foo {}
    #[automatically_derived]
    impl ::core::clone::Clone for Foo {
        #[inline]
        fn clone(&self) -> Foo { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Foo { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Foo { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Foo {
        #[inline]
        fn eq(&self, other: &Foo) -> bool { true }
    }
    impl ::prost::Message for Foo {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for Foo {
        fn default() -> Self { Foo {} }
    }
    impl ::core::fmt::Debug for Foo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Foo");
            builder.finish()
        }
    }
    /// Nested message and enum types in `Foo`.
    pub mod foo {
        pub struct Bar {}
        #[automatically_derived]
        impl ::core::clone::Clone for Bar {
            #[inline]
            fn clone(&self) -> Bar { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Bar { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Bar { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Bar {
            #[inline]
            fn eq(&self, other: &Bar) -> bool { true }
        }
        impl ::prost::Message for Bar {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize { 0 }
            fn clear(&mut self) {}
        }
        impl ::core::default::Default for Bar {
            fn default() -> Self { Bar {} }
        }
        impl ::core::fmt::Debug for Bar {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Bar");
                builder.finish()
            }
        }
        impl ::prost::Name for Bar {
            const NAME: &'static str = "Bar";
            const PACKAGE: &'static str = "type_names";
            fn full_name() -> ::prost::alloc::string::String {
                "type_names.Foo.Bar".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "tests/type_names.Foo.Bar".into()
            }
        }
    }
    impl ::prost::Name for Foo {
        const NAME: &'static str = "Foo";
        const PACKAGE: &'static str = "type_names";
        fn full_name() -> ::prost::alloc::string::String {
            "type_names.Foo".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "tests/type_names.Foo".into()
        }
    }
    pub struct Baz {}
    #[automatically_derived]
    impl ::core::clone::Clone for Baz {
        #[inline]
        fn clone(&self) -> Baz { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Baz { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Baz { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Baz {
        #[inline]
        fn eq(&self, other: &Baz) -> bool { true }
    }
    impl ::prost::Message for Baz {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for Baz {
        fn default() -> Self { Baz {} }
    }
    impl ::core::fmt::Debug for Baz {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Baz");
            builder.finish()
        }
    }
    impl ::prost::Name for Baz {
        const NAME: &'static str = "Baz";
        const PACKAGE: &'static str = "type_names";
        fn full_name() -> ::prost::alloc::string::String {
            "type_names.Baz".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/type_names.Baz".into()
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "type_names::valid_type_names"]
    #[doc(hidden)]
    pub const valid_type_names: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("type_names::valid_type_names"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/type_names.rs",
                start_line: 6usize,
                start_col: 4usize,
                end_line: 6usize,
                end_col: 20usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(valid_type_names())),
        };
    fn valid_type_names() {
        match (&"Foo", &Foo::NAME) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"type_names", &Foo::PACKAGE) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"type_names.Foo", &Foo::full_name()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"tests/type_names.Foo", &Foo::type_url()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"Bar", &foo::Bar::NAME) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"type_names", &foo::Bar::PACKAGE) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"type_names.Foo.Bar", &foo::Bar::full_name()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"tests/type_names.Foo.Bar", &foo::Bar::type_url()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"Baz", &Baz::NAME) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"type_names", &Baz::PACKAGE) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"type_names.Baz", &Baz::full_name()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&"/type_names.Baz", &Baz::type_url()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
#[cfg(test)]
mod boxed_field {
    pub struct Foo {
        #[prost(message, optional, boxed, tag = "1")]
        pub bar: ::core::option::Option<::prost::alloc::boxed::Box<Bar>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Foo {
        #[inline]
        fn clone(&self) -> Foo {
            Foo { bar: ::core::clone::Clone::clone(&self.bar) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Foo { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Foo {
        #[inline]
        fn eq(&self, other: &Foo) -> bool { self.bar == other.bar }
    }
    impl ::prost::Message for Foo {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.bar {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Foo";
            match tag {
                1u32 => {
                    let mut value = &mut self.bar;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "bar"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.bar.as_ref().map_or(0,
                    |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) { self.bar = ::core::option::Option::None; }
    }
    impl ::core::default::Default for Foo {
        fn default() -> Self {
            Foo { bar: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for Foo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Foo");
            let builder =
                { let wrapper = &self.bar; builder.field("bar", &wrapper) };
            ;
            builder.finish()
        }
    }
    pub struct Bar {}
    #[automatically_derived]
    impl ::core::clone::Clone for Bar {
        #[inline]
        fn clone(&self) -> Bar { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bar { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bar { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bar {
        #[inline]
        fn eq(&self, other: &Bar) -> bool { true }
    }
    impl ::prost::Message for Bar {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for Bar {
        fn default() -> Self { Bar {} }
    }
    impl ::core::fmt::Debug for Bar {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Bar");
            builder.finish()
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "boxed_field::test_bar_is_boxed"]
    #[doc(hidden)]
    pub const test_bar_is_boxed: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("boxed_field::test_bar_is_boxed"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/boxed_field.rs",
                start_line: 5usize,
                start_col: 4usize,
                end_line: 5usize,
                end_col: 21usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_bar_is_boxed())),
        };
    /// Confirm `Foo::bar` is boxed by creating an instance
    fn test_bar_is_boxed() {
        use alloc::boxed::Box;
        let _ = Foo { bar: Some(Box::new(Bar {})) };
    }
}
#[cfg(test)]
mod custom_debug {
    //! Tests for skipping the default Debug implementation.
    #[prost(skip_debug)]
    pub struct Msg {
        #[prost(int32, tag = "1")]
        pub a: i32,
        #[prost(string, tag = "2")]
        pub b: ::prost::alloc::string::String,
        #[prost(oneof = "msg::C", tags = "3, 4")]
        pub c: ::core::option::Option<msg::C>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Msg {
        #[inline]
        fn clone(&self) -> Msg {
            Msg {
                a: ::core::clone::Clone::clone(&self.a),
                b: ::core::clone::Clone::clone(&self.b),
                c: ::core::clone::Clone::clone(&self.c),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Msg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Msg {
        #[inline]
        fn eq(&self, other: &Msg) -> bool {
            self.a == other.a && self.b == other.b && self.c == other.c
        }
    }
    impl ::prost::Message for Msg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.a != 0i32 {
                    ::prost::encoding::int32::encode(1u32, &self.a, buf);
                }
            if self.b != "" {
                    ::prost::encoding::string::encode(2u32, &self.b, buf);
                }
            if let Some(ref oneof) = self.c { oneof.encode(buf) }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Msg";
            match tag {
                1u32 => {
                    let mut value = &mut self.a;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "a"); error })
                }
                2u32 => {
                    let mut value = &mut self.b;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "b"); error })
                }
                3u32 | 4u32 => {
                    let mut value = &mut self.c;
                    msg::C::merge(value, tag, wire_type, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "c"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                        if self.a != 0i32 {
                                ::prost::encoding::int32::encoded_len(1u32, &self.a)
                            } else { 0 } +
                    if self.b != "" {
                            ::prost::encoding::string::encoded_len(2u32, &self.b)
                        } else { 0 } +
                self.c.as_ref().map_or(0, msg::C::encoded_len)
        }
        fn clear(&mut self) {
            self.a = 0i32;
            self.b.clear();
            self.c = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Msg {
        fn default() -> Self {
            Msg {
                a: 0i32,
                b: ::prost::alloc::string::String::new(),
                c: ::core::default::Default::default(),
            }
        }
    }
    /// Nested message and enum types in `Msg`.
    pub mod msg {
        #[prost(skip_debug)]
        pub enum C {

            #[prost(enumeration = "super::AnEnum", tag = "3")]
            D(i32),

            #[prost(string, tag = "4")]
            E(::prost::alloc::string::String),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for C {
            #[inline]
            fn clone(&self) -> C {
                match self {
                    C::D(__self_0) =>
                        C::D(::core::clone::Clone::clone(__self_0)),
                    C::E(__self_0) =>
                        C::E(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for C { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for C {
            #[inline]
            fn eq(&self, other: &C) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (C::D(__self_0), C::D(__arg1_0)) => __self_0 == __arg1_0,
                        (C::E(__self_0), C::E(__arg1_0)) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl C {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    C::D(ref value) => {
                        ::prost::encoding::int32::encode(3u32, &*value, buf);
                    }
                    C::E(ref value) => {
                        ::prost::encoding::string::encode(4u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field: &mut ::core::option::Option<C>, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(C::D(ref mut value)) => {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field = ::core::option::Option::Some(C::D(owned_value)))
                            }
                        }
                    }
                    4u32 => {
                        match field {
                            ::core::option::Option::Some(C::E(ref mut value)) => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field = ::core::option::Option::Some(C::E(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid C tag: {0}", tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    C::D(ref value) =>
                        ::prost::encoding::int32::encoded_len(3u32, &*value),
                    C::E(ref value) =>
                        ::prost::encoding::string::encoded_len(4u32, &*value),
                }
            }
        }
    }
    #[repr(i32)]
    pub enum AnEnum { A = 0, B = 1, }
    #[automatically_derived]
    impl ::core::clone::Clone for AnEnum {
        #[inline]
        fn clone(&self) -> AnEnum { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AnEnum { }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnEnum {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self { AnEnum::A => "A", AnEnum::B => "B", })
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnEnum { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnEnum {
        #[inline]
        fn eq(&self, other: &AnEnum) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for AnEnum {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for AnEnum {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for AnEnum {
        #[inline]
        fn partial_cmp(&self, other: &AnEnum)
            -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for AnEnum {
        #[inline]
        fn cmp(&self, other: &AnEnum) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl AnEnum {
        #[doc = "Returns `true` if `value` is a variant of `AnEnum`."]
        pub fn is_valid(value: i32) -> bool {
            match value { 0 => true, 1 => true, _ => false, }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `AnEnum`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32) -> ::core::option::Option<AnEnum> {
            match value {
                0 => ::core::option::Option::Some(AnEnum::A),
                1 => ::core::option::Option::Some(AnEnum::B),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for AnEnum {
        fn default() -> AnEnum { AnEnum::A }
    }
    impl ::core::convert::From<AnEnum> for i32 {
        fn from(value: AnEnum) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for AnEnum {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            -> ::core::result::Result<AnEnum, ::prost::UnknownEnumValue> {
            match value {
                0 => ::core::result::Result::Ok(AnEnum::A),
                1 => ::core::result::Result::Ok(AnEnum::B),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl AnEnum {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self { Self::A => "A", Self::B => "B", }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "A" => Some(Self::A),
                "B" => Some(Self::B),
                _ => None,
            }
        }
    }
    use alloc::format;
    use alloc::string::String;
    use alloc::string::ToString;
    use core::fmt;
    use prost::OpenEnum;
    impl fmt::Debug for Msg {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_str("Msg {..}")
        }
    }
    mod int_enum {
        use super::*;
        extern crate test;
        #[cfg(test)]
        #[rustc_test_marker =
        "custom_debug::int_enum::tuple_struct_custom_debug"]
        #[doc(hidden)]
        pub const tuple_struct_custom_debug: test::TestDescAndFn =
            test::TestDescAndFn {
                desc: test::TestDesc {
                    name: test::StaticTestName("custom_debug::int_enum::tuple_struct_custom_debug"),
                    ignore: false,
                    ignore_message: ::core::option::Option::None,
                    source_file: "tests/src/custom_debug.rs",
                    start_line: 22usize,
                    start_col: 8usize,
                    end_line: 22usize,
                    end_col: 33usize,
                    compile_fail: false,
                    no_run: false,
                    should_panic: test::ShouldPanic::No,
                    test_type: test::TestType::UnitTest,
                },
                testfn: test::StaticTestFn(#[coverage(off)] ||
                        test::assert_test_result(tuple_struct_custom_debug())),
            };
        /// A special case with a tuple struct
        fn tuple_struct_custom_debug() {
            #[prost(skip_debug)]
            struct NewType(
                #[prost(enumeration = "AnEnum", tag = "5")]
                i32);
            #[automatically_derived]
            impl ::core::clone::Clone for NewType {
                #[inline]
                fn clone(&self) -> NewType {
                    NewType(::core::clone::Clone::clone(&self.0))
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NewType { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NewType {
                #[inline]
                fn eq(&self, other: &NewType) -> bool { self.0 == other.0 }
            }
            impl ::prost::Message for NewType {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    if self.0 != AnEnum::default() as i32 {
                            ::prost::encoding::int32::encode(5u32, &self.0, buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    const STRUCT_NAME: &'static str = "NewType";
                    match tag {
                        5u32 => {
                            let mut value = &mut self.0;
                            ::prost::encoding::int32::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "0"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                        if self.0 != AnEnum::default() as i32 {
                                ::prost::encoding::int32::encoded_len(5u32, &self.0)
                            } else { 0 }
                }
                fn clear(&mut self) { self.0 = AnEnum::default() as i32; }
            }
            impl ::core::default::Default for NewType {
                fn default() -> Self { NewType(AnEnum::default() as i32) }
            }
            #[allow(dead_code)]
            impl NewType {
                #[doc =
                "Returns the enum value of `0`, or the default if the field is set to an invalid enum value."]
                pub fn get_0(&self) -> AnEnum {
                    ::core::convert::TryFrom::try_from(self.0).unwrap_or(AnEnum::default())
                }
                #[doc = "Sets `0` to the provided enum value."]
                pub fn set_0(&mut self, value: AnEnum) {
                    self.0 = value as i32;
                }
            }
            impl fmt::Debug for NewType {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.write_str("NewType(custom_debug)")
                }
            }
            match (&::alloc::__export::must_use({
                                let res =
                                    ::alloc::fmt::format(format_args!("{0:?}",
                                            NewType(AnEnum::B.into())));
                                res
                            }), &"NewType(custom_debug)") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        }
        #[prost(skip_debug)]
        pub enum OneofWithEnumCustomDebug {

            #[prost(int32, tag = "8")]
            Int(i32),

            #[prost(string, tag = "9")]
            String(String),

            #[prost(enumeration = "AnEnum", tag = "10")]
            Enumeration(i32),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OneofWithEnumCustomDebug {
            #[inline]
            fn clone(&self) -> OneofWithEnumCustomDebug {
                match self {
                    OneofWithEnumCustomDebug::Int(__self_0) =>
                        OneofWithEnumCustomDebug::Int(::core::clone::Clone::clone(__self_0)),
                    OneofWithEnumCustomDebug::String(__self_0) =>
                        OneofWithEnumCustomDebug::String(::core::clone::Clone::clone(__self_0)),
                    OneofWithEnumCustomDebug::Enumeration(__self_0) =>
                        OneofWithEnumCustomDebug::Enumeration(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OneofWithEnumCustomDebug
            {
        }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OneofWithEnumCustomDebug {
            #[inline]
            fn eq(&self, other: &OneofWithEnumCustomDebug) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (OneofWithEnumCustomDebug::Int(__self_0),
                            OneofWithEnumCustomDebug::Int(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (OneofWithEnumCustomDebug::String(__self_0),
                            OneofWithEnumCustomDebug::String(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (OneofWithEnumCustomDebug::Enumeration(__self_0),
                            OneofWithEnumCustomDebug::Enumeration(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl OneofWithEnumCustomDebug {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    OneofWithEnumCustomDebug::Int(ref value) => {
                        ::prost::encoding::int32::encode(8u32, &*value, buf);
                    }
                    OneofWithEnumCustomDebug::String(ref value) => {
                        ::prost::encoding::string::encode(9u32, &*value, buf);
                    }
                    OneofWithEnumCustomDebug::Enumeration(ref value) => {
                        ::prost::encoding::int32::encode(10u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field:
                    &mut ::core::option::Option<OneofWithEnumCustomDebug>,
                tag: u32, wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    8u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Int(ref mut value))
                                => {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Int(owned_value)))
                            }
                        }
                    }
                    9u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::String(ref mut value))
                                => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::String(owned_value)))
                            }
                        }
                    }
                    10u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Enumeration(ref mut value))
                                => {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Enumeration(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid OneofWithEnumCustomDebug tag: {0}",
                                    tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    OneofWithEnumCustomDebug::Int(ref value) =>
                        ::prost::encoding::int32::encoded_len(8u32, &*value),
                    OneofWithEnumCustomDebug::String(ref value) =>
                        ::prost::encoding::string::encoded_len(9u32, &*value),
                    OneofWithEnumCustomDebug::Enumeration(ref value) =>
                        ::prost::encoding::int32::encoded_len(10u32, &*value),
                }
            }
        }
        impl fmt::Debug for OneofWithEnumCustomDebug {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("OneofWithEnumCustomDebug {..}")
            }
        }
        #[prost(skip_debug)]
        struct MessageWithOneofCustomDebug {
            #[prost(oneof = "OneofWithEnumCustomDebug", tags = "8, 9, 10")]
            of: Option<OneofWithEnumCustomDebug>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MessageWithOneofCustomDebug {
            #[inline]
            fn clone(&self) -> MessageWithOneofCustomDebug {
                MessageWithOneofCustomDebug {
                    of: ::core::clone::Clone::clone(&self.of),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for
            MessageWithOneofCustomDebug {
        }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MessageWithOneofCustomDebug {
            #[inline]
            fn eq(&self, other: &MessageWithOneofCustomDebug) -> bool {
                self.of == other.of
            }
        }
        impl ::prost::Message for MessageWithOneofCustomDebug {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref oneof) = self.of { oneof.encode(buf) }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str =
                    "MessageWithOneofCustomDebug";
                match tag {
                    8u32 | 9u32 | 10u32 => {
                        let mut value = &mut self.of;
                        OneofWithEnumCustomDebug::merge(value, tag, wire_type, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "of"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.of.as_ref().map_or(0,
                        OneofWithEnumCustomDebug::encoded_len)
            }
            fn clear(&mut self) { self.of = ::core::option::Option::None; }
        }
        impl ::core::default::Default for MessageWithOneofCustomDebug {
            fn default() -> Self {
                MessageWithOneofCustomDebug {
                    of: ::core::default::Default::default(),
                }
            }
        }
        impl fmt::Debug for MessageWithOneofCustomDebug {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("MessageWithOneofCustomDebug {..}")
            }
        }
        extern crate test;
        #[cfg(test)]
        #[rustc_test_marker =
        "custom_debug::int_enum::oneof_with_enum_custom_debug"]
        #[doc(hidden)]
        pub const oneof_with_enum_custom_debug: test::TestDescAndFn =
            test::TestDescAndFn {
                desc: test::TestDesc {
                    name: test::StaticTestName("custom_debug::int_enum::oneof_with_enum_custom_debug"),
                    ignore: false,
                    ignore_message: ::core::option::Option::None,
                    source_file: "tests/src/custom_debug.rs",
                    start_line: 68usize,
                    start_col: 8usize,
                    end_line: 68usize,
                    end_col: 36usize,
                    compile_fail: false,
                    no_run: false,
                    should_panic: test::ShouldPanic::No,
                    test_type: test::TestType::UnitTest,
                },
                testfn: test::StaticTestFn(#[coverage(off)] ||
                        test::assert_test_result(oneof_with_enum_custom_debug())),
            };
        /// Enumerations inside oneofs
        fn oneof_with_enum_custom_debug() {
            let of = OneofWithEnumCustomDebug::Enumeration(AnEnum::B.into());
            match (&::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(format_args!("{0:?}", of));
                                res
                            }), &"OneofWithEnumCustomDebug {..}") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
            let msg = MessageWithOneofCustomDebug { of: Some(of) };
            match (&::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(format_args!("{0:?}", msg));
                                res
                            }), &"MessageWithOneofCustomDebug {..}") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        }
    }
    mod open_enum {
        use super::*;
        extern crate test;
        #[cfg(test)]
        #[rustc_test_marker =
        "custom_debug::open_enum::tuple_struct_custom_debug"]
        #[doc(hidden)]
        pub const tuple_struct_custom_debug: test::TestDescAndFn =
            test::TestDescAndFn {
                desc: test::TestDesc {
                    name: test::StaticTestName("custom_debug::open_enum::tuple_struct_custom_debug"),
                    ignore: false,
                    ignore_message: ::core::option::Option::None,
                    source_file: "tests/src/custom_debug.rs",
                    start_line: 81usize,
                    start_col: 8usize,
                    end_line: 81usize,
                    end_col: 33usize,
                    compile_fail: false,
                    no_run: false,
                    should_panic: test::ShouldPanic::No,
                    test_type: test::TestType::UnitTest,
                },
                testfn: test::StaticTestFn(#[coverage(off)] ||
                        test::assert_test_result(tuple_struct_custom_debug())),
            };
        /// A special case with a tuple struct
        fn tuple_struct_custom_debug() {
            #[prost(skip_debug)]
            struct NewType(
                #[prost(enumeration = "AnEnum", enum_type = "open", tag =
                "5")]
                OpenEnum<AnEnum>);
            #[automatically_derived]
            impl ::core::clone::Clone for NewType {
                #[inline]
                fn clone(&self) -> NewType {
                    NewType(::core::clone::Clone::clone(&self.0))
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NewType { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NewType {
                #[inline]
                fn eq(&self, other: &NewType) -> bool { self.0 == other.0 }
            }
            impl ::prost::Message for NewType {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    if self.0 != ::prost::OpenEnum::Known(AnEnum::default()) {
                            ::prost::encoding::open_enum::encode(5u32, &self.0, buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    const STRUCT_NAME: &'static str = "NewType";
                    match tag {
                        5u32 => {
                            let mut value = &mut self.0;
                            ::prost::encoding::open_enum::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "0"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                        if self.0 != ::prost::OpenEnum::Known(AnEnum::default()) {
                                ::prost::encoding::open_enum::encoded_len(5u32, &self.0)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.0 = ::prost::OpenEnum::Known(AnEnum::default());
                }
            }
            impl ::core::default::Default for NewType {
                fn default() -> Self {
                    NewType(::prost::OpenEnum::Known(AnEnum::default()))
                }
            }
            impl fmt::Debug for NewType {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.write_str("NewType(custom_debug)")
                }
            }
            match (&::alloc::__export::must_use({
                                let res =
                                    ::alloc::fmt::format(format_args!("{0:?}",
                                            NewType(AnEnum::B.into())));
                                res
                            }), &"NewType(custom_debug)") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        }
        #[prost(skip_debug)]
        pub enum OneofWithEnumCustomDebug {

            #[prost(int32, tag = "8")]
            Int(i32),

            #[prost(string, tag = "9")]
            String(String),

            #[prost(enumeration = "AnEnum", enum_type = "open", tag = "10")]
            Enumeration(OpenEnum<AnEnum>),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OneofWithEnumCustomDebug {
            #[inline]
            fn clone(&self) -> OneofWithEnumCustomDebug {
                match self {
                    OneofWithEnumCustomDebug::Int(__self_0) =>
                        OneofWithEnumCustomDebug::Int(::core::clone::Clone::clone(__self_0)),
                    OneofWithEnumCustomDebug::String(__self_0) =>
                        OneofWithEnumCustomDebug::String(::core::clone::Clone::clone(__self_0)),
                    OneofWithEnumCustomDebug::Enumeration(__self_0) =>
                        OneofWithEnumCustomDebug::Enumeration(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OneofWithEnumCustomDebug
            {
        }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OneofWithEnumCustomDebug {
            #[inline]
            fn eq(&self, other: &OneofWithEnumCustomDebug) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (OneofWithEnumCustomDebug::Int(__self_0),
                            OneofWithEnumCustomDebug::Int(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (OneofWithEnumCustomDebug::String(__self_0),
                            OneofWithEnumCustomDebug::String(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (OneofWithEnumCustomDebug::Enumeration(__self_0),
                            OneofWithEnumCustomDebug::Enumeration(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl OneofWithEnumCustomDebug {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    OneofWithEnumCustomDebug::Int(ref value) => {
                        ::prost::encoding::int32::encode(8u32, &*value, buf);
                    }
                    OneofWithEnumCustomDebug::String(ref value) => {
                        ::prost::encoding::string::encode(9u32, &*value, buf);
                    }
                    OneofWithEnumCustomDebug::Enumeration(ref value) => {
                        ::prost::encoding::open_enum::encode(10u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field:
                    &mut ::core::option::Option<OneofWithEnumCustomDebug>,
                tag: u32, wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    8u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Int(ref mut value))
                                => {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Int(owned_value)))
                            }
                        }
                    }
                    9u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::String(ref mut value))
                                => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::String(owned_value)))
                            }
                        }
                    }
                    10u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Enumeration(ref mut value))
                                => {
                                ::prost::encoding::open_enum::merge(wire_type, value, buf,
                                    ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::open_enum::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Enumeration(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid OneofWithEnumCustomDebug tag: {0}",
                                    tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    OneofWithEnumCustomDebug::Int(ref value) =>
                        ::prost::encoding::int32::encoded_len(8u32, &*value),
                    OneofWithEnumCustomDebug::String(ref value) =>
                        ::prost::encoding::string::encoded_len(9u32, &*value),
                    OneofWithEnumCustomDebug::Enumeration(ref value) =>
                        ::prost::encoding::open_enum::encoded_len(10u32, &*value),
                }
            }
        }
        impl fmt::Debug for OneofWithEnumCustomDebug {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("OneofWithEnumCustomDebug {..}")
            }
        }
        #[prost(skip_debug)]
        struct MessageWithOneofCustomDebug {
            #[prost(oneof = "OneofWithEnumCustomDebug", tags = "8, 9, 10")]
            of: Option<OneofWithEnumCustomDebug>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MessageWithOneofCustomDebug {
            #[inline]
            fn clone(&self) -> MessageWithOneofCustomDebug {
                MessageWithOneofCustomDebug {
                    of: ::core::clone::Clone::clone(&self.of),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for
            MessageWithOneofCustomDebug {
        }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MessageWithOneofCustomDebug {
            #[inline]
            fn eq(&self, other: &MessageWithOneofCustomDebug) -> bool {
                self.of == other.of
            }
        }
        impl ::prost::Message for MessageWithOneofCustomDebug {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref oneof) = self.of { oneof.encode(buf) }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str =
                    "MessageWithOneofCustomDebug";
                match tag {
                    8u32 | 9u32 | 10u32 => {
                        let mut value = &mut self.of;
                        OneofWithEnumCustomDebug::merge(value, tag, wire_type, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "of"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.of.as_ref().map_or(0,
                        OneofWithEnumCustomDebug::encoded_len)
            }
            fn clear(&mut self) { self.of = ::core::option::Option::None; }
        }
        impl ::core::default::Default for MessageWithOneofCustomDebug {
            fn default() -> Self {
                MessageWithOneofCustomDebug {
                    of: ::core::default::Default::default(),
                }
            }
        }
        impl fmt::Debug for MessageWithOneofCustomDebug {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("MessageWithOneofCustomDebug {..}")
            }
        }
        extern crate test;
        #[cfg(test)]
        #[rustc_test_marker =
        "custom_debug::open_enum::oneof_with_enum_custom_debug"]
        #[doc(hidden)]
        pub const oneof_with_enum_custom_debug: test::TestDescAndFn =
            test::TestDescAndFn {
                desc: test::TestDesc {
                    name: test::StaticTestName("custom_debug::open_enum::oneof_with_enum_custom_debug"),
                    ignore: false,
                    ignore_message: ::core::option::Option::None,
                    source_file: "tests/src/custom_debug.rs",
                    start_line: 129usize,
                    start_col: 8usize,
                    end_line: 129usize,
                    end_col: 36usize,
                    compile_fail: false,
                    no_run: false,
                    should_panic: test::ShouldPanic::No,
                    test_type: test::TestType::UnitTest,
                },
                testfn: test::StaticTestFn(#[coverage(off)] ||
                        test::assert_test_result(oneof_with_enum_custom_debug())),
            };
        /// Enumerations inside oneofs
        fn oneof_with_enum_custom_debug() {
            let of = OneofWithEnumCustomDebug::Enumeration(AnEnum::B.into());
            match (&::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(format_args!("{0:?}", of));
                                res
                            }), &"OneofWithEnumCustomDebug {..}") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
            let msg = MessageWithOneofCustomDebug { of: Some(of) };
            match (&::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(format_args!("{0:?}", msg));
                                res
                            }), &"MessageWithOneofCustomDebug {..}") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        }
    }
    mod closed_enum {
        use super::*;
        extern crate test;
        #[cfg(test)]
        #[rustc_test_marker =
        "custom_debug::closed_enum::tuple_struct_custom_debug"]
        #[doc(hidden)]
        pub const tuple_struct_custom_debug: test::TestDescAndFn =
            test::TestDescAndFn {
                desc: test::TestDesc {
                    name: test::StaticTestName("custom_debug::closed_enum::tuple_struct_custom_debug"),
                    ignore: false,
                    ignore_message: ::core::option::Option::None,
                    source_file: "tests/src/custom_debug.rs",
                    start_line: 142usize,
                    start_col: 8usize,
                    end_line: 142usize,
                    end_col: 33usize,
                    compile_fail: false,
                    no_run: false,
                    should_panic: test::ShouldPanic::No,
                    test_type: test::TestType::UnitTest,
                },
                testfn: test::StaticTestFn(#[coverage(off)] ||
                        test::assert_test_result(tuple_struct_custom_debug())),
            };
        /// A special case with a tuple struct
        fn tuple_struct_custom_debug() {
            #[prost(skip_debug)]
            struct NewType(
                #[prost(enumeration = "AnEnum", enum_type = "closed", tag =
                "5")]
                AnEnum);
            #[automatically_derived]
            impl ::core::clone::Clone for NewType {
                #[inline]
                fn clone(&self) -> NewType {
                    NewType(::core::clone::Clone::clone(&self.0))
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NewType { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NewType {
                #[inline]
                fn eq(&self, other: &NewType) -> bool { self.0 == other.0 }
            }
            impl ::prost::Message for NewType {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    if self.0 != AnEnum::default() {
                            ::prost::encoding::closed_enum::encode(5u32, &self.0, buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    const STRUCT_NAME: &'static str = "NewType";
                    match tag {
                        5u32 => {
                            let mut value = &mut self.0;
                            ::prost::encoding::closed_enum::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "0"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                        if self.0 != AnEnum::default() {
                                ::prost::encoding::closed_enum::encoded_len(5u32, &self.0)
                            } else { 0 }
                }
                fn clear(&mut self) { self.0 = AnEnum::default(); }
            }
            impl ::core::default::Default for NewType {
                fn default() -> Self { NewType(AnEnum::default()) }
            }
            impl fmt::Debug for NewType {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.write_str("NewType(custom_debug)")
                }
            }
            match (&::alloc::__export::must_use({
                                let res =
                                    ::alloc::fmt::format(format_args!("{0:?}",
                                            NewType(AnEnum::B.into())));
                                res
                            }), &"NewType(custom_debug)") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        }
        #[prost(skip_debug)]
        pub enum OneofWithEnumCustomDebug {

            #[prost(int32, tag = "8")]
            Int(i32),

            #[prost(string, tag = "9")]
            String(String),

            #[prost(enumeration = "AnEnum", enum_type = "closed", tag = "10")]
            Enumeration(AnEnum),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OneofWithEnumCustomDebug {
            #[inline]
            fn clone(&self) -> OneofWithEnumCustomDebug {
                match self {
                    OneofWithEnumCustomDebug::Int(__self_0) =>
                        OneofWithEnumCustomDebug::Int(::core::clone::Clone::clone(__self_0)),
                    OneofWithEnumCustomDebug::String(__self_0) =>
                        OneofWithEnumCustomDebug::String(::core::clone::Clone::clone(__self_0)),
                    OneofWithEnumCustomDebug::Enumeration(__self_0) =>
                        OneofWithEnumCustomDebug::Enumeration(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OneofWithEnumCustomDebug
            {
        }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OneofWithEnumCustomDebug {
            #[inline]
            fn eq(&self, other: &OneofWithEnumCustomDebug) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (OneofWithEnumCustomDebug::Int(__self_0),
                            OneofWithEnumCustomDebug::Int(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (OneofWithEnumCustomDebug::String(__self_0),
                            OneofWithEnumCustomDebug::String(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (OneofWithEnumCustomDebug::Enumeration(__self_0),
                            OneofWithEnumCustomDebug::Enumeration(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl OneofWithEnumCustomDebug {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    OneofWithEnumCustomDebug::Int(ref value) => {
                        ::prost::encoding::int32::encode(8u32, &*value, buf);
                    }
                    OneofWithEnumCustomDebug::String(ref value) => {
                        ::prost::encoding::string::encode(9u32, &*value, buf);
                    }
                    OneofWithEnumCustomDebug::Enumeration(ref value) => {
                        ::prost::encoding::closed_enum::encode(10u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field:
                    &mut ::core::option::Option<OneofWithEnumCustomDebug>,
                tag: u32, wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    8u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Int(ref mut value))
                                => {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Int(owned_value)))
                            }
                        }
                    }
                    9u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::String(ref mut value))
                                => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::String(owned_value)))
                            }
                        }
                    }
                    10u32 => {
                        match field {
                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Enumeration(ref mut value))
                                => {
                                ::prost::encoding::closed_enum::merge(wire_type, value, buf,
                                    ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::closed_enum::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(OneofWithEnumCustomDebug::Enumeration(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid OneofWithEnumCustomDebug tag: {0}",
                                    tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    OneofWithEnumCustomDebug::Int(ref value) =>
                        ::prost::encoding::int32::encoded_len(8u32, &*value),
                    OneofWithEnumCustomDebug::String(ref value) =>
                        ::prost::encoding::string::encoded_len(9u32, &*value),
                    OneofWithEnumCustomDebug::Enumeration(ref value) =>
                        ::prost::encoding::closed_enum::encoded_len(10u32, &*value),
                }
            }
        }
        impl fmt::Debug for OneofWithEnumCustomDebug {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("OneofWithEnumCustomDebug {..}")
            }
        }
        #[prost(skip_debug)]
        struct MessageWithOneofCustomDebug {
            #[prost(oneof = "OneofWithEnumCustomDebug", tags = "8, 9, 10")]
            of: Option<OneofWithEnumCustomDebug>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MessageWithOneofCustomDebug {
            #[inline]
            fn clone(&self) -> MessageWithOneofCustomDebug {
                MessageWithOneofCustomDebug {
                    of: ::core::clone::Clone::clone(&self.of),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for
            MessageWithOneofCustomDebug {
        }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MessageWithOneofCustomDebug {
            #[inline]
            fn eq(&self, other: &MessageWithOneofCustomDebug) -> bool {
                self.of == other.of
            }
        }
        impl ::prost::Message for MessageWithOneofCustomDebug {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref oneof) = self.of { oneof.encode(buf) }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str =
                    "MessageWithOneofCustomDebug";
                match tag {
                    8u32 | 9u32 | 10u32 => {
                        let mut value = &mut self.of;
                        OneofWithEnumCustomDebug::merge(value, tag, wire_type, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "of"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.of.as_ref().map_or(0,
                        OneofWithEnumCustomDebug::encoded_len)
            }
            fn clear(&mut self) { self.of = ::core::option::Option::None; }
        }
        impl ::core::default::Default for MessageWithOneofCustomDebug {
            fn default() -> Self {
                MessageWithOneofCustomDebug {
                    of: ::core::default::Default::default(),
                }
            }
        }
        impl fmt::Debug for MessageWithOneofCustomDebug {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("MessageWithOneofCustomDebug {..}")
            }
        }
        extern crate test;
        #[cfg(test)]
        #[rustc_test_marker =
        "custom_debug::closed_enum::oneof_with_enum_custom_debug"]
        #[doc(hidden)]
        pub const oneof_with_enum_custom_debug: test::TestDescAndFn =
            test::TestDescAndFn {
                desc: test::TestDesc {
                    name: test::StaticTestName("custom_debug::closed_enum::oneof_with_enum_custom_debug"),
                    ignore: false,
                    ignore_message: ::core::option::Option::None,
                    source_file: "tests/src/custom_debug.rs",
                    start_line: 188usize,
                    start_col: 8usize,
                    end_line: 188usize,
                    end_col: 36usize,
                    compile_fail: false,
                    no_run: false,
                    should_panic: test::ShouldPanic::No,
                    test_type: test::TestType::UnitTest,
                },
                testfn: test::StaticTestFn(#[coverage(off)] ||
                        test::assert_test_result(oneof_with_enum_custom_debug())),
            };
        /// Enumerations inside oneofs
        fn oneof_with_enum_custom_debug() {
            let of = OneofWithEnumCustomDebug::Enumeration(AnEnum::B.into());
            match (&::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(format_args!("{0:?}", of));
                                res
                            }), &"OneofWithEnumCustomDebug {..}") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
            let msg = MessageWithOneofCustomDebug { of: Some(of) };
            match (&::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(format_args!("{0:?}", msg));
                                res
                            }), &"MessageWithOneofCustomDebug {..}") {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(kind, &*left_val,
                                &*right_val, ::core::option::Option::None);
                        }
                }
            };
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "custom_debug::test_proto_msg_custom_debug"]
    #[doc(hidden)]
    pub const test_proto_msg_custom_debug: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("custom_debug::test_proto_msg_custom_debug"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/custom_debug.rs",
                start_line: 198usize,
                start_col: 4usize,
                end_line: 198usize,
                end_col: 31usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_proto_msg_custom_debug())),
        };
    /// Generated protobufs
    fn test_proto_msg_custom_debug() {
        let msg =
            Msg {
                a: 0,
                b: "".to_string(),
                c: Some(msg::C::D(AnEnum::A.into())),
            };
        match (&::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0:?}", msg));
                            res
                        }), &"Msg {..}") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
}
pub mod disable_comments {
    //! MessageWithInvalidDoctest would generate a invalid doc test if
    //! `Config::disable_comments` doesn't work correctly.
    pub struct MessageWithInvalidDoctest {}
    #[automatically_derived]
    impl ::core::clone::Clone for MessageWithInvalidDoctest {
        #[inline]
        fn clone(&self) -> MessageWithInvalidDoctest { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for MessageWithInvalidDoctest { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MessageWithInvalidDoctest { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MessageWithInvalidDoctest {
        #[inline]
        fn eq(&self, other: &MessageWithInvalidDoctest) -> bool { true }
    }
    impl ::prost::Message for MessageWithInvalidDoctest {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for MessageWithInvalidDoctest {
        fn default() -> Self { MessageWithInvalidDoctest {} }
    }
    impl ::core::fmt::Debug for MessageWithInvalidDoctest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("MessageWithInvalidDoctest");
            builder.finish()
        }
    }
}
mod test_enum_named_option_value {
    pub struct FailMessage {
        #[prost(enumeration = "Option", tag = "1")]
        pub result: i32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FailMessage {
        #[inline]
        fn clone(&self) -> FailMessage {
            let _: ::core::clone::AssertParamIsClone<i32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FailMessage { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FailMessage { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FailMessage {
        #[inline]
        fn eq(&self, other: &FailMessage) -> bool {
            self.result == other.result
        }
    }
    impl ::prost::Message for FailMessage {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.result != Option::default() as i32 {
                    ::prost::encoding::int32::encode(1u32, &self.result, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "FailMessage";
            match tag {
                1u32 => {
                    let mut value = &mut self.result;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "result"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                if self.result != Option::default() as i32 {
                        ::prost::encoding::int32::encoded_len(1u32, &self.result)
                    } else { 0 }
        }
        fn clear(&mut self) { self.result = Option::default() as i32; }
    }
    impl ::core::default::Default for FailMessage {
        fn default() -> Self {
            FailMessage { result: Option::default() as i32 }
        }
    }
    impl ::core::fmt::Debug for FailMessage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FailMessage");
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let res: ::core::result::Result<Option, _> =
                                        ::core::convert::TryFrom::try_from(*self.0);
                                    match res {
                                        Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                        Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.result)
                        };
                    builder.field("result", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl FailMessage {
        #[doc =
        "Returns the enum value of `result`, or the default if the field is set to an invalid enum value."]
        pub fn result(&self) -> Option {
            ::core::convert::TryFrom::try_from(self.result).unwrap_or(Option::default())
        }
        #[doc = "Sets `result` to the provided enum value."]
        pub fn set_result(&mut self, value: Option) {
            self.result = value as i32;
        }
    }
    #[repr(i32)]
    pub enum Option { Hello = 0, }
    #[automatically_derived]
    impl ::core::clone::Clone for Option {
        #[inline]
        fn clone(&self) -> Option { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Option { }
    #[automatically_derived]
    impl ::core::fmt::Debug for Option {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Hello")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Option { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Option {
        #[inline]
        fn eq(&self, other: &Option) -> bool { true }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Option {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Option {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Option {
        #[inline]
        fn partial_cmp(&self, other: &Option)
            -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Option {
        #[inline]
        fn cmp(&self, other: &Option) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    impl Option {
        #[doc = "Returns `true` if `value` is a variant of `Option`."]
        pub fn is_valid(value: i32) -> bool {
            match value { 0 => true, _ => false, }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `Option`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32) -> ::core::option::Option<Option> {
            match value {
                0 => ::core::option::Option::Some(Option::Hello),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for Option {
        fn default() -> Option { Option::Hello }
    }
    impl ::core::convert::From<Option> for i32 {
        fn from(value: Option) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for Option {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            -> ::core::result::Result<Option, ::prost::UnknownEnumValue> {
            match value {
                0 => ::core::result::Result::Ok(Option::Hello),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl Option {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self { Self::Hello => "HELLO", }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value { "HELLO" => Some(Self::Hello), _ => None, }
        }
    }
}
mod test_enum_named_result_value {
    pub struct FailMessage {
        #[prost(enumeration = "Result", tag = "1")]
        pub result: i32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FailMessage {
        #[inline]
        fn clone(&self) -> FailMessage {
            let _: ::core::clone::AssertParamIsClone<i32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FailMessage { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FailMessage { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FailMessage {
        #[inline]
        fn eq(&self, other: &FailMessage) -> bool {
            self.result == other.result
        }
    }
    impl ::prost::Message for FailMessage {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.result != Result::default() as i32 {
                    ::prost::encoding::int32::encode(1u32, &self.result, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "FailMessage";
            match tag {
                1u32 => {
                    let mut value = &mut self.result;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "result"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                if self.result != Result::default() as i32 {
                        ::prost::encoding::int32::encoded_len(1u32, &self.result)
                    } else { 0 }
        }
        fn clear(&mut self) { self.result = Result::default() as i32; }
    }
    impl ::core::default::Default for FailMessage {
        fn default() -> Self {
            FailMessage { result: Result::default() as i32 }
        }
    }
    impl ::core::fmt::Debug for FailMessage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FailMessage");
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    let res: ::core::result::Result<Result, _> =
                                        ::core::convert::TryFrom::try_from(*self.0);
                                    match res {
                                        Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                        Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.result)
                        };
                    builder.field("result", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl FailMessage {
        #[doc =
        "Returns the enum value of `result`, or the default if the field is set to an invalid enum value."]
        pub fn result(&self) -> Result {
            ::core::convert::TryFrom::try_from(self.result).unwrap_or(Result::default())
        }
        #[doc = "Sets `result` to the provided enum value."]
        pub fn set_result(&mut self, value: Result) {
            self.result = value as i32;
        }
    }
    #[repr(i32)]
    pub enum Result { Hello = 0, }
    #[automatically_derived]
    impl ::core::clone::Clone for Result {
        #[inline]
        fn clone(&self) -> Result { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Result { }
    #[automatically_derived]
    impl ::core::fmt::Debug for Result {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Hello")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Result { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Result {
        #[inline]
        fn eq(&self, other: &Result) -> bool { true }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Result {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Result {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Result {
        #[inline]
        fn partial_cmp(&self, other: &Result)
            -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Result {
        #[inline]
        fn cmp(&self, other: &Result) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    impl Result {
        #[doc = "Returns `true` if `value` is a variant of `Result`."]
        pub fn is_valid(value: i32) -> bool {
            match value { 0 => true, _ => false, }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `Result`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32) -> ::core::option::Option<Result> {
            match value {
                0 => ::core::option::Option::Some(Result::Hello),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for Result {
        fn default() -> Result { Result::Hello }
    }
    impl ::core::convert::From<Result> for i32 {
        fn from(value: Result) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for Result {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            -> ::core::result::Result<Result, ::prost::UnknownEnumValue> {
            match value {
                0 => ::core::result::Result::Ok(Result::Hello),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self { Self::Hello => "HELLO", }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value { "HELLO" => Some(Self::Hello), _ => None, }
        }
    }
}
mod test_result_named_option_value {
    pub struct Option {
        #[prost(string, tag = "1")]
        pub msg: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Option {
        #[inline]
        fn clone(&self) -> Option {
            Option { msg: ::core::clone::Clone::clone(&self.msg) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Option { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Option {
        #[inline]
        fn eq(&self, other: &Option) -> bool { self.msg == other.msg }
    }
    impl ::prost::Message for Option {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.msg != "" {
                    ::prost::encoding::string::encode(1u32, &self.msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Option";
            match tag {
                1u32 => {
                    let mut value = &mut self.msg;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "msg"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                if self.msg != "" {
                        ::prost::encoding::string::encoded_len(1u32, &self.msg)
                    } else { 0 }
        }
        fn clear(&mut self) { self.msg.clear(); }
    }
    impl ::core::default::Default for Option {
        fn default() -> Self {
            Option { msg: ::prost::alloc::string::String::new() }
        }
    }
    impl ::core::fmt::Debug for Option {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Option");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.msg)
                        };
                    builder.field("msg", &wrapper)
                };
            ;
            builder.finish()
        }
    }
}
mod test_result_named_result_value {
    pub struct Result {
        #[prost(string, tag = "1")]
        pub msg: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Result {
        #[inline]
        fn clone(&self) -> Result {
            Result { msg: ::core::clone::Clone::clone(&self.msg) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Result { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Result {
        #[inline]
        fn eq(&self, other: &Result) -> bool { self.msg == other.msg }
    }
    impl ::prost::Message for Result {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if self.msg != "" {
                    ::prost::encoding::string::encode(1u32, &self.msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Result";
            match tag {
                1u32 => {
                    let mut value = &mut self.msg;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "msg"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                if self.msg != "" {
                        ::prost::encoding::string::encoded_len(1u32, &self.msg)
                    } else { 0 }
        }
        fn clear(&mut self) { self.msg.clear(); }
    }
    impl ::core::default::Default for Result {
        fn default() -> Self {
            Result { msg: ::prost::alloc::string::String::new() }
        }
    }
    impl ::core::fmt::Debug for Result {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Result");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.msg)
                        };
                    builder.field("msg", &wrapper)
                };
            ;
            builder.finish()
        }
    }
}
pub mod foo {
    pub mod bar_baz {
        /// Test that ident conversion works correctly on message and field names.
        pub struct FooBarBaz {
            #[prost(int32, tag = "1")]
            pub foo_bar_baz: i32,
            #[prost(message, repeated, tag = "2")]
            pub fuzz_busters: ::prost::alloc::vec::Vec<foo_bar_baz::FuzzBuster>,
            #[prost(enumeration = "foo_bar_baz::StrawberryRhubarbPie", tag =
            "3")]
            pub p_i_e: i32,
            /// Rust Keywords:
            #[prost(int32, tag = "4")]
            pub r#as: i32,
            #[prost(int32, tag = "5")]
            pub r#break: i32,
            #[prost(int32, tag = "6")]
            pub r#const: i32,
            #[prost(int32, tag = "7")]
            pub r#continue: i32,
            #[prost(int32, tag = "8")]
            pub r#else: i32,
            #[prost(int32, tag = "9")]
            pub r#enum: i32,
            #[prost(int32, tag = "10")]
            pub r#false: i32,
            #[prost(int32, tag = "11")]
            pub r#fn: i32,
            #[prost(int32, tag = "12")]
            pub r#for: i32,
            #[prost(int32, tag = "13")]
            pub r#if: i32,
            #[prost(int32, tag = "14")]
            pub r#impl: i32,
            #[prost(int32, tag = "15")]
            pub r#in: i32,
            #[prost(int32, tag = "16")]
            pub r#let: i32,
            #[prost(int32, tag = "17")]
            pub r#loop: i32,
            #[prost(int32, tag = "18")]
            pub r#match: i32,
            #[prost(int32, tag = "19")]
            pub r#mod: i32,
            #[prost(int32, tag = "20")]
            pub r#move: i32,
            #[prost(int32, tag = "21")]
            pub r#mut: i32,
            #[prost(int32, tag = "22")]
            pub r#pub: i32,
            #[prost(int32, tag = "23")]
            pub r#ref: i32,
            #[prost(int32, tag = "24")]
            pub r#return: i32,
            #[prost(int32, tag = "25")]
            pub r#static: i32,
            #[prost(int32, tag = "26")]
            pub r#struct: i32,
            #[prost(int32, tag = "27")]
            pub r#trait: i32,
            #[prost(int32, tag = "28")]
            pub r#true: i32,
            #[prost(int32, tag = "29")]
            pub r#type: i32,
            #[prost(int32, tag = "30")]
            pub r#unsafe: i32,
            #[prost(int32, tag = "31")]
            pub r#use: i32,
            #[prost(int32, tag = "32")]
            pub r#where: i32,
            #[prost(int32, tag = "33")]
            pub r#while: i32,
            #[prost(int32, tag = "34")]
            pub r#dyn: i32,
            #[prost(int32, tag = "35")]
            pub r#abstract: i32,
            #[prost(int32, tag = "36")]
            pub r#become: i32,
            #[prost(int32, tag = "37")]
            pub r#box: i32,
            #[prost(int32, tag = "38")]
            pub r#do: i32,
            #[prost(int32, tag = "39")]
            pub r#final: i32,
            #[prost(int32, tag = "40")]
            pub r#macro: i32,
            #[prost(int32, tag = "41")]
            pub r#override: i32,
            #[prost(int32, tag = "42")]
            pub r#priv: i32,
            #[prost(int32, tag = "43")]
            pub r#typeof: i32,
            #[prost(int32, tag = "44")]
            pub r#unsized: i32,
            #[prost(int32, tag = "45")]
            pub r#virtual: i32,
            #[prost(int32, tag = "46")]
            pub r#yield: i32,
            #[prost(int32, tag = "47")]
            pub r#async: i32,
            #[prost(int32, tag = "48")]
            pub r#await: i32,
            #[prost(int32, tag = "49")]
            pub r#try: i32,
            #[prost(int32, tag = "50")]
            pub self_: i32,
            #[prost(int32, tag = "51")]
            pub super_: i32,
            #[prost(int32, tag = "52")]
            pub extern_: i32,
            #[prost(int32, tag = "53")]
            pub crate_: i32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FooBarBaz {
            #[inline]
            fn clone(&self) -> FooBarBaz {
                FooBarBaz {
                    foo_bar_baz: ::core::clone::Clone::clone(&self.foo_bar_baz),
                    fuzz_busters: ::core::clone::Clone::clone(&self.fuzz_busters),
                    p_i_e: ::core::clone::Clone::clone(&self.p_i_e),
                    r#as: ::core::clone::Clone::clone(&self.r#as),
                    r#break: ::core::clone::Clone::clone(&self.r#break),
                    r#const: ::core::clone::Clone::clone(&self.r#const),
                    r#continue: ::core::clone::Clone::clone(&self.r#continue),
                    r#else: ::core::clone::Clone::clone(&self.r#else),
                    r#enum: ::core::clone::Clone::clone(&self.r#enum),
                    r#false: ::core::clone::Clone::clone(&self.r#false),
                    r#fn: ::core::clone::Clone::clone(&self.r#fn),
                    r#for: ::core::clone::Clone::clone(&self.r#for),
                    r#if: ::core::clone::Clone::clone(&self.r#if),
                    r#impl: ::core::clone::Clone::clone(&self.r#impl),
                    r#in: ::core::clone::Clone::clone(&self.r#in),
                    r#let: ::core::clone::Clone::clone(&self.r#let),
                    r#loop: ::core::clone::Clone::clone(&self.r#loop),
                    r#match: ::core::clone::Clone::clone(&self.r#match),
                    r#mod: ::core::clone::Clone::clone(&self.r#mod),
                    r#move: ::core::clone::Clone::clone(&self.r#move),
                    r#mut: ::core::clone::Clone::clone(&self.r#mut),
                    r#pub: ::core::clone::Clone::clone(&self.r#pub),
                    r#ref: ::core::clone::Clone::clone(&self.r#ref),
                    r#return: ::core::clone::Clone::clone(&self.r#return),
                    r#static: ::core::clone::Clone::clone(&self.r#static),
                    r#struct: ::core::clone::Clone::clone(&self.r#struct),
                    r#trait: ::core::clone::Clone::clone(&self.r#trait),
                    r#true: ::core::clone::Clone::clone(&self.r#true),
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                    r#unsafe: ::core::clone::Clone::clone(&self.r#unsafe),
                    r#use: ::core::clone::Clone::clone(&self.r#use),
                    r#where: ::core::clone::Clone::clone(&self.r#where),
                    r#while: ::core::clone::Clone::clone(&self.r#while),
                    r#dyn: ::core::clone::Clone::clone(&self.r#dyn),
                    r#abstract: ::core::clone::Clone::clone(&self.r#abstract),
                    r#become: ::core::clone::Clone::clone(&self.r#become),
                    r#box: ::core::clone::Clone::clone(&self.r#box),
                    r#do: ::core::clone::Clone::clone(&self.r#do),
                    r#final: ::core::clone::Clone::clone(&self.r#final),
                    r#macro: ::core::clone::Clone::clone(&self.r#macro),
                    r#override: ::core::clone::Clone::clone(&self.r#override),
                    r#priv: ::core::clone::Clone::clone(&self.r#priv),
                    r#typeof: ::core::clone::Clone::clone(&self.r#typeof),
                    r#unsized: ::core::clone::Clone::clone(&self.r#unsized),
                    r#virtual: ::core::clone::Clone::clone(&self.r#virtual),
                    r#yield: ::core::clone::Clone::clone(&self.r#yield),
                    r#async: ::core::clone::Clone::clone(&self.r#async),
                    r#await: ::core::clone::Clone::clone(&self.r#await),
                    r#try: ::core::clone::Clone::clone(&self.r#try),
                    self_: ::core::clone::Clone::clone(&self.self_),
                    super_: ::core::clone::Clone::clone(&self.super_),
                    extern_: ::core::clone::Clone::clone(&self.extern_),
                    crate_: ::core::clone::Clone::clone(&self.crate_),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FooBarBaz { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FooBarBaz {
            #[inline]
            fn eq(&self, other: &FooBarBaz) -> bool {
                self.foo_bar_baz == other.foo_bar_baz &&
                                                                                                                                                                                                                                self.fuzz_busters == other.fuzz_busters &&
                                                                                                                                                                                                                            self.p_i_e == other.p_i_e && self.r#as == other.r#as &&
                                                                                                                                                                                                                    self.r#break == other.r#break &&
                                                                                                                                                                                                                self.r#const == other.r#const &&
                                                                                                                                                                                                            self.r#continue == other.r#continue &&
                                                                                                                                                                                                        self.r#else == other.r#else && self.r#enum == other.r#enum
                                                                                                                                                                                                && self.r#false == other.r#false && self.r#fn == other.r#fn
                                                                                                                                                                                        && self.r#for == other.r#for && self.r#if == other.r#if &&
                                                                                                                                                                                self.r#impl == other.r#impl && self.r#in == other.r#in &&
                                                                                                                                                                        self.r#let == other.r#let && self.r#loop == other.r#loop &&
                                                                                                                                                                self.r#match == other.r#match && self.r#mod == other.r#mod
                                                                                                                                                        && self.r#move == other.r#move && self.r#mut == other.r#mut
                                                                                                                                                && self.r#pub == other.r#pub && self.r#ref == other.r#ref &&
                                                                                                                                        self.r#return == other.r#return &&
                                                                                                                                    self.r#static == other.r#static &&
                                                                                                                                self.r#struct == other.r#struct &&
                                                                                                                            self.r#trait == other.r#trait && self.r#true == other.r#true
                                                                                                                    && self.r#type == other.r#type &&
                                                                                                                self.r#unsafe == other.r#unsafe && self.r#use == other.r#use
                                                                                                        && self.r#where == other.r#where &&
                                                                                                    self.r#while == other.r#while && self.r#dyn == other.r#dyn
                                                                                            && self.r#abstract == other.r#abstract &&
                                                                                        self.r#become == other.r#become && self.r#box == other.r#box
                                                                                && self.r#do == other.r#do && self.r#final == other.r#final
                                                                        && self.r#macro == other.r#macro &&
                                                                    self.r#override == other.r#override &&
                                                                self.r#priv == other.r#priv &&
                                                            self.r#typeof == other.r#typeof &&
                                                        self.r#unsized == other.r#unsized &&
                                                    self.r#virtual == other.r#virtual &&
                                                self.r#yield == other.r#yield &&
                                            self.r#async == other.r#async &&
                                        self.r#await == other.r#await && self.r#try == other.r#try
                                && self.self_ == other.self_ && self.super_ == other.super_
                        && self.extern_ == other.extern_ &&
                    self.crate_ == other.crate_
            }
        }
        impl ::prost::Message for FooBarBaz {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if self.foo_bar_baz != 0i32 {
                        ::prost::encoding::int32::encode(1u32, &self.foo_bar_baz,
                            buf);
                    }
                for msg in &self.fuzz_busters {
                    ::prost::encoding::message::encode(2u32, msg, buf);
                }
                if self.p_i_e !=
                            foo_bar_baz::StrawberryRhubarbPie::default() as i32 {
                        ::prost::encoding::int32::encode(3u32, &self.p_i_e, buf);
                    }
                if self.r#as != 0i32 {
                        ::prost::encoding::int32::encode(4u32, &self.r#as, buf);
                    }
                if self.r#break != 0i32 {
                        ::prost::encoding::int32::encode(5u32, &self.r#break, buf);
                    }
                if self.r#const != 0i32 {
                        ::prost::encoding::int32::encode(6u32, &self.r#const, buf);
                    }
                if self.r#continue != 0i32 {
                        ::prost::encoding::int32::encode(7u32, &self.r#continue,
                            buf);
                    }
                if self.r#else != 0i32 {
                        ::prost::encoding::int32::encode(8u32, &self.r#else, buf);
                    }
                if self.r#enum != 0i32 {
                        ::prost::encoding::int32::encode(9u32, &self.r#enum, buf);
                    }
                if self.r#false != 0i32 {
                        ::prost::encoding::int32::encode(10u32, &self.r#false, buf);
                    }
                if self.r#fn != 0i32 {
                        ::prost::encoding::int32::encode(11u32, &self.r#fn, buf);
                    }
                if self.r#for != 0i32 {
                        ::prost::encoding::int32::encode(12u32, &self.r#for, buf);
                    }
                if self.r#if != 0i32 {
                        ::prost::encoding::int32::encode(13u32, &self.r#if, buf);
                    }
                if self.r#impl != 0i32 {
                        ::prost::encoding::int32::encode(14u32, &self.r#impl, buf);
                    }
                if self.r#in != 0i32 {
                        ::prost::encoding::int32::encode(15u32, &self.r#in, buf);
                    }
                if self.r#let != 0i32 {
                        ::prost::encoding::int32::encode(16u32, &self.r#let, buf);
                    }
                if self.r#loop != 0i32 {
                        ::prost::encoding::int32::encode(17u32, &self.r#loop, buf);
                    }
                if self.r#match != 0i32 {
                        ::prost::encoding::int32::encode(18u32, &self.r#match, buf);
                    }
                if self.r#mod != 0i32 {
                        ::prost::encoding::int32::encode(19u32, &self.r#mod, buf);
                    }
                if self.r#move != 0i32 {
                        ::prost::encoding::int32::encode(20u32, &self.r#move, buf);
                    }
                if self.r#mut != 0i32 {
                        ::prost::encoding::int32::encode(21u32, &self.r#mut, buf);
                    }
                if self.r#pub != 0i32 {
                        ::prost::encoding::int32::encode(22u32, &self.r#pub, buf);
                    }
                if self.r#ref != 0i32 {
                        ::prost::encoding::int32::encode(23u32, &self.r#ref, buf);
                    }
                if self.r#return != 0i32 {
                        ::prost::encoding::int32::encode(24u32, &self.r#return,
                            buf);
                    }
                if self.r#static != 0i32 {
                        ::prost::encoding::int32::encode(25u32, &self.r#static,
                            buf);
                    }
                if self.r#struct != 0i32 {
                        ::prost::encoding::int32::encode(26u32, &self.r#struct,
                            buf);
                    }
                if self.r#trait != 0i32 {
                        ::prost::encoding::int32::encode(27u32, &self.r#trait, buf);
                    }
                if self.r#true != 0i32 {
                        ::prost::encoding::int32::encode(28u32, &self.r#true, buf);
                    }
                if self.r#type != 0i32 {
                        ::prost::encoding::int32::encode(29u32, &self.r#type, buf);
                    }
                if self.r#unsafe != 0i32 {
                        ::prost::encoding::int32::encode(30u32, &self.r#unsafe,
                            buf);
                    }
                if self.r#use != 0i32 {
                        ::prost::encoding::int32::encode(31u32, &self.r#use, buf);
                    }
                if self.r#where != 0i32 {
                        ::prost::encoding::int32::encode(32u32, &self.r#where, buf);
                    }
                if self.r#while != 0i32 {
                        ::prost::encoding::int32::encode(33u32, &self.r#while, buf);
                    }
                if self.r#dyn != 0i32 {
                        ::prost::encoding::int32::encode(34u32, &self.r#dyn, buf);
                    }
                if self.r#abstract != 0i32 {
                        ::prost::encoding::int32::encode(35u32, &self.r#abstract,
                            buf);
                    }
                if self.r#become != 0i32 {
                        ::prost::encoding::int32::encode(36u32, &self.r#become,
                            buf);
                    }
                if self.r#box != 0i32 {
                        ::prost::encoding::int32::encode(37u32, &self.r#box, buf);
                    }
                if self.r#do != 0i32 {
                        ::prost::encoding::int32::encode(38u32, &self.r#do, buf);
                    }
                if self.r#final != 0i32 {
                        ::prost::encoding::int32::encode(39u32, &self.r#final, buf);
                    }
                if self.r#macro != 0i32 {
                        ::prost::encoding::int32::encode(40u32, &self.r#macro, buf);
                    }
                if self.r#override != 0i32 {
                        ::prost::encoding::int32::encode(41u32, &self.r#override,
                            buf);
                    }
                if self.r#priv != 0i32 {
                        ::prost::encoding::int32::encode(42u32, &self.r#priv, buf);
                    }
                if self.r#typeof != 0i32 {
                        ::prost::encoding::int32::encode(43u32, &self.r#typeof,
                            buf);
                    }
                if self.r#unsized != 0i32 {
                        ::prost::encoding::int32::encode(44u32, &self.r#unsized,
                            buf);
                    }
                if self.r#virtual != 0i32 {
                        ::prost::encoding::int32::encode(45u32, &self.r#virtual,
                            buf);
                    }
                if self.r#yield != 0i32 {
                        ::prost::encoding::int32::encode(46u32, &self.r#yield, buf);
                    }
                if self.r#async != 0i32 {
                        ::prost::encoding::int32::encode(47u32, &self.r#async, buf);
                    }
                if self.r#await != 0i32 {
                        ::prost::encoding::int32::encode(48u32, &self.r#await, buf);
                    }
                if self.r#try != 0i32 {
                        ::prost::encoding::int32::encode(49u32, &self.r#try, buf);
                    }
                if self.self_ != 0i32 {
                        ::prost::encoding::int32::encode(50u32, &self.self_, buf);
                    }
                if self.super_ != 0i32 {
                        ::prost::encoding::int32::encode(51u32, &self.super_, buf);
                    }
                if self.extern_ != 0i32 {
                        ::prost::encoding::int32::encode(52u32, &self.extern_, buf);
                    }
                if self.crate_ != 0i32 {
                        ::prost::encoding::int32::encode(53u32, &self.crate_, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "FooBarBaz";
                match tag {
                    1u32 => {
                        let mut value = &mut self.foo_bar_baz;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "foo_bar_baz"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.fuzz_busters;
                        ::prost::encoding::message::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "fuzz_busters"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.p_i_e;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "p_i_e"); error })
                    }
                    4u32 => {
                        let mut value = &mut self.r#as;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#as"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.r#break;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#break"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.r#const;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#const"); error })
                    }
                    7u32 => {
                        let mut value = &mut self.r#continue;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#continue"); error })
                    }
                    8u32 => {
                        let mut value = &mut self.r#else;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#else"); error })
                    }
                    9u32 => {
                        let mut value = &mut self.r#enum;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#enum"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.r#false;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#false"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.r#fn;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#fn"); error })
                    }
                    12u32 => {
                        let mut value = &mut self.r#for;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#for"); error })
                    }
                    13u32 => {
                        let mut value = &mut self.r#if;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#if"); error })
                    }
                    14u32 => {
                        let mut value = &mut self.r#impl;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#impl"); error })
                    }
                    15u32 => {
                        let mut value = &mut self.r#in;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#in"); error })
                    }
                    16u32 => {
                        let mut value = &mut self.r#let;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#let"); error })
                    }
                    17u32 => {
                        let mut value = &mut self.r#loop;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#loop"); error })
                    }
                    18u32 => {
                        let mut value = &mut self.r#match;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#match"); error })
                    }
                    19u32 => {
                        let mut value = &mut self.r#mod;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#mod"); error })
                    }
                    20u32 => {
                        let mut value = &mut self.r#move;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#move"); error })
                    }
                    21u32 => {
                        let mut value = &mut self.r#mut;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#mut"); error })
                    }
                    22u32 => {
                        let mut value = &mut self.r#pub;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#pub"); error })
                    }
                    23u32 => {
                        let mut value = &mut self.r#ref;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#ref"); error })
                    }
                    24u32 => {
                        let mut value = &mut self.r#return;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#return"); error })
                    }
                    25u32 => {
                        let mut value = &mut self.r#static;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#static"); error })
                    }
                    26u32 => {
                        let mut value = &mut self.r#struct;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#struct"); error })
                    }
                    27u32 => {
                        let mut value = &mut self.r#trait;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#trait"); error })
                    }
                    28u32 => {
                        let mut value = &mut self.r#true;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#true"); error })
                    }
                    29u32 => {
                        let mut value = &mut self.r#type;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#type"); error })
                    }
                    30u32 => {
                        let mut value = &mut self.r#unsafe;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#unsafe"); error })
                    }
                    31u32 => {
                        let mut value = &mut self.r#use;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#use"); error })
                    }
                    32u32 => {
                        let mut value = &mut self.r#where;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#where"); error })
                    }
                    33u32 => {
                        let mut value = &mut self.r#while;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#while"); error })
                    }
                    34u32 => {
                        let mut value = &mut self.r#dyn;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#dyn"); error })
                    }
                    35u32 => {
                        let mut value = &mut self.r#abstract;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#abstract"); error })
                    }
                    36u32 => {
                        let mut value = &mut self.r#become;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#become"); error })
                    }
                    37u32 => {
                        let mut value = &mut self.r#box;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#box"); error })
                    }
                    38u32 => {
                        let mut value = &mut self.r#do;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#do"); error })
                    }
                    39u32 => {
                        let mut value = &mut self.r#final;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#final"); error })
                    }
                    40u32 => {
                        let mut value = &mut self.r#macro;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#macro"); error })
                    }
                    41u32 => {
                        let mut value = &mut self.r#override;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#override"); error })
                    }
                    42u32 => {
                        let mut value = &mut self.r#priv;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#priv"); error })
                    }
                    43u32 => {
                        let mut value = &mut self.r#typeof;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#typeof"); error })
                    }
                    44u32 => {
                        let mut value = &mut self.r#unsized;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#unsized"); error })
                    }
                    45u32 => {
                        let mut value = &mut self.r#virtual;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#virtual"); error })
                    }
                    46u32 => {
                        let mut value = &mut self.r#yield;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#yield"); error })
                    }
                    47u32 => {
                        let mut value = &mut self.r#async;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#async"); error })
                    }
                    48u32 => {
                        let mut value = &mut self.r#await;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#await"); error })
                    }
                    49u32 => {
                        let mut value = &mut self.r#try;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "r#try"); error })
                    }
                    50u32 => {
                        let mut value = &mut self.self_;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "self_"); error })
                    }
                    51u32 => {
                        let mut value = &mut self.super_;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "super_"); error })
                    }
                    52u32 => {
                        let mut value = &mut self.extern_;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "extern_"); error })
                    }
                    53u32 => {
                        let mut value = &mut self.crate_;
                        ::prost::encoding::int32::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "crate_"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                                                                                                                                                                                                    if self.foo_bar_baz != 0i32 {
                                                                                                                                                                                                                                            ::prost::encoding::int32::encoded_len(1u32,
                                                                                                                                                                                                                                                &self.foo_bar_baz)
                                                                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                                                                ::prost::encoding::message::encoded_len_repeated(2u32,
                                                                                                                                                                                                                                    &self.fuzz_busters) +
                                                                                                                                                                                                                            if self.p_i_e !=
                                                                                                                                                                                                                                        foo_bar_baz::StrawberryRhubarbPie::default() as i32 {
                                                                                                                                                                                                                                    ::prost::encoding::int32::encoded_len(3u32, &self.p_i_e)
                                                                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                                                                        if self.r#as != 0i32 {
                                                                                                                                                                                                                                ::prost::encoding::int32::encoded_len(4u32, &self.r#as)
                                                                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                                                                    if self.r#break != 0i32 {
                                                                                                                                                                                                                            ::prost::encoding::int32::encoded_len(5u32, &self.r#break)
                                                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                                                if self.r#const != 0i32 {
                                                                                                                                                                                                                        ::prost::encoding::int32::encoded_len(6u32, &self.r#const)
                                                                                                                                                                                                                    } else { 0 } +
                                                                                                                                                                                                            if self.r#continue != 0i32 {
                                                                                                                                                                                                                    ::prost::encoding::int32::encoded_len(7u32,
                                                                                                                                                                                                                        &self.r#continue)
                                                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                                                        if self.r#else != 0i32 {
                                                                                                                                                                                                                ::prost::encoding::int32::encoded_len(8u32, &self.r#else)
                                                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                                                    if self.r#enum != 0i32 {
                                                                                                                                                                                                            ::prost::encoding::int32::encoded_len(9u32, &self.r#enum)
                                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                                if self.r#false != 0i32 {
                                                                                                                                                                                                        ::prost::encoding::int32::encoded_len(10u32, &self.r#false)
                                                                                                                                                                                                    } else { 0 } +
                                                                                                                                                                                            if self.r#fn != 0i32 {
                                                                                                                                                                                                    ::prost::encoding::int32::encoded_len(11u32, &self.r#fn)
                                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                                        if self.r#for != 0i32 {
                                                                                                                                                                                                ::prost::encoding::int32::encoded_len(12u32, &self.r#for)
                                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                                    if self.r#if != 0i32 {
                                                                                                                                                                                            ::prost::encoding::int32::encoded_len(13u32, &self.r#if)
                                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                                if self.r#impl != 0i32 {
                                                                                                                                                                                        ::prost::encoding::int32::encoded_len(14u32, &self.r#impl)
                                                                                                                                                                                    } else { 0 } +
                                                                                                                                                                            if self.r#in != 0i32 {
                                                                                                                                                                                    ::prost::encoding::int32::encoded_len(15u32, &self.r#in)
                                                                                                                                                                                } else { 0 } +
                                                                                                                                                                        if self.r#let != 0i32 {
                                                                                                                                                                                ::prost::encoding::int32::encoded_len(16u32, &self.r#let)
                                                                                                                                                                            } else { 0 } +
                                                                                                                                                                    if self.r#loop != 0i32 {
                                                                                                                                                                            ::prost::encoding::int32::encoded_len(17u32, &self.r#loop)
                                                                                                                                                                        } else { 0 } +
                                                                                                                                                                if self.r#match != 0i32 {
                                                                                                                                                                        ::prost::encoding::int32::encoded_len(18u32, &self.r#match)
                                                                                                                                                                    } else { 0 } +
                                                                                                                                                            if self.r#mod != 0i32 {
                                                                                                                                                                    ::prost::encoding::int32::encoded_len(19u32, &self.r#mod)
                                                                                                                                                                } else { 0 } +
                                                                                                                                                        if self.r#move != 0i32 {
                                                                                                                                                                ::prost::encoding::int32::encoded_len(20u32, &self.r#move)
                                                                                                                                                            } else { 0 } +
                                                                                                                                                    if self.r#mut != 0i32 {
                                                                                                                                                            ::prost::encoding::int32::encoded_len(21u32, &self.r#mut)
                                                                                                                                                        } else { 0 } +
                                                                                                                                                if self.r#pub != 0i32 {
                                                                                                                                                        ::prost::encoding::int32::encoded_len(22u32, &self.r#pub)
                                                                                                                                                    } else { 0 } +
                                                                                                                                            if self.r#ref != 0i32 {
                                                                                                                                                    ::prost::encoding::int32::encoded_len(23u32, &self.r#ref)
                                                                                                                                                } else { 0 } +
                                                                                                                                        if self.r#return != 0i32 {
                                                                                                                                                ::prost::encoding::int32::encoded_len(24u32, &self.r#return)
                                                                                                                                            } else { 0 } +
                                                                                                                                    if self.r#static != 0i32 {
                                                                                                                                            ::prost::encoding::int32::encoded_len(25u32, &self.r#static)
                                                                                                                                        } else { 0 } +
                                                                                                                                if self.r#struct != 0i32 {
                                                                                                                                        ::prost::encoding::int32::encoded_len(26u32, &self.r#struct)
                                                                                                                                    } else { 0 } +
                                                                                                                            if self.r#trait != 0i32 {
                                                                                                                                    ::prost::encoding::int32::encoded_len(27u32, &self.r#trait)
                                                                                                                                } else { 0 } +
                                                                                                                        if self.r#true != 0i32 {
                                                                                                                                ::prost::encoding::int32::encoded_len(28u32, &self.r#true)
                                                                                                                            } else { 0 } +
                                                                                                                    if self.r#type != 0i32 {
                                                                                                                            ::prost::encoding::int32::encoded_len(29u32, &self.r#type)
                                                                                                                        } else { 0 } +
                                                                                                                if self.r#unsafe != 0i32 {
                                                                                                                        ::prost::encoding::int32::encoded_len(30u32, &self.r#unsafe)
                                                                                                                    } else { 0 } +
                                                                                                            if self.r#use != 0i32 {
                                                                                                                    ::prost::encoding::int32::encoded_len(31u32, &self.r#use)
                                                                                                                } else { 0 } +
                                                                                                        if self.r#where != 0i32 {
                                                                                                                ::prost::encoding::int32::encoded_len(32u32, &self.r#where)
                                                                                                            } else { 0 } +
                                                                                                    if self.r#while != 0i32 {
                                                                                                            ::prost::encoding::int32::encoded_len(33u32, &self.r#while)
                                                                                                        } else { 0 } +
                                                                                                if self.r#dyn != 0i32 {
                                                                                                        ::prost::encoding::int32::encoded_len(34u32, &self.r#dyn)
                                                                                                    } else { 0 } +
                                                                                            if self.r#abstract != 0i32 {
                                                                                                    ::prost::encoding::int32::encoded_len(35u32,
                                                                                                        &self.r#abstract)
                                                                                                } else { 0 } +
                                                                                        if self.r#become != 0i32 {
                                                                                                ::prost::encoding::int32::encoded_len(36u32, &self.r#become)
                                                                                            } else { 0 } +
                                                                                    if self.r#box != 0i32 {
                                                                                            ::prost::encoding::int32::encoded_len(37u32, &self.r#box)
                                                                                        } else { 0 } +
                                                                                if self.r#do != 0i32 {
                                                                                        ::prost::encoding::int32::encoded_len(38u32, &self.r#do)
                                                                                    } else { 0 } +
                                                                            if self.r#final != 0i32 {
                                                                                    ::prost::encoding::int32::encoded_len(39u32, &self.r#final)
                                                                                } else { 0 } +
                                                                        if self.r#macro != 0i32 {
                                                                                ::prost::encoding::int32::encoded_len(40u32, &self.r#macro)
                                                                            } else { 0 } +
                                                                    if self.r#override != 0i32 {
                                                                            ::prost::encoding::int32::encoded_len(41u32,
                                                                                &self.r#override)
                                                                        } else { 0 } +
                                                                if self.r#priv != 0i32 {
                                                                        ::prost::encoding::int32::encoded_len(42u32, &self.r#priv)
                                                                    } else { 0 } +
                                                            if self.r#typeof != 0i32 {
                                                                    ::prost::encoding::int32::encoded_len(43u32, &self.r#typeof)
                                                                } else { 0 } +
                                                        if self.r#unsized != 0i32 {
                                                                ::prost::encoding::int32::encoded_len(44u32,
                                                                    &self.r#unsized)
                                                            } else { 0 } +
                                                    if self.r#virtual != 0i32 {
                                                            ::prost::encoding::int32::encoded_len(45u32,
                                                                &self.r#virtual)
                                                        } else { 0 } +
                                                if self.r#yield != 0i32 {
                                                        ::prost::encoding::int32::encoded_len(46u32, &self.r#yield)
                                                    } else { 0 } +
                                            if self.r#async != 0i32 {
                                                    ::prost::encoding::int32::encoded_len(47u32, &self.r#async)
                                                } else { 0 } +
                                        if self.r#await != 0i32 {
                                                ::prost::encoding::int32::encoded_len(48u32, &self.r#await)
                                            } else { 0 } +
                                    if self.r#try != 0i32 {
                                            ::prost::encoding::int32::encoded_len(49u32, &self.r#try)
                                        } else { 0 } +
                                if self.self_ != 0i32 {
                                        ::prost::encoding::int32::encoded_len(50u32, &self.self_)
                                    } else { 0 } +
                            if self.super_ != 0i32 {
                                    ::prost::encoding::int32::encoded_len(51u32, &self.super_)
                                } else { 0 } +
                        if self.extern_ != 0i32 {
                                ::prost::encoding::int32::encoded_len(52u32, &self.extern_)
                            } else { 0 } +
                    if self.crate_ != 0i32 {
                            ::prost::encoding::int32::encoded_len(53u32, &self.crate_)
                        } else { 0 }
            }
            fn clear(&mut self) {
                self.foo_bar_baz = 0i32;
                self.fuzz_busters.clear();
                self.p_i_e =
                    foo_bar_baz::StrawberryRhubarbPie::default() as i32;
                self.r#as = 0i32;
                self.r#break = 0i32;
                self.r#const = 0i32;
                self.r#continue = 0i32;
                self.r#else = 0i32;
                self.r#enum = 0i32;
                self.r#false = 0i32;
                self.r#fn = 0i32;
                self.r#for = 0i32;
                self.r#if = 0i32;
                self.r#impl = 0i32;
                self.r#in = 0i32;
                self.r#let = 0i32;
                self.r#loop = 0i32;
                self.r#match = 0i32;
                self.r#mod = 0i32;
                self.r#move = 0i32;
                self.r#mut = 0i32;
                self.r#pub = 0i32;
                self.r#ref = 0i32;
                self.r#return = 0i32;
                self.r#static = 0i32;
                self.r#struct = 0i32;
                self.r#trait = 0i32;
                self.r#true = 0i32;
                self.r#type = 0i32;
                self.r#unsafe = 0i32;
                self.r#use = 0i32;
                self.r#where = 0i32;
                self.r#while = 0i32;
                self.r#dyn = 0i32;
                self.r#abstract = 0i32;
                self.r#become = 0i32;
                self.r#box = 0i32;
                self.r#do = 0i32;
                self.r#final = 0i32;
                self.r#macro = 0i32;
                self.r#override = 0i32;
                self.r#priv = 0i32;
                self.r#typeof = 0i32;
                self.r#unsized = 0i32;
                self.r#virtual = 0i32;
                self.r#yield = 0i32;
                self.r#async = 0i32;
                self.r#await = 0i32;
                self.r#try = 0i32;
                self.self_ = 0i32;
                self.super_ = 0i32;
                self.extern_ = 0i32;
                self.crate_ = 0i32;
            }
        }
        impl ::core::default::Default for FooBarBaz {
            fn default() -> Self {
                FooBarBaz {
                    foo_bar_baz: 0i32,
                    fuzz_busters: ::core::default::Default::default(),
                    p_i_e: foo_bar_baz::StrawberryRhubarbPie::default() as i32,
                    r#as: 0i32,
                    r#break: 0i32,
                    r#const: 0i32,
                    r#continue: 0i32,
                    r#else: 0i32,
                    r#enum: 0i32,
                    r#false: 0i32,
                    r#fn: 0i32,
                    r#for: 0i32,
                    r#if: 0i32,
                    r#impl: 0i32,
                    r#in: 0i32,
                    r#let: 0i32,
                    r#loop: 0i32,
                    r#match: 0i32,
                    r#mod: 0i32,
                    r#move: 0i32,
                    r#mut: 0i32,
                    r#pub: 0i32,
                    r#ref: 0i32,
                    r#return: 0i32,
                    r#static: 0i32,
                    r#struct: 0i32,
                    r#trait: 0i32,
                    r#true: 0i32,
                    r#type: 0i32,
                    r#unsafe: 0i32,
                    r#use: 0i32,
                    r#where: 0i32,
                    r#while: 0i32,
                    r#dyn: 0i32,
                    r#abstract: 0i32,
                    r#become: 0i32,
                    r#box: 0i32,
                    r#do: 0i32,
                    r#final: 0i32,
                    r#macro: 0i32,
                    r#override: 0i32,
                    r#priv: 0i32,
                    r#typeof: 0i32,
                    r#unsized: 0i32,
                    r#virtual: 0i32,
                    r#yield: 0i32,
                    r#async: 0i32,
                    r#await: 0i32,
                    r#try: 0i32,
                    self_: 0i32,
                    super_: 0i32,
                    extern_: 0i32,
                    crate_: 0i32,
                }
            }
        }
        impl ::core::fmt::Debug for FooBarBaz {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("FooBarBaz");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.foo_bar_baz)
                            };
                        builder.field("foo_bar_baz", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper = &self.fuzz_busters;
                        builder.field("fuzz_busters", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        let res:
                                                ::core::result::Result<foo_bar_baz::StrawberryRhubarbPie,
                                                _> = ::core::convert::TryFrom::try_from(*self.0);
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&self.p_i_e)
                            };
                        builder.field("p_i_e", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#as)
                            };
                        builder.field("r#as", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#break)
                            };
                        builder.field("r#break", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#const)
                            };
                        builder.field("r#const", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#continue)
                            };
                        builder.field("r#continue", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#else)
                            };
                        builder.field("r#else", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#enum)
                            };
                        builder.field("r#enum", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#false)
                            };
                        builder.field("r#false", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#fn)
                            };
                        builder.field("r#fn", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#for)
                            };
                        builder.field("r#for", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#if)
                            };
                        builder.field("r#if", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#impl)
                            };
                        builder.field("r#impl", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#in)
                            };
                        builder.field("r#in", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#let)
                            };
                        builder.field("r#let", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#loop)
                            };
                        builder.field("r#loop", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#match)
                            };
                        builder.field("r#match", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#mod)
                            };
                        builder.field("r#mod", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#move)
                            };
                        builder.field("r#move", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#mut)
                            };
                        builder.field("r#mut", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#pub)
                            };
                        builder.field("r#pub", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#ref)
                            };
                        builder.field("r#ref", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#return)
                            };
                        builder.field("r#return", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#static)
                            };
                        builder.field("r#static", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#struct)
                            };
                        builder.field("r#struct", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#trait)
                            };
                        builder.field("r#trait", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#true)
                            };
                        builder.field("r#true", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#type)
                            };
                        builder.field("r#type", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#unsafe)
                            };
                        builder.field("r#unsafe", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#use)
                            };
                        builder.field("r#use", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#where)
                            };
                        builder.field("r#where", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#while)
                            };
                        builder.field("r#while", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#dyn)
                            };
                        builder.field("r#dyn", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#abstract)
                            };
                        builder.field("r#abstract", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#become)
                            };
                        builder.field("r#become", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#box)
                            };
                        builder.field("r#box", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#do)
                            };
                        builder.field("r#do", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#final)
                            };
                        builder.field("r#final", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#macro)
                            };
                        builder.field("r#macro", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#override)
                            };
                        builder.field("r#override", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#priv)
                            };
                        builder.field("r#priv", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#typeof)
                            };
                        builder.field("r#typeof", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#unsized)
                            };
                        builder.field("r#unsized", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#virtual)
                            };
                        builder.field("r#virtual", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#yield)
                            };
                        builder.field("r#yield", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#async)
                            };
                        builder.field("r#async", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#await)
                            };
                        builder.field("r#await", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.r#try)
                            };
                        builder.field("r#try", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.self_)
                            };
                        builder.field("self_", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.super_)
                            };
                        builder.field("super_", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.extern_)
                            };
                        builder.field("extern_", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.crate_)
                            };
                        builder.field("crate_", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl FooBarBaz {
            #[doc =
            "Returns the enum value of `p_i_e`, or the default if the field is set to an invalid enum value."]
            pub fn p_i_e(&self) -> foo_bar_baz::StrawberryRhubarbPie {
                ::core::convert::TryFrom::try_from(self.p_i_e).unwrap_or(foo_bar_baz::StrawberryRhubarbPie::default())
            }
            #[doc = "Sets `p_i_e` to the provided enum value."]
            pub fn set_p_i_e(&mut self,
                value: foo_bar_baz::StrawberryRhubarbPie) {
                self.p_i_e = value as i32;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for FooBarBaz {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<i32>;
                let _:
                        ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<foo_bar_baz::FuzzBuster>>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for FooBarBaz {
            #[inline]
            fn partial_cmp(&self, other: &FooBarBaz)
                -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.foo_bar_baz,
                        &other.foo_bar_baz) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                        =>
                        match ::core::cmp::PartialOrd::partial_cmp(&self.fuzz_busters,
                                &other.fuzz_busters) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                match ::core::cmp::PartialOrd::partial_cmp(&self.p_i_e,
                                        &other.p_i_e) {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                        =>
                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#as,
                                                &other.r#as) {
                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                =>
                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#break,
                                                        &other.r#break) {
                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                        =>
                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#const,
                                                                &other.r#const) {
                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                =>
                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#continue,
                                                                        &other.r#continue) {
                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                        =>
                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#else,
                                                                                &other.r#else) {
                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                =>
                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#enum,
                                                                                        &other.r#enum) {
                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                        =>
                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#false,
                                                                                                &other.r#false) {
                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                =>
                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#fn,
                                                                                                        &other.r#fn) {
                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                        =>
                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#for,
                                                                                                                &other.r#for) {
                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                =>
                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#if,
                                                                                                                        &other.r#if) {
                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                        =>
                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#impl,
                                                                                                                                &other.r#impl) {
                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                =>
                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#in,
                                                                                                                                        &other.r#in) {
                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                        =>
                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#let,
                                                                                                                                                &other.r#let) {
                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                =>
                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#loop,
                                                                                                                                                        &other.r#loop) {
                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                        =>
                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#match,
                                                                                                                                                                &other.r#match) {
                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                =>
                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#mod,
                                                                                                                                                                        &other.r#mod) {
                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                        =>
                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#move,
                                                                                                                                                                                &other.r#move) {
                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                =>
                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#mut,
                                                                                                                                                                                        &other.r#mut) {
                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                        =>
                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#pub,
                                                                                                                                                                                                &other.r#pub) {
                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                =>
                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#ref,
                                                                                                                                                                                                        &other.r#ref) {
                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                        =>
                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#return,
                                                                                                                                                                                                                &other.r#return) {
                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                =>
                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#static,
                                                                                                                                                                                                                        &other.r#static) {
                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#struct,
                                                                                                                                                                                                                                &other.r#struct) {
                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#trait,
                                                                                                                                                                                                                                        &other.r#trait) {
                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#true,
                                                                                                                                                                                                                                                &other.r#true) {
                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#type,
                                                                                                                                                                                                                                                        &other.r#type) {
                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#unsafe,
                                                                                                                                                                                                                                                                &other.r#unsafe) {
                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#use,
                                                                                                                                                                                                                                                                        &other.r#use) {
                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#where,
                                                                                                                                                                                                                                                                                &other.r#where) {
                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#while,
                                                                                                                                                                                                                                                                                        &other.r#while) {
                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#dyn,
                                                                                                                                                                                                                                                                                                &other.r#dyn) {
                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#abstract,
                                                                                                                                                                                                                                                                                                        &other.r#abstract) {
                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#become,
                                                                                                                                                                                                                                                                                                                &other.r#become) {
                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#box,
                                                                                                                                                                                                                                                                                                                        &other.r#box) {
                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#do,
                                                                                                                                                                                                                                                                                                                                &other.r#do) {
                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#final,
                                                                                                                                                                                                                                                                                                                                        &other.r#final) {
                                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#macro,
                                                                                                                                                                                                                                                                                                                                                &other.r#macro) {
                                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#override,
                                                                                                                                                                                                                                                                                                                                                        &other.r#override) {
                                                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#priv,
                                                                                                                                                                                                                                                                                                                                                                &other.r#priv) {
                                                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#typeof,
                                                                                                                                                                                                                                                                                                                                                                        &other.r#typeof) {
                                                                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#unsized,
                                                                                                                                                                                                                                                                                                                                                                                &other.r#unsized) {
                                                                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#virtual,
                                                                                                                                                                                                                                                                                                                                                                                        &other.r#virtual) {
                                                                                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#yield,
                                                                                                                                                                                                                                                                                                                                                                                                &other.r#yield) {
                                                                                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#async,
                                                                                                                                                                                                                                                                                                                                                                                                        &other.r#async) {
                                                                                                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.r#await,
                                                                                                                                                                                                                                                                                                                                                                                                                &other.r#await) {
                                                                                                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.r#try,
                                                                                                                                                                                                                                                                                                                                                                                                                        &other.r#try) {
                                                                                                                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.self_,
                                                                                                                                                                                                                                                                                                                                                                                                                                &other.self_) {
                                                                                                                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.super_,
                                                                                                                                                                                                                                                                                                                                                                                                                                        &other.super_) {
                                                                                                                                                                                                                                                                                                                                                                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::PartialOrd::partial_cmp(&self.extern_,
                                                                                                                                                                                                                                                                                                                                                                                                                                                &other.extern_) {
                                                                                                                                                                                                                                                                                                                                                                                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                                                                                                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                                                                                                                ::core::cmp::PartialOrd::partial_cmp(&self.crate_,
                                                                                                                                                                                                                                                                                                                                                                                                                                                    &other.crate_),
                                                                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                },
                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                        },
                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                },
                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                        },
                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                },
                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                        },
                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                },
                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                        },
                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                },
                                                                                                                                                            cmp => cmp,
                                                                                                                                                        },
                                                                                                                                                    cmp => cmp,
                                                                                                                                                },
                                                                                                                                            cmp => cmp,
                                                                                                                                        },
                                                                                                                                    cmp => cmp,
                                                                                                                                },
                                                                                                                            cmp => cmp,
                                                                                                                        },
                                                                                                                    cmp => cmp,
                                                                                                                },
                                                                                                            cmp => cmp,
                                                                                                        },
                                                                                                    cmp => cmp,
                                                                                                },
                                                                                            cmp => cmp,
                                                                                        },
                                                                                    cmp => cmp,
                                                                                },
                                                                            cmp => cmp,
                                                                        },
                                                                    cmp => cmp,
                                                                },
                                                            cmp => cmp,
                                                        },
                                                    cmp => cmp,
                                                },
                                            cmp => cmp,
                                        },
                                    cmp => cmp,
                                },
                            cmp => cmp,
                        },
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for FooBarBaz {
            #[inline]
            fn cmp(&self, other: &FooBarBaz) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.foo_bar_baz,
                        &other.foo_bar_baz) {
                    ::core::cmp::Ordering::Equal =>
                        match ::core::cmp::Ord::cmp(&self.fuzz_busters,
                                &other.fuzz_busters) {
                            ::core::cmp::Ordering::Equal =>
                                match ::core::cmp::Ord::cmp(&self.p_i_e, &other.p_i_e) {
                                    ::core::cmp::Ordering::Equal =>
                                        match ::core::cmp::Ord::cmp(&self.r#as, &other.r#as) {
                                            ::core::cmp::Ordering::Equal =>
                                                match ::core::cmp::Ord::cmp(&self.r#break, &other.r#break) {
                                                    ::core::cmp::Ordering::Equal =>
                                                        match ::core::cmp::Ord::cmp(&self.r#const, &other.r#const) {
                                                            ::core::cmp::Ordering::Equal =>
                                                                match ::core::cmp::Ord::cmp(&self.r#continue,
                                                                        &other.r#continue) {
                                                                    ::core::cmp::Ordering::Equal =>
                                                                        match ::core::cmp::Ord::cmp(&self.r#else, &other.r#else) {
                                                                            ::core::cmp::Ordering::Equal =>
                                                                                match ::core::cmp::Ord::cmp(&self.r#enum, &other.r#enum) {
                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                        match ::core::cmp::Ord::cmp(&self.r#false, &other.r#false) {
                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                match ::core::cmp::Ord::cmp(&self.r#fn, &other.r#fn) {
                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                        match ::core::cmp::Ord::cmp(&self.r#for, &other.r#for) {
                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                match ::core::cmp::Ord::cmp(&self.r#if, &other.r#if) {
                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#impl, &other.r#impl) {
                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#in, &other.r#in) {
                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#let, &other.r#let) {
                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#loop, &other.r#loop) {
                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#match, &other.r#match) {
                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#mod, &other.r#mod) {
                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#move, &other.r#move) {
                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#mut, &other.r#mut) {
                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#pub, &other.r#pub) {
                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#ref, &other.r#ref) {
                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#return, &other.r#return)
                                                                                                                                                                                                            {
                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#static, &other.r#static)
                                                                                                                                                                                                                    {
                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#struct, &other.r#struct)
                                                                                                                                                                                                                            {
                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#trait, &other.r#trait) {
                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#true, &other.r#true) {
                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#type, &other.r#type) {
                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#unsafe, &other.r#unsafe)
                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#use, &other.r#use) {
                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#where, &other.r#where) {
                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#while, &other.r#while) {
                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#dyn, &other.r#dyn) {
                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#abstract,
                                                                                                                                                                                                                                                                                                        &other.r#abstract) {
                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#become, &other.r#become)
                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#box, &other.r#box) {
                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#do, &other.r#do) {
                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#final, &other.r#final) {
                                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#macro, &other.r#macro) {
                                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#override,
                                                                                                                                                                                                                                                                                                                                                        &other.r#override) {
                                                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#priv, &other.r#priv) {
                                                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#typeof, &other.r#typeof)
                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#unsized,
                                                                                                                                                                                                                                                                                                                                                                                &other.r#unsized) {
                                                                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#virtual,
                                                                                                                                                                                                                                                                                                                                                                                        &other.r#virtual) {
                                                                                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#yield, &other.r#yield) {
                                                                                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#async, &other.r#async) {
                                                                                                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.r#await, &other.r#await) {
                                                                                                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.r#try, &other.r#try) {
                                                                                                                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.self_, &other.self_) {
                                                                                                                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                                                                match ::core::cmp::Ord::cmp(&self.super_, &other.super_) {
                                                                                                                                                                                                                                                                                                                                                                                                                                    ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                                                                        match ::core::cmp::Ord::cmp(&self.extern_, &other.extern_) {
                                                                                                                                                                                                                                                                                                                                                                                                                                            ::core::cmp::Ordering::Equal =>
                                                                                                                                                                                                                                                                                                                                                                                                                                                ::core::cmp::Ord::cmp(&self.crate_, &other.crate_),
                                                                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                                },
                                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                                        },
                                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                                },
                                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                                        },
                                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                                },
                                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                                        },
                                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                                },
                                                                                                                                                                            cmp => cmp,
                                                                                                                                                                        },
                                                                                                                                                                    cmp => cmp,
                                                                                                                                                                },
                                                                                                                                                            cmp => cmp,
                                                                                                                                                        },
                                                                                                                                                    cmp => cmp,
                                                                                                                                                },
                                                                                                                                            cmp => cmp,
                                                                                                                                        },
                                                                                                                                    cmp => cmp,
                                                                                                                                },
                                                                                                                            cmp => cmp,
                                                                                                                        },
                                                                                                                    cmp => cmp,
                                                                                                                },
                                                                                                            cmp => cmp,
                                                                                                        },
                                                                                                    cmp => cmp,
                                                                                                },
                                                                                            cmp => cmp,
                                                                                        },
                                                                                    cmp => cmp,
                                                                                },
                                                                            cmp => cmp,
                                                                        },
                                                                    cmp => cmp,
                                                                },
                                                            cmp => cmp,
                                                        },
                                                    cmp => cmp,
                                                },
                                            cmp => cmp,
                                        },
                                    cmp => cmp,
                                },
                            cmp => cmp,
                        },
                    cmp => cmp,
                }
            }
        }
        /// Nested message and enum types in `Foo_barBaz`.
        pub mod foo_bar_baz {
            pub struct Self_ {}
            #[automatically_derived]
            impl ::core::clone::Clone for Self_ {
                #[inline]
                fn clone(&self) -> Self_ { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Self_ { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Self_ { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Self_ {
                #[inline]
                fn eq(&self, other: &Self_) -> bool { true }
            }
            impl ::prost::Message for Self_ {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Self_ {
                fn default() -> Self { Self_ {} }
            }
            impl ::core::fmt::Debug for Self_ {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Self_");
                    builder.finish()
                }
            }
            pub struct FuzzBuster {
                #[prost(btree_map = "int32, message", tag = "1")]
                pub t: ::prost::alloc::collections::BTreeMap<i32,
                super::FooBarBaz>,
                #[prost(message, optional, boxed, tag = "2")]
                pub nested_self: ::core::option::Option<::prost::alloc::boxed::Box<FuzzBuster>>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for FuzzBuster {
                #[inline]
                fn clone(&self) -> FuzzBuster {
                    FuzzBuster {
                        t: ::core::clone::Clone::clone(&self.t),
                        nested_self: ::core::clone::Clone::clone(&self.nested_self),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for FuzzBuster { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for FuzzBuster {
                #[inline]
                fn eq(&self, other: &FuzzBuster) -> bool {
                    self.t == other.t && self.nested_self == other.nested_self
                }
            }
            impl ::prost::Message for FuzzBuster {
                #[allow(unused_variables)]
                fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    ::prost::encoding::btree_map::encode(::prost::encoding::int32::encode,
                        ::prost::encoding::int32::encoded_len,
                        ::prost::encoding::message::encode,
                        ::prost::encoding::message::encoded_len, 1u32, &self.t,
                        buf);
                    if let Some(ref msg) = self.nested_self {
                            ::prost::encoding::message::encode(2u32, msg, buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field(&mut self, tag: u32,
                    wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    const STRUCT_NAME: &'static str = "FuzzBuster";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.t;
                            ::prost::encoding::btree_map::merge(::prost::encoding::int32::merge,
                                    ::prost::encoding::message::merge, &mut value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "t"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.nested_self;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "nested_self"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                            ::prost::encoding::btree_map::encoded_len(::prost::encoding::int32::encoded_len,
                                ::prost::encoding::message::encoded_len, 1u32, &self.t) +
                        self.nested_self.as_ref().map_or(0,
                            |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                }
                fn clear(&mut self) {
                    self.t.clear();
                    self.nested_self = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for FuzzBuster {
                fn default() -> Self {
                    FuzzBuster {
                        t: ::core::default::Default::default(),
                        nested_self: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for FuzzBuster {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("FuzzBuster");
                    let builder =
                        {
                            let wrapper =
                                {
                                    struct MapWrapper<'a,
                                        V: 'a>(&'a ::prost::alloc::collections::BTreeMap<i32, V>);
                                    impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                        V: ::core::fmt::Debug + 'a {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            #[allow(non_snake_case)]
                                            fn KeyWrapper<T>(v: T) -> T { v }
                                            #[allow(non_snake_case)]
                                            fn ValueWrapper<T>(v: T) -> T { v }
                                            let mut builder = f.debug_map();
                                            for (k, v) in self.0 {
                                                builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                            }
                                            builder.finish()
                                        }
                                    }
                                    MapWrapper(&self.t)
                                };
                            builder.field("t", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.nested_self;
                            builder.field("nested_self", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for FuzzBuster {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _:
                            ::core::cmp::AssertParamIsEq<::prost::alloc::collections::BTreeMap<i32,
                            super::FooBarBaz>>;
                    let _:
                            ::core::cmp::AssertParamIsEq<::core::option::Option<::prost::alloc::boxed::Box<FuzzBuster>>>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for FuzzBuster {
                #[inline]
                fn partial_cmp(&self, other: &FuzzBuster)
                    -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.t,
                            &other.t) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            ::core::cmp::PartialOrd::partial_cmp(&self.nested_self,
                                &other.nested_self),
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for FuzzBuster {
                #[inline]
                fn cmp(&self, other: &FuzzBuster) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.t, &other.t) {
                        ::core::cmp::Ordering::Equal =>
                            ::core::cmp::Ord::cmp(&self.nested_self,
                                &other.nested_self),
                        cmp => cmp,
                    }
                }
            }
            #[repr(i32)]
            pub enum StrawberryRhubarbPie {
                Foo = 0,
                Bar = 1,
                FooBar = 2,
                FuzzBuster = 3,
                NormalRustEnumCase = 4,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for StrawberryRhubarbPie {
                #[inline]
                fn clone(&self) -> StrawberryRhubarbPie { *self }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for StrawberryRhubarbPie { }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrawberryRhubarbPie {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f,
                        match self {
                            StrawberryRhubarbPie::Foo => "Foo",
                            StrawberryRhubarbPie::Bar => "Bar",
                            StrawberryRhubarbPie::FooBar => "FooBar",
                            StrawberryRhubarbPie::FuzzBuster => "FuzzBuster",
                            StrawberryRhubarbPie::NormalRustEnumCase =>
                                "NormalRustEnumCase",
                        })
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StrawberryRhubarbPie
                {
            }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for StrawberryRhubarbPie {
                #[inline]
                fn eq(&self, other: &StrawberryRhubarbPie) -> bool {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for StrawberryRhubarbPie {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for StrawberryRhubarbPie {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H)
                    -> () {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_discr, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for StrawberryRhubarbPie {
                #[inline]
                fn partial_cmp(&self, other: &StrawberryRhubarbPie)
                    -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                        &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for StrawberryRhubarbPie {
                #[inline]
                fn cmp(&self, other: &StrawberryRhubarbPie)
                    -> ::core::cmp::Ordering {
                    let __self_discr =
                        ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr =
                        ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl StrawberryRhubarbPie {
                #[doc =
                "Returns `true` if `value` is a variant of `StrawberryRhubarbPie`."]
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        4 => true,
                        _ => false,
                    }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                #[doc =
                "Converts an `i32` to a `StrawberryRhubarbPie`, or `None` if `value` is not a valid variant."]
                pub fn from_i32(value: i32)
                    -> ::core::option::Option<StrawberryRhubarbPie> {
                    match value {
                        0 =>
                            ::core::option::Option::Some(StrawberryRhubarbPie::Foo),
                        1 =>
                            ::core::option::Option::Some(StrawberryRhubarbPie::Bar),
                        2 =>
                            ::core::option::Option::Some(StrawberryRhubarbPie::FooBar),
                        3 =>
                            ::core::option::Option::Some(StrawberryRhubarbPie::FuzzBuster),
                        4 =>
                            ::core::option::Option::Some(StrawberryRhubarbPie::NormalRustEnumCase),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for StrawberryRhubarbPie {
                fn default() -> StrawberryRhubarbPie {
                    StrawberryRhubarbPie::Foo
                }
            }
            impl ::core::convert::From<StrawberryRhubarbPie> for i32 {
                fn from(value: StrawberryRhubarbPie) -> i32 { value as i32 }
            }
            impl ::core::convert::TryFrom<i32> for StrawberryRhubarbPie {
                type Error = ::prost::UnknownEnumValue;
                fn try_from(value: i32)
                    ->
                        ::core::result::Result<StrawberryRhubarbPie,
                        ::prost::UnknownEnumValue> {
                    match value {
                        0 => ::core::result::Result::Ok(StrawberryRhubarbPie::Foo),
                        1 => ::core::result::Result::Ok(StrawberryRhubarbPie::Bar),
                        2 =>
                            ::core::result::Result::Ok(StrawberryRhubarbPie::FooBar),
                        3 =>
                            ::core::result::Result::Ok(StrawberryRhubarbPie::FuzzBuster),
                        4 =>
                            ::core::result::Result::Ok(StrawberryRhubarbPie::NormalRustEnumCase),
                        _ =>
                            ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
                    }
                }
            }
            impl StrawberryRhubarbPie {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Foo => "foo",
                        Self::Bar => "BAR",
                        Self::FooBar => "foo_bar",
                        Self::FuzzBuster => "fuzzBUSTER",
                        Self::NormalRustEnumCase => "NormalRustEnumCase",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str)
                    -> ::core::option::Option<Self> {
                    match value {
                        "foo" => Some(Self::Foo),
                        "BAR" => Some(Self::Bar),
                        "foo_bar" => Some(Self::FooBar),
                        "fuzzBUSTER" => Some(Self::FuzzBuster),
                        "NormalRustEnumCase" => Some(Self::NormalRustEnumCase),
                        _ => None,
                    }
                }
            }
        }
    }
}
pub mod nesting {
    pub struct A {
        #[prost(message, optional, boxed, tag = "1")]
        pub a: ::core::option::Option<::prost::alloc::boxed::Box<A>>,
        #[prost(message, repeated, tag = "2")]
        pub repeated_a: ::prost::alloc::vec::Vec<A>,
        #[prost(btree_map = "int32, message", tag = "3")]
        pub map_a: ::prost::alloc::collections::BTreeMap<i32, A>,
        #[prost(message, optional, boxed, tag = "4")]
        pub b: ::core::option::Option<::prost::alloc::boxed::Box<B>>,
        #[prost(message, repeated, tag = "5")]
        pub repeated_b: ::prost::alloc::vec::Vec<B>,
        #[prost(btree_map = "int32, message", tag = "6")]
        pub map_b: ::prost::alloc::collections::BTreeMap<i32, B>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for A {
        #[inline]
        fn clone(&self) -> A {
            A {
                a: ::core::clone::Clone::clone(&self.a),
                repeated_a: ::core::clone::Clone::clone(&self.repeated_a),
                map_a: ::core::clone::Clone::clone(&self.map_a),
                b: ::core::clone::Clone::clone(&self.b),
                repeated_b: ::core::clone::Clone::clone(&self.repeated_b),
                map_b: ::core::clone::Clone::clone(&self.map_b),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for A { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for A {
        #[inline]
        fn eq(&self, other: &A) -> bool {
            self.a == other.a && self.repeated_a == other.repeated_a &&
                            self.map_a == other.map_a && self.b == other.b &&
                    self.repeated_b == other.repeated_b &&
                self.map_b == other.map_b
        }
    }
    impl ::prost::Message for A {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.a {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
            for msg in &self.repeated_a {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            ::prost::encoding::btree_map::encode(::prost::encoding::int32::encode,
                ::prost::encoding::int32::encoded_len,
                ::prost::encoding::message::encode,
                ::prost::encoding::message::encoded_len, 3u32, &self.map_a,
                buf);
            if let Some(ref msg) = self.b {
                    ::prost::encoding::message::encode(4u32, msg, buf);
                }
            for msg in &self.repeated_b {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            ::prost::encoding::btree_map::encode(::prost::encoding::int32::encode,
                ::prost::encoding::int32::encoded_len,
                ::prost::encoding::message::encode,
                ::prost::encoding::message::encoded_len, 6u32, &self.map_b,
                buf);
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "A";
            match tag {
                1u32 => {
                    let mut value = &mut self.a;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "a"); error })
                }
                2u32 => {
                    let mut value = &mut self.repeated_a;
                    ::prost::encoding::message::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_a"); error })
                }
                3u32 => {
                    let mut value = &mut self.map_a;
                    ::prost::encoding::btree_map::merge(::prost::encoding::int32::merge,
                            ::prost::encoding::message::merge, &mut value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "map_a"); error })
                }
                4u32 => {
                    let mut value = &mut self.b;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "b"); error })
                }
                5u32 => {
                    let mut value = &mut self.repeated_b;
                    ::prost::encoding::message::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeated_b"); error })
                }
                6u32 => {
                    let mut value = &mut self.map_b;
                    ::prost::encoding::btree_map::merge(::prost::encoding::int32::merge,
                            ::prost::encoding::message::merge, &mut value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "map_b"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                                    self.a.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                ::prost::encoding::message::encoded_len_repeated(2u32,
                                    &self.repeated_a) +
                            ::prost::encoding::btree_map::encoded_len(::prost::encoding::int32::encoded_len,
                                ::prost::encoding::message::encoded_len, 3u32, &self.map_a)
                        +
                        self.b.as_ref().map_or(0,
                            |msg| ::prost::encoding::message::encoded_len(4u32, msg)) +
                    ::prost::encoding::message::encoded_len_repeated(5u32,
                        &self.repeated_b) +
                ::prost::encoding::btree_map::encoded_len(::prost::encoding::int32::encoded_len,
                    ::prost::encoding::message::encoded_len, 6u32, &self.map_b)
        }
        fn clear(&mut self) {
            self.a = ::core::option::Option::None;
            self.repeated_a.clear();
            self.map_a.clear();
            self.b = ::core::option::Option::None;
            self.repeated_b.clear();
            self.map_b.clear();
        }
    }
    impl ::core::default::Default for A {
        fn default() -> Self {
            A {
                a: ::core::default::Default::default(),
                repeated_a: ::core::default::Default::default(),
                map_a: ::core::default::Default::default(),
                b: ::core::default::Default::default(),
                repeated_b: ::core::default::Default::default(),
                map_b: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for A {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("A");
            let builder =
                { let wrapper = &self.a; builder.field("a", &wrapper) };
            ;
            let builder =
                {
                    let wrapper = &self.repeated_a;
                    builder.field("repeated_a", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct MapWrapper<'a,
                                V: 'a>(&'a ::prost::alloc::collections::BTreeMap<i32, V>);
                            impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                V: ::core::fmt::Debug + 'a {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn KeyWrapper<T>(v: T) -> T { v }
                                    #[allow(non_snake_case)]
                                    fn ValueWrapper<T>(v: T) -> T { v }
                                    let mut builder = f.debug_map();
                                    for (k, v) in self.0 {
                                        builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                    }
                                    builder.finish()
                                }
                            }
                            MapWrapper(&self.map_a)
                        };
                    builder.field("map_a", &wrapper)
                };
            ;
            let builder =
                { let wrapper = &self.b; builder.field("b", &wrapper) };
            ;
            let builder =
                {
                    let wrapper = &self.repeated_b;
                    builder.field("repeated_b", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct MapWrapper<'a,
                                V: 'a>(&'a ::prost::alloc::collections::BTreeMap<i32, V>);
                            impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                V: ::core::fmt::Debug + 'a {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn KeyWrapper<T>(v: T) -> T { v }
                                    #[allow(non_snake_case)]
                                    fn ValueWrapper<T>(v: T) -> T { v }
                                    let mut builder = f.debug_map();
                                    for (k, v) in self.0 {
                                        builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                    }
                                    builder.finish()
                                }
                            }
                            MapWrapper(&self.map_b)
                        };
                    builder.field("map_b", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    pub struct B {
        #[prost(message, optional, boxed, tag = "1")]
        pub a: ::core::option::Option<::prost::alloc::boxed::Box<A>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for B {
        #[inline]
        fn clone(&self) -> B { B { a: ::core::clone::Clone::clone(&self.a) } }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for B { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for B {
        #[inline]
        fn eq(&self, other: &B) -> bool { self.a == other.a }
    }
    impl ::prost::Message for B {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.a {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "B";
            match tag {
                1u32 => {
                    let mut value = &mut self.a;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "a"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.a.as_ref().map_or(0,
                    |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) { self.a = ::core::option::Option::None; }
    }
    impl ::core::default::Default for B {
        fn default() -> Self { B { a: ::core::default::Default::default() } }
    }
    impl ::core::fmt::Debug for B {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("B");
            let builder =
                { let wrapper = &self.a; builder.field("a", &wrapper) };
            ;
            builder.finish()
        }
    }
    pub struct C {
        #[prost(message, repeated, tag = "1")]
        pub r: ::prost::alloc::vec::Vec<C>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for C {
        #[inline]
        fn clone(&self) -> C { C { r: ::core::clone::Clone::clone(&self.r) } }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for C { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for C {
        #[inline]
        fn eq(&self, other: &C) -> bool { self.r == other.r }
    }
    impl ::prost::Message for C {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            for msg in &self.r {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "C";
            match tag {
                1u32 => {
                    let mut value = &mut self.r;
                    ::prost::encoding::message::merge_repeated(wire_type, value,
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "r"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                ::prost::encoding::message::encoded_len_repeated(1u32,
                    &self.r)
        }
        fn clear(&mut self) { self.r.clear(); }
    }
    impl ::core::default::Default for C {
        fn default() -> Self { C { r: ::core::default::Default::default() } }
    }
    impl ::core::fmt::Debug for C {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("C");
            let builder =
                { let wrapper = &self.r; builder.field("r", &wrapper) };
            ;
            builder.finish()
        }
    }
    pub struct D {
        #[prost(btree_map = "string, message", tag = "1")]
        pub m: ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
        D>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for D {
        #[inline]
        fn clone(&self) -> D { D { m: ::core::clone::Clone::clone(&self.m) } }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for D { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for D {
        #[inline]
        fn eq(&self, other: &D) -> bool { self.m == other.m }
    }
    impl ::prost::Message for D {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            ::prost::encoding::btree_map::encode(::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                ::prost::encoding::message::encode,
                ::prost::encoding::message::encoded_len, 1u32, &self.m, buf);
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "D";
            match tag {
                1u32 => {
                    let mut value = &mut self.m;
                    ::prost::encoding::btree_map::merge(::prost::encoding::string::merge,
                            ::prost::encoding::message::merge, &mut value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "m"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                ::prost::encoding::btree_map::encoded_len(::prost::encoding::string::encoded_len,
                    ::prost::encoding::message::encoded_len, 1u32, &self.m)
        }
        fn clear(&mut self) { self.m.clear(); }
    }
    impl ::core::default::Default for D {
        fn default() -> Self { D { m: ::core::default::Default::default() } }
    }
    impl ::core::fmt::Debug for D {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("D");
            let builder =
                {
                    let wrapper =
                        {
                            struct MapWrapper<'a,
                                V: 'a>(&'a ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String,
                                V>);
                            impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V> where
                                V: ::core::fmt::Debug + 'a {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn KeyWrapper<T>(v: T) -> T { v }
                                    #[allow(non_snake_case)]
                                    fn ValueWrapper<T>(v: T) -> T { v }
                                    let mut builder = f.debug_map();
                                    for (k, v) in self.0 {
                                        builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                                    }
                                    builder.finish()
                                }
                            }
                            MapWrapper(&self.m)
                        };
                    builder.field("m", &wrapper)
                };
            ;
            builder.finish()
        }
    }
}
pub mod recursive_oneof {
    pub struct A {
        #[prost(oneof = "a::Kind", tags = "1, 2, 3")]
        pub kind: ::core::option::Option<a::Kind>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for A {
        #[inline]
        fn clone(&self) -> A {
            A { kind: ::core::clone::Clone::clone(&self.kind) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for A { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for A {
        #[inline]
        fn eq(&self, other: &A) -> bool { self.kind == other.kind }
    }
    impl ::prost::Message for A {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref oneof) = self.kind { oneof.encode(buf) }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "A";
            match tag {
                1u32 | 2u32 | 3u32 => {
                    let mut value = &mut self.kind;
                    a::Kind::merge(value, tag, wire_type, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "kind"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.kind.as_ref().map_or(0, a::Kind::encoded_len)
        }
        fn clear(&mut self) { self.kind = ::core::option::Option::None; }
    }
    impl ::core::default::Default for A {
        fn default() -> Self {
            A { kind: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for A {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("A");
            let builder =
                { let wrapper = &self.kind; builder.field("kind", &wrapper) };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `A`.
    pub mod a {
        pub enum Kind {

            #[prost(message, tag = "1")]
            A(::prost::alloc::boxed::Box<super::A>),

            #[prost(message, tag = "2")]
            B(::prost::alloc::boxed::Box<super::B>),

            #[prost(message, tag = "3")]
            C(super::C),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Kind {
            #[inline]
            fn clone(&self) -> Kind {
                match self {
                    Kind::A(__self_0) =>
                        Kind::A(::core::clone::Clone::clone(__self_0)),
                    Kind::B(__self_0) =>
                        Kind::B(::core::clone::Clone::clone(__self_0)),
                    Kind::C(__self_0) =>
                        Kind::C(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Kind { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Kind {
            #[inline]
            fn eq(&self, other: &Kind) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (Kind::A(__self_0), Kind::A(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (Kind::B(__self_0), Kind::B(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (Kind::C(__self_0), Kind::C(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl Kind {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    Kind::A(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Kind::B(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Kind::C(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field: &mut ::core::option::Option<Kind>, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(Kind::A(ref mut value)) => {
                                ::prost::encoding::message::merge(wire_type, value, buf,
                                    ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field = ::core::option::Option::Some(Kind::A(owned_value)))
                            }
                        }
                    }
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(Kind::B(ref mut value)) => {
                                ::prost::encoding::message::merge(wire_type, value, buf,
                                    ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field = ::core::option::Option::Some(Kind::B(owned_value)))
                            }
                        }
                    }
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(Kind::C(ref mut value)) => {
                                ::prost::encoding::message::merge(wire_type, value, buf,
                                    ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field = ::core::option::Option::Some(Kind::C(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid Kind tag: {0}", tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Kind::A(ref value) =>
                        ::prost::encoding::message::encoded_len(1u32, &*value),
                    Kind::B(ref value) =>
                        ::prost::encoding::message::encoded_len(2u32, &*value),
                    Kind::C(ref value) =>
                        ::prost::encoding::message::encoded_len(3u32, &*value),
                }
            }
        }
        impl ::core::fmt::Debug for Kind {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match *self {
                    Kind::A(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("A").field(&wrapper).finish()
                    }
                    Kind::B(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("B").field(&wrapper).finish()
                    }
                    Kind::C(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("C").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    pub struct B {
        #[prost(message, optional, boxed, tag = "1")]
        pub a: ::core::option::Option<::prost::alloc::boxed::Box<A>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for B {
        #[inline]
        fn clone(&self) -> B { B { a: ::core::clone::Clone::clone(&self.a) } }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for B { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for B {
        #[inline]
        fn eq(&self, other: &B) -> bool { self.a == other.a }
    }
    impl ::prost::Message for B {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.a {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "B";
            match tag {
                1u32 => {
                    let mut value = &mut self.a;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "a"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.a.as_ref().map_or(0,
                    |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) { self.a = ::core::option::Option::None; }
    }
    impl ::core::default::Default for B {
        fn default() -> Self { B { a: ::core::default::Default::default() } }
    }
    impl ::core::fmt::Debug for B {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("B");
            let builder =
                { let wrapper = &self.a; builder.field("a", &wrapper) };
            ;
            builder.finish()
        }
    }
    pub struct C {}
    #[automatically_derived]
    impl ::core::clone::Clone for C {
        #[inline]
        fn clone(&self) -> C { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for C { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for C { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for C {
        #[inline]
        fn eq(&self, other: &C) -> bool { true }
    }
    impl ::prost::Message for C {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for C {
        fn default() -> Self { C {} }
    }
    impl ::core::fmt::Debug for C {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("C");
            builder.finish()
        }
    }
}
/// This tests the custom attributes support by abusing docs.
///
/// Docs really are full-blown attributes. So we use them to ensure we can place them on everything
/// we need. If they aren't put onto something or allowed not to be there (by the generator),
/// compilation fails.
#[deny(missing_docs)]
pub mod custom_attributes {
    #[allow(missing_docs)]
    pub struct Msg {}
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::clone::Clone for Msg {
        #[inline]
        fn clone(&self) -> Msg { *self }
    }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::marker::Copy for Msg { }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::marker::StructuralPartialEq for Msg { }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::cmp::PartialEq for Msg {
        #[inline]
        fn eq(&self, other: &Msg) -> bool { true }
    }
    impl ::prost::Message for Msg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {}
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            match tag {
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize { 0 }
        fn clear(&mut self) {}
    }
    impl ::core::default::Default for Msg {
        fn default() -> Self { Msg {} }
    }
    impl ::core::fmt::Debug for Msg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Msg");
            builder.finish()
        }
    }
    #[allow(missing_docs)]
    #[repr(i32)]
    pub enum AnEnum { A = 0, B = 1, }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::clone::Clone for AnEnum {
        #[inline]
        fn clone(&self) -> AnEnum { *self }
    }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::marker::Copy for AnEnum { }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::fmt::Debug for AnEnum {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self { AnEnum::A => "A", AnEnum::B => "B", })
        }
    }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::marker::StructuralPartialEq for AnEnum { }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::cmp::PartialEq for AnEnum {
        #[inline]
        fn eq(&self, other: &AnEnum) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::cmp::Eq for AnEnum {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::hash::Hash for AnEnum {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::cmp::PartialOrd for AnEnum {
        #[inline]
        fn partial_cmp(&self, other: &AnEnum)
            -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    #[allow(missing_docs)]
    impl ::core::cmp::Ord for AnEnum {
        #[inline]
        fn cmp(&self, other: &AnEnum) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl AnEnum {
        #[doc = "Returns `true` if `value` is a variant of `AnEnum`."]
        pub fn is_valid(value: i32) -> bool {
            match value { 0 => true, 1 => true, _ => false, }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `AnEnum`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32) -> ::core::option::Option<AnEnum> {
            match value {
                0 => ::core::option::Option::Some(AnEnum::A),
                1 => ::core::option::Option::Some(AnEnum::B),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for AnEnum {
        fn default() -> AnEnum { AnEnum::A }
    }
    impl ::core::convert::From<AnEnum> for i32 {
        fn from(value: AnEnum) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for AnEnum {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            -> ::core::result::Result<AnEnum, ::prost::UnknownEnumValue> {
            match value {
                0 => ::core::result::Result::Ok(AnEnum::A),
                1 => ::core::result::Result::Ok(AnEnum::B),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl AnEnum {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self { Self::A => "A", Self::B => "B", }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "A" => Some(Self::A),
                "B" => Some(Self::B),
                _ => None,
            }
        }
    }
    /// Oneof docs
    #[repr(i32)]
    pub enum AnotherEnum {

        /// The C docs
        C = 0,

        /// The D docs
        D = 2,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnotherEnum {
        #[inline]
        fn clone(&self) -> AnotherEnum { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AnotherEnum { }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnotherEnum {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self { AnotherEnum::C => "C", AnotherEnum::D => "D", })
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnotherEnum { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnotherEnum {
        #[inline]
        fn eq(&self, other: &AnotherEnum) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for AnotherEnum {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for AnotherEnum {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for AnotherEnum {
        #[inline]
        fn partial_cmp(&self, other: &AnotherEnum)
            -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for AnotherEnum {
        #[inline]
        fn cmp(&self, other: &AnotherEnum) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl AnotherEnum {
        #[doc = "Returns `true` if `value` is a variant of `AnotherEnum`."]
        pub fn is_valid(value: i32) -> bool {
            match value { 0 => true, 2 => true, _ => false, }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `AnotherEnum`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32) -> ::core::option::Option<AnotherEnum> {
            match value {
                0 => ::core::option::Option::Some(AnotherEnum::C),
                2 => ::core::option::Option::Some(AnotherEnum::D),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for AnotherEnum {
        fn default() -> AnotherEnum { AnotherEnum::C }
    }
    impl ::core::convert::From<AnotherEnum> for i32 {
        fn from(value: AnotherEnum) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for AnotherEnum {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            ->
                ::core::result::Result<AnotherEnum,
                ::prost::UnknownEnumValue> {
            match value {
                0 => ::core::result::Result::Ok(AnotherEnum::C),
                2 => ::core::result::Result::Ok(AnotherEnum::D),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl AnotherEnum {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self { Self::C => "C", Self::D => "D", }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "C" => Some(Self::C),
                "D" => Some(Self::D),
                _ => None,
            }
        }
    }
}
/// Also for testing custom attributes, but on oneofs.
///
/// Unfortunately, an OneOf field generates a companion module in the .rs file. There's no
/// reasonable way to place a doc comment on that, so we do the test with `derive(Ord)` and have it
/// in a separate file.
pub mod oneof_attributes {
    pub struct Msg {
        #[prost(oneof = "msg::Field", tags = "1, 2")]
        pub field: ::core::option::Option<msg::Field>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Msg {
        #[inline]
        fn clone(&self) -> Msg {
            Msg { field: ::core::clone::Clone::clone(&self.field) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Msg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Msg {
        #[inline]
        fn eq(&self, other: &Msg) -> bool { self.field == other.field }
    }
    impl ::prost::Message for Msg {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref oneof) = self.field { oneof.encode(buf) }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Msg";
            match tag {
                1u32 | 2u32 => {
                    let mut value = &mut self.field;
                    msg::Field::merge(value, tag, wire_type, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.field.as_ref().map_or(0, msg::Field::encoded_len)
        }
        fn clear(&mut self) { self.field = ::core::option::Option::None; }
    }
    impl ::core::default::Default for Msg {
        fn default() -> Self {
            Msg { field: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for Msg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Msg");
            let builder =
                {
                    let wrapper = &self.field;
                    builder.field("field", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `Msg`.
    pub mod msg {
        pub enum Field {

            #[prost(string, tag = "1")]
            A(::prost::alloc::string::String),

            #[prost(bytes, tag = "2")]
            B(::prost::alloc::vec::Vec<u8>),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Field {
            #[inline]
            fn clone(&self) -> Field {
                match self {
                    Field::A(__self_0) =>
                        Field::A(::core::clone::Clone::clone(__self_0)),
                    Field::B(__self_0) =>
                        Field::B(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Field { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Field {
            #[inline]
            fn eq(&self, other: &Field) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (Field::A(__self_0), Field::A(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (Field::B(__self_0), Field::B(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl Field {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    Field::A(ref value) => {
                        ::prost::encoding::string::encode(1u32, &*value, buf);
                    }
                    Field::B(ref value) => {
                        ::prost::encoding::bytes::encode(2u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field: &mut ::core::option::Option<Field>, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(Field::A(ref mut value)) => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(Field::A(owned_value)))
                            }
                        }
                    }
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(Field::B(ref mut value)) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(Field::B(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid Field tag: {0}", tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Field::A(ref value) =>
                        ::prost::encoding::string::encoded_len(1u32, &*value),
                    Field::B(ref value) =>
                        ::prost::encoding::bytes::encoded_len(2u32, &*value),
                }
            }
        }
        impl ::core::fmt::Debug for Field {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match *self {
                    Field::A(ref value) => {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&*value)
                            };
                        f.debug_tuple("A").field(&wrapper).finish()
                    }
                    Field::B(ref value) => {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&*value)
                            };
                        f.debug_tuple("B").field(&wrapper).finish()
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Field {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _:
                        ::core::cmp::AssertParamIsEq<::prost::alloc::string::String>;
                let _:
                        ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Field {
            #[inline]
            fn partial_cmp(&self, other: &Field)
                -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (Field::A(__self_0), Field::A(__arg1_0)) =>
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (Field::B(__self_0), Field::B(__arg1_0)) =>
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ =>
                        ::core::cmp::PartialOrd::partial_cmp(&__self_discr,
                            &__arg1_discr),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Field {
            #[inline]
            fn cmp(&self, other: &Field) -> ::core::cmp::Ordering {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                    ::core::cmp::Ordering::Equal =>
                        match (self, other) {
                            (Field::A(__self_0), Field::A(__arg1_0)) =>
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Field::B(__self_0), Field::B(__arg1_0)) =>
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        },
                    cmp => cmp,
                }
            }
        }
    }
}
/// Issue <https://github.com/tokio-rs/prost/issues/118>
///
/// When a message contains an enum field with a default value, we
/// must ensure that the appropriate name conventions are used.
pub mod default_enum_value {
    pub struct Test {
        #[prost(enumeration = "PrivacyLevel", optional, tag = "1", default =
        "One")]
        pub privacy_level_1: ::core::option::Option<i32>,
        #[prost(enumeration = "PrivacyLevel", optional, tag = "2", default =
        "PrivacyLevelThree")]
        pub privacy_level_3: ::core::option::Option<i32>,
        #[prost(enumeration = "PrivacyLevel", optional, tag = "3", default =
        "PrivacyLevelprivacyLevelFour")]
        pub privacy_level_4: ::core::option::Option<i32>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Test {
        #[inline]
        fn clone(&self) -> Test {
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<i32>>;
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<i32>>;
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<i32>>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Test { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Test { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Test {
        #[inline]
        fn eq(&self, other: &Test) -> bool {
            self.privacy_level_1 == other.privacy_level_1 &&
                    self.privacy_level_3 == other.privacy_level_3 &&
                self.privacy_level_4 == other.privacy_level_4
        }
    }
    impl ::prost::Message for Test {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let ::core::option::Option::Some(ref value) =
                        self.privacy_level_1 {
                    ::prost::encoding::int32::encode(1u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.privacy_level_3 {
                    ::prost::encoding::int32::encode(2u32, value, buf);
                }
            if let ::core::option::Option::Some(ref value) =
                        self.privacy_level_4 {
                    ::prost::encoding::int32::encode(3u32, value, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Test";
            match tag {
                1u32 => {
                    let mut value = &mut self.privacy_level_1;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "privacy_level_1"); error })
                }
                2u32 => {
                    let mut value = &mut self.privacy_level_3;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "privacy_level_3"); error })
                }
                3u32 => {
                    let mut value = &mut self.privacy_level_4;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "privacy_level_4"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                        self.privacy_level_1.as_ref().map_or(0,
                            |value| ::prost::encoding::int32::encoded_len(1u32, value))
                    +
                    self.privacy_level_3.as_ref().map_or(0,
                        |value| ::prost::encoding::int32::encoded_len(2u32, value))
                +
                self.privacy_level_4.as_ref().map_or(0,
                    |value| ::prost::encoding::int32::encoded_len(3u32, value))
        }
        fn clear(&mut self) {
            self.privacy_level_1 = ::core::option::Option::None;
            self.privacy_level_3 = ::core::option::Option::None;
            self.privacy_level_4 = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Test {
        fn default() -> Self {
            Test {
                privacy_level_1: ::core::option::Option::None,
                privacy_level_3: ::core::option::Option::None,
                privacy_level_4: ::core::option::Option::None,
            }
        }
    }
    impl ::core::fmt::Debug for Test {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Test");
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    struct Inner<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for Inner<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            let res: ::core::result::Result<PrivacyLevel, _> =
                                                ::core::convert::TryFrom::try_from(*self.0);
                                            match res {
                                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.privacy_level_1)
                        };
                    builder.field("privacy_level_1", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    struct Inner<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for Inner<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            let res: ::core::result::Result<PrivacyLevel, _> =
                                                ::core::convert::TryFrom::try_from(*self.0);
                                            match res {
                                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.privacy_level_3)
                        };
                    builder.field("privacy_level_3", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    struct Inner<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for Inner<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            let res: ::core::result::Result<PrivacyLevel, _> =
                                                ::core::convert::TryFrom::try_from(*self.0);
                                            match res {
                                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.privacy_level_4)
                        };
                    builder.field("privacy_level_4", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl Test {
        #[doc =
        "Returns the enum value of `privacy_level_1`, or the default if the field is unset or set to an invalid enum value."]
        pub fn privacy_level_1(&self) -> PrivacyLevel {
            self.privacy_level_1.and_then(|value|
                        {
                            let result: ::core::result::Result<PrivacyLevel, _> =
                                ::core::convert::TryFrom::try_from(value);
                            result.ok()
                        }).unwrap_or(PrivacyLevel::One)
        }
        #[doc = "Sets `privacy_level_1` to the provided enum value."]
        pub fn set_privacy_level_1(&mut self, value: PrivacyLevel) {
            self.privacy_level_1 = ::core::option::Option::Some(value as i32);
        }
        #[doc =
        "Returns the enum value of `privacy_level_3`, or the default if the field is unset or set to an invalid enum value."]
        pub fn privacy_level_3(&self) -> PrivacyLevel {
            self.privacy_level_3.and_then(|value|
                        {
                            let result: ::core::result::Result<PrivacyLevel, _> =
                                ::core::convert::TryFrom::try_from(value);
                            result.ok()
                        }).unwrap_or(PrivacyLevel::PrivacyLevelThree)
        }
        #[doc = "Sets `privacy_level_3` to the provided enum value."]
        pub fn set_privacy_level_3(&mut self, value: PrivacyLevel) {
            self.privacy_level_3 = ::core::option::Option::Some(value as i32);
        }
        #[doc =
        "Returns the enum value of `privacy_level_4`, or the default if the field is unset or set to an invalid enum value."]
        pub fn privacy_level_4(&self) -> PrivacyLevel {
            self.privacy_level_4.and_then(|value|
                        {
                            let result: ::core::result::Result<PrivacyLevel, _> =
                                ::core::convert::TryFrom::try_from(value);
                            result.ok()
                        }).unwrap_or(PrivacyLevel::PrivacyLevelprivacyLevelFour)
        }
        #[doc = "Sets `privacy_level_4` to the provided enum value."]
        pub fn set_privacy_level_4(&mut self, value: PrivacyLevel) {
            self.privacy_level_4 = ::core::option::Option::Some(value as i32);
        }
    }
    pub struct CMsgRemoteClientBroadcastHeader {
        #[prost(enumeration = "ERemoteClientBroadcastMsg", optional, tag =
        "2", default = "KERemoteClientBroadcastMsgDiscovery")]
        pub msg_type: ::core::option::Option<i32>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CMsgRemoteClientBroadcastHeader {
        #[inline]
        fn clone(&self) -> CMsgRemoteClientBroadcastHeader {
            let _:
                    ::core::clone::AssertParamIsClone<::core::option::Option<i32>>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CMsgRemoteClientBroadcastHeader { }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for
        CMsgRemoteClientBroadcastHeader {
    }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CMsgRemoteClientBroadcastHeader {
        #[inline]
        fn eq(&self, other: &CMsgRemoteClientBroadcastHeader) -> bool {
            self.msg_type == other.msg_type
        }
    }
    impl ::prost::Message for CMsgRemoteClientBroadcastHeader {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let ::core::option::Option::Some(ref value) = self.msg_type {
                    ::prost::encoding::int32::encode(2u32, value, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str =
                "CMsgRemoteClientBroadcastHeader";
            match tag {
                2u32 => {
                    let mut value = &mut self.msg_type;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "msg_type"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.msg_type.as_ref().map_or(0,
                    |value| ::prost::encoding::int32::encoded_len(2u32, value))
        }
        fn clear(&mut self) { self.msg_type = ::core::option::Option::None; }
    }
    impl ::core::default::Default for CMsgRemoteClientBroadcastHeader {
        fn default() -> Self {
            CMsgRemoteClientBroadcastHeader {
                msg_type: ::core::option::Option::None,
            }
        }
    }
    impl ::core::fmt::Debug for CMsgRemoteClientBroadcastHeader {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder =
                f.debug_struct("CMsgRemoteClientBroadcastHeader");
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    struct Inner<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for Inner<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            let res:
                                                    ::core::result::Result<ERemoteClientBroadcastMsg, _> =
                                                ::core::convert::TryFrom::try_from(*self.0);
                                            match res {
                                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.msg_type)
                        };
                    builder.field("msg_type", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl CMsgRemoteClientBroadcastHeader {
        #[doc =
        "Returns the enum value of `msg_type`, or the default if the field is unset or set to an invalid enum value."]
        pub fn msg_type(&self) -> ERemoteClientBroadcastMsg {
            self.msg_type.and_then(|value|
                        {
                            let result:
                                    ::core::result::Result<ERemoteClientBroadcastMsg, _> =
                                ::core::convert::TryFrom::try_from(value);
                            result.ok()
                        }).unwrap_or(ERemoteClientBroadcastMsg::KERemoteClientBroadcastMsgDiscovery)
        }
        #[doc = "Sets `msg_type` to the provided enum value."]
        pub fn set_msg_type(&mut self, value: ERemoteClientBroadcastMsg) {
            self.msg_type = ::core::option::Option::Some(value as i32);
        }
    }
    #[repr(i32)]
    pub enum PrivacyLevel {
        One = 1,
        Two = 2,
        PrivacyLevelThree = 3,
        PrivacyLevelprivacyLevelFour = 4,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PrivacyLevel {
        #[inline]
        fn clone(&self) -> PrivacyLevel { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PrivacyLevel { }
    #[automatically_derived]
    impl ::core::fmt::Debug for PrivacyLevel {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self {
                    PrivacyLevel::One => "One",
                    PrivacyLevel::Two => "Two",
                    PrivacyLevel::PrivacyLevelThree => "PrivacyLevelThree",
                    PrivacyLevel::PrivacyLevelprivacyLevelFour =>
                        "PrivacyLevelprivacyLevelFour",
                })
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PrivacyLevel { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PrivacyLevel {
        #[inline]
        fn eq(&self, other: &PrivacyLevel) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for PrivacyLevel {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for PrivacyLevel {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for PrivacyLevel {
        #[inline]
        fn partial_cmp(&self, other: &PrivacyLevel)
            -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for PrivacyLevel {
        #[inline]
        fn cmp(&self, other: &PrivacyLevel) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl PrivacyLevel {
        #[doc = "Returns `true` if `value` is a variant of `PrivacyLevel`."]
        pub fn is_valid(value: i32) -> bool {
            match value {
                1 => true,
                2 => true,
                3 => true,
                4 => true,
                _ => false,
            }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `PrivacyLevel`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32) -> ::core::option::Option<PrivacyLevel> {
            match value {
                1 => ::core::option::Option::Some(PrivacyLevel::One),
                2 => ::core::option::Option::Some(PrivacyLevel::Two),
                3 =>
                    ::core::option::Option::Some(PrivacyLevel::PrivacyLevelThree),
                4 =>
                    ::core::option::Option::Some(PrivacyLevel::PrivacyLevelprivacyLevelFour),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for PrivacyLevel {
        fn default() -> PrivacyLevel { PrivacyLevel::One }
    }
    impl ::core::convert::From<PrivacyLevel> for i32 {
        fn from(value: PrivacyLevel) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for PrivacyLevel {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            ->
                ::core::result::Result<PrivacyLevel,
                ::prost::UnknownEnumValue> {
            match value {
                1 => ::core::result::Result::Ok(PrivacyLevel::One),
                2 => ::core::result::Result::Ok(PrivacyLevel::Two),
                3 =>
                    ::core::result::Result::Ok(PrivacyLevel::PrivacyLevelThree),
                4 =>
                    ::core::result::Result::Ok(PrivacyLevel::PrivacyLevelprivacyLevelFour),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl PrivacyLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::One => "PRIVACY_LEVEL_ONE",
                Self::Two => "PRIVACY_LEVEL_TWO",
                Self::PrivacyLevelThree =>
                    "PRIVACY_LEVEL_PRIVACY_LEVEL_THREE",
                Self::PrivacyLevelprivacyLevelFour =>
                    "PRIVACY_LEVELPRIVACY_LEVEL_FOUR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIVACY_LEVEL_ONE" => Some(Self::One),
                "PRIVACY_LEVEL_TWO" => Some(Self::Two),
                "PRIVACY_LEVEL_PRIVACY_LEVEL_THREE" =>
                    Some(Self::PrivacyLevelThree),
                "PRIVACY_LEVELPRIVACY_LEVEL_FOUR" =>
                    Some(Self::PrivacyLevelprivacyLevelFour),
                _ => None,
            }
        }
    }
    /// tokio-rs/prost#310
    #[repr(i32)]
    pub enum ERemoteClientBroadcastMsg {
        KERemoteClientBroadcastMsgDiscovery = 0,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ERemoteClientBroadcastMsg {
        #[inline]
        fn clone(&self) -> ERemoteClientBroadcastMsg { *self }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ERemoteClientBroadcastMsg { }
    #[automatically_derived]
    impl ::core::fmt::Debug for ERemoteClientBroadcastMsg {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                "KERemoteClientBroadcastMsgDiscovery")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ERemoteClientBroadcastMsg { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ERemoteClientBroadcastMsg {
        #[inline]
        fn eq(&self, other: &ERemoteClientBroadcastMsg) -> bool { true }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ERemoteClientBroadcastMsg {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ERemoteClientBroadcastMsg {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ERemoteClientBroadcastMsg {
        #[inline]
        fn partial_cmp(&self, other: &ERemoteClientBroadcastMsg)
            -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ERemoteClientBroadcastMsg {
        #[inline]
        fn cmp(&self, other: &ERemoteClientBroadcastMsg)
            -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    impl ERemoteClientBroadcastMsg {
        #[doc =
        "Returns `true` if `value` is a variant of `ERemoteClientBroadcastMsg`."]
        pub fn is_valid(value: i32) -> bool {
            match value { 0 => true, _ => false, }
        }
        #[deprecated = "Use the TryFrom<i32> implementation instead"]
        #[doc =
        "Converts an `i32` to a `ERemoteClientBroadcastMsg`, or `None` if `value` is not a valid variant."]
        pub fn from_i32(value: i32)
            -> ::core::option::Option<ERemoteClientBroadcastMsg> {
            match value {
                0 =>
                    ::core::option::Option::Some(ERemoteClientBroadcastMsg::KERemoteClientBroadcastMsgDiscovery),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for ERemoteClientBroadcastMsg {
        fn default() -> ERemoteClientBroadcastMsg {
            ERemoteClientBroadcastMsg::KERemoteClientBroadcastMsgDiscovery
        }
    }
    impl ::core::convert::From<ERemoteClientBroadcastMsg> for i32 {
        fn from(value: ERemoteClientBroadcastMsg) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom<i32> for ERemoteClientBroadcastMsg {
        type Error = ::prost::UnknownEnumValue;
        fn try_from(value: i32)
            ->
                ::core::result::Result<ERemoteClientBroadcastMsg,
                ::prost::UnknownEnumValue> {
            match value {
                0 =>
                    ::core::result::Result::Ok(ERemoteClientBroadcastMsg::KERemoteClientBroadcastMsgDiscovery),
                _ =>
                    ::core::result::Result::Err(::prost::UnknownEnumValue(value)),
            }
        }
    }
    impl ERemoteClientBroadcastMsg {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::KERemoteClientBroadcastMsgDiscovery => {
                    "k_ERemoteClientBroadcastMsgDiscovery"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "k_ERemoteClientBroadcastMsgDiscovery" => {
                    Some(Self::KERemoteClientBroadcastMsgDiscovery)
                }
                _ => None,
            }
        }
    }
}
pub mod groups {
    pub struct Test1 {
        #[prost(group, optional, tag = "1")]
        pub groupa: ::core::option::Option<test1::GroupA>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Test1 {
        #[inline]
        fn clone(&self) -> Test1 {
            Test1 { groupa: ::core::clone::Clone::clone(&self.groupa) }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Test1 { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Test1 {
        #[inline]
        fn eq(&self, other: &Test1) -> bool { self.groupa == other.groupa }
    }
    impl ::prost::Message for Test1 {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.groupa {
                    ::prost::encoding::group::encode(1u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Test1";
            match tag {
                1u32 => {
                    let mut value = &mut self.groupa;
                    ::prost::encoding::group::merge(tag, wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "groupa"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.groupa.as_ref().map_or(0,
                    |msg| ::prost::encoding::group::encoded_len(1u32, msg))
        }
        fn clear(&mut self) { self.groupa = ::core::option::Option::None; }
    }
    impl ::core::default::Default for Test1 {
        fn default() -> Self {
            Test1 { groupa: ::core::default::Default::default() }
        }
    }
    impl ::core::fmt::Debug for Test1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Test1");
            let builder =
                {
                    let wrapper = &self.groupa;
                    builder.field("groupa", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `Test1`.
    pub mod test1 {
        pub struct GroupA {
            #[prost(int32, optional, tag = "2")]
            pub i2: ::core::option::Option<i32>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GroupA {
            #[inline]
            fn clone(&self) -> GroupA {
                let _:
                        ::core::clone::AssertParamIsClone<::core::option::Option<i32>>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for GroupA { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GroupA { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GroupA {
            #[inline]
            fn eq(&self, other: &GroupA) -> bool { self.i2 == other.i2 }
        }
        impl ::prost::Message for GroupA {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let ::core::option::Option::Some(ref value) = self.i2 {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "GroupA";
                match tag {
                    2u32 => {
                        let mut value = &mut self.i2;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "i2"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.i2.as_ref().map_or(0,
                        |value| ::prost::encoding::int32::encoded_len(2u32, value))
            }
            fn clear(&mut self) { self.i2 = ::core::option::Option::None; }
        }
        impl ::core::default::Default for GroupA {
            fn default() -> Self {
                GroupA { i2: ::core::option::Option::None }
            }
        }
        impl ::core::fmt::Debug for GroupA {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("GroupA");
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.i2)
                            };
                        builder.field("i2", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl GroupA {
            #[doc =
            "Returns the value of `i2`, or the default value if `i2` is unset."]
            pub fn i2(&self) -> i32 {
                match self.i2 {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
        }
    }
    pub struct Test2 {
        #[prost(int32, optional, tag = "4")]
        pub i14: ::core::option::Option<i32>,
        #[prost(group, repeated, tag = "5")]
        pub groupb: ::prost::alloc::vec::Vec<test2::GroupB>,
        #[prost(int32, optional, tag = "7")]
        pub i17: ::core::option::Option<i32>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Test2 {
        #[inline]
        fn clone(&self) -> Test2 {
            Test2 {
                i14: ::core::clone::Clone::clone(&self.i14),
                groupb: ::core::clone::Clone::clone(&self.groupb),
                i17: ::core::clone::Clone::clone(&self.i17),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Test2 { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Test2 {
        #[inline]
        fn eq(&self, other: &Test2) -> bool {
            self.i14 == other.i14 && self.groupb == other.groupb &&
                self.i17 == other.i17
        }
    }
    impl ::prost::Message for Test2 {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let ::core::option::Option::Some(ref value) = self.i14 {
                    ::prost::encoding::int32::encode(4u32, value, buf);
                }
            for msg in &self.groupb {
                ::prost::encoding::group::encode(5u32, msg, buf);
            }
            if let ::core::option::Option::Some(ref value) = self.i17 {
                    ::prost::encoding::int32::encode(7u32, value, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Test2";
            match tag {
                4u32 => {
                    let mut value = &mut self.i14;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "i14"); error })
                }
                5u32 => {
                    let mut value = &mut self.groupb;
                    ::prost::encoding::group::merge_repeated(tag, wire_type,
                            value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "groupb"); error })
                }
                7u32 => {
                    let mut value = &mut self.i17;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "i17"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                        self.i14.as_ref().map_or(0,
                            |value| ::prost::encoding::int32::encoded_len(4u32, value))
                    +
                    ::prost::encoding::group::encoded_len_repeated(5u32,
                        &self.groupb) +
                self.i17.as_ref().map_or(0,
                    |value| ::prost::encoding::int32::encoded_len(7u32, value))
        }
        fn clear(&mut self) {
            self.i14 = ::core::option::Option::None;
            self.groupb.clear();
            self.i17 = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Test2 {
        fn default() -> Self {
            Test2 {
                i14: ::core::option::Option::None,
                groupb: ::core::default::Default::default(),
                i17: ::core::option::Option::None,
            }
        }
    }
    impl ::core::fmt::Debug for Test2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Test2");
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.i14)
                        };
                    builder.field("i14", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper = &self.groupb;
                    builder.field("groupb", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.i17)
                        };
                    builder.field("i17", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl Test2 {
        #[doc =
        "Returns the value of `i14`, or the default value if `i14` is unset."]
        pub fn i14(&self) -> i32 {
            match self.i14 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i32,
            }
        }
        #[doc =
        "Returns the value of `i17`, or the default value if `i17` is unset."]
        pub fn i17(&self) -> i32 {
            match self.i17 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i32,
            }
        }
    }
    /// Nested message and enum types in `Test2`.
    pub mod test2 {
        pub struct GroupB {
            #[prost(int32, optional, tag = "6")]
            pub i16: ::core::option::Option<i32>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GroupB {
            #[inline]
            fn clone(&self) -> GroupB {
                let _:
                        ::core::clone::AssertParamIsClone<::core::option::Option<i32>>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for GroupB { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GroupB { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GroupB {
            #[inline]
            fn eq(&self, other: &GroupB) -> bool { self.i16 == other.i16 }
        }
        impl ::prost::Message for GroupB {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let ::core::option::Option::Some(ref value) = self.i16 {
                        ::prost::encoding::int32::encode(6u32, value, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "GroupB";
                match tag {
                    6u32 => {
                        let mut value = &mut self.i16;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "i16"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.i16.as_ref().map_or(0,
                        |value| ::prost::encoding::int32::encoded_len(6u32, value))
            }
            fn clear(&mut self) { self.i16 = ::core::option::Option::None; }
        }
        impl ::core::default::Default for GroupB {
            fn default() -> Self {
                GroupB { i16: ::core::option::Option::None }
            }
        }
        impl ::core::fmt::Debug for GroupB {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("GroupB");
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.i16)
                            };
                        builder.field("i16", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl GroupB {
            #[doc =
            "Returns the value of `i16`, or the default value if `i16` is unset."]
            pub fn i16(&self) -> i32 {
                match self.i16 {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
        }
    }
    pub struct OneofGroup {
        #[prost(int32, optional, tag = "1")]
        pub i1: ::core::option::Option<i32>,
        #[prost(oneof = "oneof_group::Field", tags = "2, 3")]
        pub field: ::core::option::Option<oneof_group::Field>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OneofGroup {
        #[inline]
        fn clone(&self) -> OneofGroup {
            OneofGroup {
                i1: ::core::clone::Clone::clone(&self.i1),
                field: ::core::clone::Clone::clone(&self.field),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OneofGroup { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OneofGroup {
        #[inline]
        fn eq(&self, other: &OneofGroup) -> bool {
            self.i1 == other.i1 && self.field == other.field
        }
    }
    impl ::prost::Message for OneofGroup {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let ::core::option::Option::Some(ref value) = self.i1 {
                    ::prost::encoding::int32::encode(1u32, value, buf);
                }
            if let Some(ref oneof) = self.field { oneof.encode(buf) }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "OneofGroup";
            match tag {
                1u32 => {
                    let mut value = &mut self.i1;
                    ::prost::encoding::int32::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "i1"); error })
                }
                2u32 | 3u32 => {
                    let mut value = &mut self.field;
                    oneof_group::Field::merge(value, tag, wire_type, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "field"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                    self.i1.as_ref().map_or(0,
                        |value| ::prost::encoding::int32::encoded_len(1u32, value))
                +
                self.field.as_ref().map_or(0, oneof_group::Field::encoded_len)
        }
        fn clear(&mut self) {
            self.i1 = ::core::option::Option::None;
            self.field = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for OneofGroup {
        fn default() -> Self {
            OneofGroup {
                i1: ::core::option::Option::None,
                field: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for OneofGroup {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("OneofGroup");
            let builder =
                {
                    let wrapper =
                        {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                    -> ::core::fmt::Result {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T { v }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.i1)
                        };
                    builder.field("i1", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper = &self.field;
                    builder.field("field", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl OneofGroup {
        #[doc =
        "Returns the value of `i1`, or the default value if `i1` is unset."]
        pub fn i1(&self) -> i32 {
            match self.i1 {
                ::core::option::Option::Some(val) => val,
                ::core::option::Option::None => 0i32,
            }
        }
    }
    /// Nested message and enum types in `OneofGroup`.
    pub mod oneof_group {
        pub struct G {
            #[prost(int32, optional, tag = "1")]
            pub i2: ::core::option::Option<i32>,
            #[prost(string, required, tag = "2")]
            pub s1: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub t1: ::core::option::Option<super::Test1>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for G {
            #[inline]
            fn clone(&self) -> G {
                G {
                    i2: ::core::clone::Clone::clone(&self.i2),
                    s1: ::core::clone::Clone::clone(&self.s1),
                    t1: ::core::clone::Clone::clone(&self.t1),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for G { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for G {
            #[inline]
            fn eq(&self, other: &G) -> bool {
                self.i2 == other.i2 && self.s1 == other.s1 &&
                    self.t1 == other.t1
            }
        }
        impl ::prost::Message for G {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let ::core::option::Option::Some(ref value) = self.i2 {
                        ::prost::encoding::int32::encode(1u32, value, buf);
                    }
                ::prost::encoding::string::encode(2u32, &self.s1, buf);
                if let Some(ref msg) = self.t1 {
                        ::prost::encoding::message::encode(3u32, msg, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "G";
                match tag {
                    1u32 => {
                        let mut value = &mut self.i2;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "i2"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.s1;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "s1"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.t1;
                        ::prost::encoding::message::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "t1"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                            self.i2.as_ref().map_or(0,
                                |value| ::prost::encoding::int32::encoded_len(1u32, value))
                        + ::prost::encoding::string::encoded_len(2u32, &self.s1) +
                    self.t1.as_ref().map_or(0,
                        |msg| ::prost::encoding::message::encoded_len(3u32, msg))
            }
            fn clear(&mut self) {
                self.i2 = ::core::option::Option::None;
                self.s1.clear();
                self.t1 = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for G {
            fn default() -> Self {
                G {
                    i2: ::core::option::Option::None,
                    s1: ::prost::alloc::string::String::new(),
                    t1: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for G {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("G");
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.i2)
                            };
                        builder.field("i2", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.s1)
                            };
                        builder.field("s1", &wrapper)
                    };
                ;
                let builder =
                    { let wrapper = &self.t1; builder.field("t1", &wrapper) };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl G {
            #[doc =
            "Returns the value of `i2`, or the default value if `i2` is unset."]
            pub fn i2(&self) -> i32 {
                match self.i2 {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
        }
        pub enum Field {

            #[prost(group, tag = "2")]
            G(G),

            #[prost(string, tag = "3")]
            S2(::prost::alloc::string::String),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Field {
            #[inline]
            fn clone(&self) -> Field {
                match self {
                    Field::G(__self_0) =>
                        Field::G(::core::clone::Clone::clone(__self_0)),
                    Field::S2(__self_0) =>
                        Field::S2(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Field { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Field {
            #[inline]
            fn eq(&self, other: &Field) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr &&
                    match (self, other) {
                        (Field::G(__self_0), Field::G(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        (Field::S2(__self_0), Field::S2(__arg1_0)) =>
                            __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl Field {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    Field::G(ref value) => {
                        ::prost::encoding::group::encode(2u32, &*value, buf);
                    }
                    Field::S2(ref value) => {
                        ::prost::encoding::string::encode(3u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field: &mut ::core::option::Option<Field>, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(Field::G(ref mut value)) => {
                                ::prost::encoding::group::merge(tag, wire_type, value, buf,
                                    ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::group::merge(tag, wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(Field::G(owned_value)))
                            }
                        }
                    }
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(Field::S2(ref mut value)) => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map(|_|
                                        *field =
                                            ::core::option::Option::Some(Field::S2(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid Field tag: {0}", tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Field::G(ref value) =>
                        ::prost::encoding::group::encoded_len(2u32, &*value),
                    Field::S2(ref value) =>
                        ::prost::encoding::string::encoded_len(3u32, &*value),
                }
            }
        }
        impl ::core::fmt::Debug for Field {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match *self {
                    Field::G(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("G").field(&wrapper).finish()
                    }
                    Field::S2(ref value) => {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&*value)
                            };
                        f.debug_tuple("S2").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    pub struct NestedGroup {
        #[prost(group, optional, boxed, tag = "1")]
        pub optionalgroup: ::core::option::Option<::prost::alloc::boxed::Box<nested_group::OptionalGroup>>,
        #[prost(group, required, boxed, tag = "2")]
        pub requiredgroup: ::prost::alloc::boxed::Box<nested_group::RequiredGroup>,
        #[prost(group, repeated, tag = "3")]
        pub repeatedgroup: ::prost::alloc::vec::Vec<nested_group::RepeatedGroup>,
        #[prost(oneof = "nested_group::O", tags = "4")]
        pub o: ::core::option::Option<nested_group::O>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NestedGroup {
        #[inline]
        fn clone(&self) -> NestedGroup {
            NestedGroup {
                optionalgroup: ::core::clone::Clone::clone(&self.optionalgroup),
                requiredgroup: ::core::clone::Clone::clone(&self.requiredgroup),
                repeatedgroup: ::core::clone::Clone::clone(&self.repeatedgroup),
                o: ::core::clone::Clone::clone(&self.o),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NestedGroup { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NestedGroup {
        #[inline]
        fn eq(&self, other: &NestedGroup) -> bool {
            self.optionalgroup == other.optionalgroup &&
                        self.requiredgroup == other.requiredgroup &&
                    self.repeatedgroup == other.repeatedgroup &&
                self.o == other.o
        }
    }
    impl ::prost::Message for NestedGroup {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.optionalgroup {
                    ::prost::encoding::group::encode(1u32, msg, buf);
                }
            ::prost::encoding::group::encode(2u32, &self.requiredgroup, buf);
            for msg in &self.repeatedgroup {
                ::prost::encoding::group::encode(3u32, msg, buf);
            }
            if let Some(ref oneof) = self.o { oneof.encode(buf) }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "NestedGroup";
            match tag {
                1u32 => {
                    let mut value = &mut self.optionalgroup;
                    ::prost::encoding::group::merge(tag, wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optionalgroup"); error })
                }
                2u32 => {
                    let mut value = &mut self.requiredgroup;
                    ::prost::encoding::group::merge(tag, wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "requiredgroup"); error })
                }
                3u32 => {
                    let mut value = &mut self.repeatedgroup;
                    ::prost::encoding::group::merge_repeated(tag, wire_type,
                            value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "repeatedgroup"); error })
                }
                4u32 => {
                    let mut value = &mut self.o;
                    nested_group::O::merge(value, tag, wire_type, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "o"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                            self.optionalgroup.as_ref().map_or(0,
                                |msg| ::prost::encoding::group::encoded_len(1u32, msg)) +
                        ::prost::encoding::group::encoded_len(2u32,
                            &self.requiredgroup) +
                    ::prost::encoding::group::encoded_len_repeated(3u32,
                        &self.repeatedgroup) +
                self.o.as_ref().map_or(0, nested_group::O::encoded_len)
        }
        fn clear(&mut self) {
            self.optionalgroup = ::core::option::Option::None;
            self.requiredgroup.clear();
            self.repeatedgroup.clear();
            self.o = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for NestedGroup {
        fn default() -> Self {
            NestedGroup {
                optionalgroup: ::core::default::Default::default(),
                requiredgroup: ::core::default::Default::default(),
                repeatedgroup: ::core::default::Default::default(),
                o: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for NestedGroup {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NestedGroup");
            let builder =
                {
                    let wrapper = &self.optionalgroup;
                    builder.field("optionalgroup", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper = &self.requiredgroup;
                    builder.field("requiredgroup", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper = &self.repeatedgroup;
                    builder.field("repeatedgroup", &wrapper)
                };
            ;
            let builder =
                { let wrapper = &self.o; builder.field("o", &wrapper) };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `NestedGroup`.
    pub mod nested_group {
        pub struct OptionalGroup {
            #[prost(message, optional, tag = "1")]
            pub nested_group: ::core::option::Option<super::NestedGroup>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OptionalGroup {
            #[inline]
            fn clone(&self) -> OptionalGroup {
                OptionalGroup {
                    nested_group: ::core::clone::Clone::clone(&self.nested_group),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OptionalGroup { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OptionalGroup {
            #[inline]
            fn eq(&self, other: &OptionalGroup) -> bool {
                self.nested_group == other.nested_group
            }
        }
        impl ::prost::Message for OptionalGroup {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref msg) = self.nested_group {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "OptionalGroup";
                match tag {
                    1u32 => {
                        let mut value = &mut self.nested_group;
                        ::prost::encoding::message::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "nested_group"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.nested_group.as_ref().map_or(0,
                        |msg| ::prost::encoding::message::encoded_len(1u32, msg))
            }
            fn clear(&mut self) {
                self.nested_group = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for OptionalGroup {
            fn default() -> Self {
                OptionalGroup {
                    nested_group: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for OptionalGroup {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("OptionalGroup");
                let builder =
                    {
                        let wrapper = &self.nested_group;
                        builder.field("nested_group", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        pub struct RequiredGroup {
            #[prost(message, required, tag = "1")]
            pub nested_group: super::NestedGroup,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RequiredGroup {
            #[inline]
            fn clone(&self) -> RequiredGroup {
                RequiredGroup {
                    nested_group: ::core::clone::Clone::clone(&self.nested_group),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RequiredGroup { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RequiredGroup {
            #[inline]
            fn eq(&self, other: &RequiredGroup) -> bool {
                self.nested_group == other.nested_group
            }
        }
        impl ::prost::Message for RequiredGroup {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                ::prost::encoding::message::encode(1u32, &self.nested_group,
                    buf);
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "RequiredGroup";
                match tag {
                    1u32 => {
                        let mut value = &mut self.nested_group;
                        ::prost::encoding::message::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "nested_group"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    ::prost::encoding::message::encoded_len(1u32,
                        &self.nested_group)
            }
            fn clear(&mut self) { self.nested_group.clear(); }
        }
        impl ::core::default::Default for RequiredGroup {
            fn default() -> Self {
                RequiredGroup {
                    nested_group: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for RequiredGroup {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("RequiredGroup");
                let builder =
                    {
                        let wrapper = &self.nested_group;
                        builder.field("nested_group", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        pub struct RepeatedGroup {
            #[prost(message, repeated, tag = "1")]
            pub nested_groups: ::prost::alloc::vec::Vec<super::NestedGroup>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RepeatedGroup {
            #[inline]
            fn clone(&self) -> RepeatedGroup {
                RepeatedGroup {
                    nested_groups: ::core::clone::Clone::clone(&self.nested_groups),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RepeatedGroup { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RepeatedGroup {
            #[inline]
            fn eq(&self, other: &RepeatedGroup) -> bool {
                self.nested_groups == other.nested_groups
            }
        }
        impl ::prost::Message for RepeatedGroup {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                for msg in &self.nested_groups {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "RepeatedGroup";
                match tag {
                    1u32 => {
                        let mut value = &mut self.nested_groups;
                        ::prost::encoding::message::merge_repeated(wire_type, value,
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "nested_groups"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    ::prost::encoding::message::encoded_len_repeated(1u32,
                        &self.nested_groups)
            }
            fn clear(&mut self) { self.nested_groups.clear(); }
        }
        impl ::core::default::Default for RepeatedGroup {
            fn default() -> Self {
                RepeatedGroup {
                    nested_groups: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for RepeatedGroup {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("RepeatedGroup");
                let builder =
                    {
                        let wrapper = &self.nested_groups;
                        builder.field("nested_groups", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        pub struct G {
            #[prost(message, optional, tag = "1")]
            pub nested_group: ::core::option::Option<super::NestedGroup>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for G {
            #[inline]
            fn clone(&self) -> G {
                G {
                    nested_group: ::core::clone::Clone::clone(&self.nested_group),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for G { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for G {
            #[inline]
            fn eq(&self, other: &G) -> bool {
                self.nested_group == other.nested_group
            }
        }
        impl ::prost::Message for G {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref msg) = self.nested_group {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "G";
                match tag {
                    1u32 => {
                        let mut value = &mut self.nested_group;
                        ::prost::encoding::message::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "nested_group"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.nested_group.as_ref().map_or(0,
                        |msg| ::prost::encoding::message::encoded_len(1u32, msg))
            }
            fn clear(&mut self) {
                self.nested_group = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for G {
            fn default() -> Self {
                G { nested_group: ::core::default::Default::default() }
            }
        }
        impl ::core::fmt::Debug for G {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("G");
                let builder =
                    {
                        let wrapper = &self.nested_group;
                        builder.field("nested_group", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
        pub enum O {

            #[prost(group, tag = "4")]
            G(::prost::alloc::boxed::Box<G>),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for O {
            #[inline]
            fn clone(&self) -> O {
                match self {
                    O::G(__self_0) =>
                        O::G(::core::clone::Clone::clone(__self_0)),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for O { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for O {
            #[inline]
            fn eq(&self, other: &O) -> bool {
                match (self, other) {
                    (O::G(__self_0), O::G(__arg1_0)) => __self_0 == __arg1_0,
                }
            }
        }
        impl O {
            #[doc = r" Encodes the message to a buffer."]
            pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                match *self {
                    O::G(ref value) => {
                        ::prost::encoding::group::encode(4u32, &*value, buf);
                    }
                }
            }
            #[doc =
            r" Decodes an instance of the message from a buffer, and merges it into self."]
            pub fn merge(field: &mut ::core::option::Option<O>, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                match tag {
                    4u32 => {
                        match field {
                            ::core::option::Option::Some(O::G(ref mut value)) => {
                                ::prost::encoding::group::merge(tag, wire_type, value, buf,
                                    ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::group::merge(tag, wire_type, value, buf,
                                        ctx).map(|_|
                                        *field = ::core::option::Option::Some(O::G(owned_value)))
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("invalid O tag: {0}", tag)));
                    }
                }
            }
            #[doc =
            r" Returns the encoded length of the message without a length delimiter."]
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    O::G(ref value) =>
                        ::prost::encoding::group::encoded_len(4u32, &*value),
                }
            }
        }
        impl ::core::fmt::Debug for O {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match *self {
                    O::G(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("G").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    pub struct NestedGroup2 {
        #[prost(group, optional, boxed, tag = "1")]
        pub optionalgroup: ::core::option::Option<::prost::alloc::boxed::Box<nested_group2::OptionalGroup>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NestedGroup2 {
        #[inline]
        fn clone(&self) -> NestedGroup2 {
            NestedGroup2 {
                optionalgroup: ::core::clone::Clone::clone(&self.optionalgroup),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NestedGroup2 { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NestedGroup2 {
        #[inline]
        fn eq(&self, other: &NestedGroup2) -> bool {
            self.optionalgroup == other.optionalgroup
        }
    }
    impl ::prost::Message for NestedGroup2 {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if let Some(ref msg) = self.optionalgroup {
                    ::prost::encoding::group::encode(1u32, msg, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "NestedGroup2";
            match tag {
                1u32 => {
                    let mut value = &mut self.optionalgroup;
                    ::prost::encoding::group::merge(tag, wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "optionalgroup"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                self.optionalgroup.as_ref().map_or(0,
                    |msg| ::prost::encoding::group::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.optionalgroup = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for NestedGroup2 {
        fn default() -> Self {
            NestedGroup2 {
                optionalgroup: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for NestedGroup2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NestedGroup2");
            let builder =
                {
                    let wrapper = &self.optionalgroup;
                    builder.field("optionalgroup", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `NestedGroup2`.
    pub mod nested_group2 {
        pub struct OptionalGroup {
            #[prost(message, optional, tag = "1")]
            pub nested_group: ::core::option::Option<super::NestedGroup2>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OptionalGroup {
            #[inline]
            fn clone(&self) -> OptionalGroup {
                OptionalGroup {
                    nested_group: ::core::clone::Clone::clone(&self.nested_group),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OptionalGroup { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OptionalGroup {
            #[inline]
            fn eq(&self, other: &OptionalGroup) -> bool {
                self.nested_group == other.nested_group
            }
        }
        impl ::prost::Message for OptionalGroup {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let Some(ref msg) = self.nested_group {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "OptionalGroup";
                match tag {
                    1u32 => {
                        let mut value = &mut self.nested_group;
                        ::prost::encoding::message::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "nested_group"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                    self.nested_group.as_ref().map_or(0,
                        |msg| ::prost::encoding::message::encoded_len(1u32, msg))
            }
            fn clear(&mut self) {
                self.nested_group = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for OptionalGroup {
            fn default() -> Self {
                OptionalGroup {
                    nested_group: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for OptionalGroup {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("OptionalGroup");
                let builder =
                    {
                        let wrapper = &self.nested_group;
                        builder.field("nested_group", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
    }
}
pub mod proto3 {
    pub mod presence {
        pub struct A {
            #[prost(int32, optional, tag = "1")]
            pub b: ::core::option::Option<i32>,
            #[prost(oneof = "a::Foo", tags = "2")]
            pub foo: ::core::option::Option<a::Foo>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for A {
            #[inline]
            fn clone(&self) -> A {
                let _:
                        ::core::clone::AssertParamIsClone<::core::option::Option<i32>>;
                let _:
                        ::core::clone::AssertParamIsClone<::core::option::Option<a::Foo>>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for A { }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for A { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for A {
            #[inline]
            fn eq(&self, other: &A) -> bool {
                self.b == other.b && self.foo == other.foo
            }
        }
        impl ::prost::Message for A {
            #[allow(unused_variables)]
            fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
                if let ::core::option::Option::Some(ref value) = self.b {
                        ::prost::encoding::int32::encode(1u32, value, buf);
                    }
                if let Some(ref oneof) = self.foo { oneof.encode(buf) }
            }
            #[allow(unused_variables)]
            fn merge_field(&mut self, tag: u32,
                wire_type: ::prost::encoding::wire_type::WireType,
                buf: &mut impl ::prost::bytes::Buf,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> {
                const STRUCT_NAME: &'static str = "A";
                match tag {
                    1u32 => {
                        let mut value = &mut self.b;
                        ::prost::encoding::int32::merge(wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "b"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.foo;
                        a::Foo::merge(value, tag, wire_type, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "foo"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                        self.b.as_ref().map_or(0,
                            |value| ::prost::encoding::int32::encoded_len(1u32, value))
                    + self.foo.as_ref().map_or(0, a::Foo::encoded_len)
            }
            fn clear(&mut self) {
                self.b = ::core::option::Option::None;
                self.foo = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for A {
            fn default() -> Self {
                A {
                    b: ::core::option::Option::None,
                    foo: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for A {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("A");
                let builder =
                    {
                        let wrapper =
                            {
                                struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                        -> ::core::fmt::Result {
                                        #[allow(non_snake_case)]
                                        fn Inner<T>(v: T) -> T { v }
                                        ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                    }
                                }
                                ScalarWrapper(&self.b)
                            };
                        builder.field("b", &wrapper)
                    };
                ;
                let builder =
                    { let wrapper = &self.foo; builder.field("foo", &wrapper) };
                ;
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl A {
            #[doc =
            "Returns the value of `b`, or the default value if `b` is unset."]
            pub fn b(&self) -> i32 {
                match self.b {
                    ::core::option::Option::Some(val) => val,
                    ::core::option::Option::None => 0i32,
                }
            }
        }
        /// Nested message and enum types in `A`.
        pub mod a {
            pub enum Foo {

                #[prost(int32, tag = "2")]
                C(i32),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Foo {
                #[inline]
                fn clone(&self) -> Foo {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Foo { }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Foo { }
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Foo {
                #[inline]
                fn eq(&self, other: &Foo) -> bool {
                    match (self, other) {
                        (Foo::C(__self_0), Foo::C(__arg1_0)) =>
                            __self_0 == __arg1_0,
                    }
                }
            }
            impl Foo {
                #[doc = r" Encodes the message to a buffer."]
                pub fn encode(&self, buf: &mut impl ::prost::bytes::BufMut) {
                    match *self {
                        Foo::C(ref value) => {
                            ::prost::encoding::int32::encode(2u32, &*value, buf);
                        }
                    }
                }
                #[doc =
                r" Decodes an instance of the message from a buffer, and merges it into self."]
                pub fn merge(field: &mut ::core::option::Option<Foo>,
                    tag: u32, wire_type: ::prost::encoding::wire_type::WireType,
                    buf: &mut impl ::prost::bytes::Buf,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> {
                    match tag {
                        2u32 => {
                            match field {
                                ::core::option::Option::Some(Foo::C(ref mut value)) => {
                                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::int32::merge(wire_type, value, buf,
                                            ctx).map(|_|
                                            *field = ::core::option::Option::Some(Foo::C(owned_value)))
                                }
                            }
                        }
                        _ => {
                            ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                    format_args!("invalid Foo tag: {0}", tag)));
                        }
                    }
                }
                #[doc =
                r" Returns the encoded length of the message without a length delimiter."]
                #[inline]
                pub fn encoded_len(&self) -> usize {
                    match *self {
                        Foo::C(ref value) =>
                            ::prost::encoding::int32::encoded_len(2u32, &*value),
                    }
                }
            }
            impl ::core::fmt::Debug for Foo {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    match *self {
                        Foo::C(ref value) => {
                            let wrapper =
                                {
                                    #[allow(non_snake_case)]
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&*value)
                                };
                            f.debug_tuple("C").field(&wrapper).finish()
                        }
                    }
                }
            }
        }
    }
}
pub mod default_string_escape {
    pub struct Person {
        #[prost(string, required, tag = "1", default = "[\"unknown\"]")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub age: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Person {
        #[inline]
        fn clone(&self) -> Person {
            Person {
                name: ::core::clone::Clone::clone(&self.name),
                age: ::core::clone::Clone::clone(&self.age),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Person { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Person {
        #[inline]
        fn eq(&self, other: &Person) -> bool {
            self.name == other.name && self.age == other.age
        }
    }
    impl ::prost::Message for Person {
        #[allow(unused_variables)]
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            ::prost::encoding::string::encode(1u32, &self.name, buf);
            ::prost::encoding::string::encode(2u32, &self.age, buf);
        }
        #[allow(unused_variables)]
        fn merge_field(&mut self, tag: u32,
            wire_type: ::prost::encoding::wire_type::WireType,
            buf: &mut impl ::prost::bytes::Buf,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> {
            const STRUCT_NAME: &'static str = "Person";
            match tag {
                1u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "name"); error })
                }
                2u32 => {
                    let mut value = &mut self.age;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "age"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::string::encoded_len(1u32, &self.name) +
                ::prost::encoding::string::encoded_len(2u32, &self.age)
        }
        fn clear(&mut self) { self.name.clear(); self.age.clear(); }
    }
    impl ::core::default::Default for Person {
        fn default() -> Self {
            Person {
                name: "[\"unknown\"]".into(),
                age: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for Person {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Person");
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.name)
                        };
                    builder.field("name", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.age)
                        };
                    builder.field("age", &wrapper)
                };
            ;
            builder.finish()
        }
    }
}
use anyhow::anyhow;
use prost::bytes::Buf;
use prost::Message;
pub enum RoundtripResult {

    /// The roundtrip succeeded.
    Ok(Vec<u8>),

    /// The data could not be decoded. This could indicate a bug in prost,
    /// or it could indicate that the input was bogus.
    DecodeError(prost::DecodeError),

    /// Re-encoding or validating the data failed.  This indicates a bug in `prost`.
    Error(anyhow::Error),
}
impl RoundtripResult {
    /// Unwrap the roundtrip result.
    pub fn unwrap(self) -> Vec<u8> {
        match self {
            RoundtripResult::Ok(buf) => buf,
            RoundtripResult::DecodeError(error) => {
                {
                    ::core::panicking::panic_fmt(format_args!("failed to decode the roundtrip data: {0}",
                            error));
                }
            }
            RoundtripResult::Error(error) => {
                ::core::panicking::panic_fmt(format_args!("failed roundtrip: {0}",
                        error));
            }
        }
    }
    /// Unwrap the roundtrip result. Panics if the result was a validation or re-encoding error.
    pub fn unwrap_error(self) -> Result<Vec<u8>, prost::DecodeError> {
        match self {
            RoundtripResult::Ok(buf) => Ok(buf),
            RoundtripResult::DecodeError(error) => Err(error),
            RoundtripResult::Error(error) => {
                ::core::panicking::panic_fmt(format_args!("failed roundtrip: {0}",
                        error));
            }
        }
    }
}
/// Tests round-tripping a message type. The message should be compiled with `BTreeMap` fields,
/// otherwise the comparison may fail due to inconsistent `HashMap` entry encoding ordering.
pub fn roundtrip<M>(data: &[u8]) -> RoundtripResult where M: Message +
    Default {
    let all_types =
        match M::decode(data) {
            Ok(all_types) => all_types,
            Err(error) => return RoundtripResult::DecodeError(error),
        };
    let encoded_len = all_types.encoded_len();
    let mut buf1 = Vec::new();
    if let Err(error) = all_types.encode(&mut buf1) {
            return RoundtripResult::Error(::anyhow::__private::must_use({
                            use ::anyhow::__private::kind::*;
                            let error =
                                match error { error => (&error).anyhow_kind().new(error), };
                            error
                        }));
        }
    let buf1 = buf1;
    if encoded_len != buf1.len() {
            return RoundtripResult::Error(::anyhow::Error::msg(::alloc::__export::must_use({
                                let res =
                                    ::alloc::fmt::format(format_args!("expected encoded len ({0}) did not match actual encoded len ({1})",
                                            encoded_len, buf1.len()));
                                res
                            })));
        }
    let roundtrip =
        match M::decode(buf1.as_slice()) {
            Ok(roundtrip) => roundtrip,
            Err(error) =>
                return RoundtripResult::Error(::anyhow::__private::must_use({
                                use ::anyhow::__private::kind::*;
                                let error =
                                    match error { error => (&error).anyhow_kind().new(error), };
                                error
                            })),
        };
    let mut buf2 = Vec::new();
    if let Err(error) = roundtrip.encode(&mut buf2) {
            return RoundtripResult::Error(::anyhow::__private::must_use({
                            use ::anyhow::__private::kind::*;
                            let error =
                                match error { error => (&error).anyhow_kind().new(error), };
                            error
                        }));
        }
    let buf2 = buf2;
    let buf3 = roundtrip.encode_to_vec();
    if buf1 != buf2 {
            return RoundtripResult::Error(::anyhow::__private::must_use({
                            let error =
                                ::anyhow::__private::format_err(format_args!("roundtripped encoded buffers do not match"));
                            error
                        }));
        }
    if buf1 != buf3 {
            return RoundtripResult::Error(::anyhow::__private::must_use({
                            let error =
                                ::anyhow::__private::format_err(format_args!("roundtripped encoded buffers do not match with `encode_to_vec`"));
                            error
                        }));
        }
    RoundtripResult::Ok(buf1)
}
/// Generic roundtrip serialization check for messages.
pub fn check_message<M>(msg: &M) where M: Message + Default + PartialEq {
    let expected_len = msg.encoded_len();
    let mut buf = Vec::with_capacity(18);
    msg.encode(&mut buf).unwrap();
    match (&expected_len, &buf.len()) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(kind, &*left_val,
                        &*right_val, ::core::option::Option::None);
                }
        }
    };
    let mut buf = buf.as_slice();
    let roundtrip = M::decode(&mut buf).unwrap();
    if !!buf.has_remaining() {
            {
                ::core::panicking::panic_fmt(format_args!("expected buffer to be empty: {0}",
                        buf.remaining()));
            }
        };
    match (&msg, &&roundtrip) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(kind, &*left_val,
                        &*right_val, ::core::option::Option::None);
                }
        }
    };
}
/// Serialize from A should equal Serialize from B
pub fn check_serialize_equivalent<M, N>(msg_a: &M, msg_b: &N) where
    M: Message + Default + PartialEq, N: Message + Default + PartialEq {
    let mut buf_a = Vec::new();
    msg_a.encode(&mut buf_a).unwrap();
    let mut buf_b = Vec::new();
    msg_b.encode(&mut buf_b).unwrap();
    match (&buf_a, &buf_b) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(kind, &*left_val,
                        &*right_val, ::core::option::Option::None);
                }
        }
    };
}
#[cfg(test)]
mod tests {
    use alloc::collections::{BTreeMap, BTreeSet};
    use alloc::vec;
    use super::*;
    use protobuf::test_messages::proto3::TestAllTypesProto3;
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_all_types_proto3"]
    #[doc(hidden)]
    pub const test_all_types_proto3: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_all_types_proto3"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 287usize,
                start_col: 8usize,
                end_line: 287usize,
                end_col: 29usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_all_types_proto3())),
        };
    fn test_all_types_proto3() {
        let msgs: &[&[u8]] =
            &[&[0x28, 0x28, 0x28, 0xFF, 0xFF, 0xFF, 0xFF, 0x68],
                        &[0x92, 0x01, 0x00, 0x92, 0xF4, 0x01, 0x02, 0x00, 0x00],
                        &[0x5d, 0xff, 0xff, 0xff, 0xff, 0x28, 0xff, 0xff, 0x21],
                        &[0x98, 0x04, 0x02, 0x08, 0x0B, 0x98, 0x04, 0x02, 0x08,
                                    0x02],
                        &[0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                    0x08], &[0xDA, 0x02, 0x02, 0x2A, 0x03],
                        &[0xb1, 0x07, 0xf6, 0x3d, 0xf5, 0xff, 0x27, 0x3d, 0xf5,
                                    0xff], &[0xdd, 0x00, 0x00, 0x00, 0x00, 0x80],
                        &[0xE2, 0x13, 0x1B, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                                    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                                    0x11, 0x11, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                    0xFF, 0x08, 0xFF, 0x0E]];
        for msg in msgs { roundtrip::<TestAllTypesProto3>(msg).unwrap(); }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_ident_conversions"]
    #[doc(hidden)]
    pub const test_ident_conversions: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_ident_conversions"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 316usize,
                start_col: 8usize,
                end_line: 316usize,
                end_col: 30usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_ident_conversions())),
        };
    fn test_ident_conversions() {
        let msg =
            foo::bar_baz::FooBarBaz {
                foo_bar_baz: 42,
                fuzz_busters: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([foo::bar_baz::foo_bar_baz::FuzzBuster {
                                    t: BTreeMap::<i32, foo::bar_baz::FooBarBaz>::new(),
                                    nested_self: None,
                                }])),
                p_i_e: foo::bar_baz::foo_bar_baz::StrawberryRhubarbPie::Foo.into(),
                r#as: 4,
                r#break: 5,
                r#const: 6,
                r#continue: 7,
                r#else: 8,
                r#enum: 9,
                r#false: 10,
                r#fn: 11,
                r#for: 12,
                r#if: 13,
                r#impl: 14,
                r#in: 15,
                r#let: 16,
                r#loop: 17,
                r#match: 18,
                r#mod: 19,
                r#move: 20,
                r#mut: 21,
                r#pub: 22,
                r#ref: 23,
                r#return: 24,
                r#static: 25,
                r#struct: 26,
                r#trait: 27,
                r#true: 28,
                r#type: 29,
                r#unsafe: 30,
                r#use: 31,
                r#where: 32,
                r#while: 33,
                r#dyn: 34,
                r#abstract: 35,
                r#become: 36,
                r#box: 37,
                r#do: 38,
                r#final: 39,
                r#macro: 40,
                r#override: 41,
                r#priv: 42,
                r#typeof: 43,
                r#unsized: 44,
                r#virtual: 45,
                r#yield: 46,
                r#async: 47,
                r#await: 48,
                r#try: 49,
                self_: 50,
                super_: 51,
                extern_: 52,
                crate_: 53,
            };
        let _ = foo::bar_baz::foo_bar_baz::Self_ {};
        let _ = foo::bar_baz::foo_bar_baz::StrawberryRhubarbPie::Foo;
        let _ = foo::bar_baz::foo_bar_baz::StrawberryRhubarbPie::Bar;
        let _ = foo::bar_baz::foo_bar_baz::StrawberryRhubarbPie::FooBar;
        let _ = foo::bar_baz::foo_bar_baz::StrawberryRhubarbPie::FuzzBuster;
        let _ =
            foo::bar_baz::foo_bar_baz::StrawberryRhubarbPie::NormalRustEnumCase;
        let mut buf = Vec::new();
        msg.encode(&mut buf).expect("encode");
        roundtrip::<foo::bar_baz::FooBarBaz>(&buf).unwrap();
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_custom_type_attributes"]
    #[doc(hidden)]
    pub const test_custom_type_attributes: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_custom_type_attributes"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 391usize,
                start_col: 8usize,
                end_line: 391usize,
                end_col: 35usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_custom_type_attributes())),
        };
    fn test_custom_type_attributes() {
        let mut set1 = BTreeSet::new();
        let msg1 = foo::bar_baz::FooBarBaz::default();
        set1.insert(msg1);
        let mut set2 = BTreeSet::new();
        let msg2 = oneof_attributes::Msg::default();
        set2.insert(msg2.field);
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_nesting"]
    #[doc(hidden)]
    pub const test_nesting: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_nesting"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 404usize,
                start_col: 8usize,
                end_line: 404usize,
                end_col: 20usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_nesting())),
        };
    fn test_nesting() {
        use crate::nesting::{A, B};
        let _ =
            A {
                a: Some(Box::default()),
                repeated_a: Vec::<A>::new(),
                map_a: BTreeMap::<i32, A>::new(),
                b: Some(Box::default()),
                repeated_b: Vec::<B>::new(),
                map_b: BTreeMap::<i32, B>::new(),
            };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_deep_nesting"]
    #[doc(hidden)]
    pub const test_deep_nesting: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_deep_nesting"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 417usize,
                start_col: 8usize,
                end_line: 417usize,
                end_col: 25usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_deep_nesting())),
        };
    fn test_deep_nesting() {
        fn build_and_roundtrip(depth: usize)
            -> Result<(), prost::DecodeError> {
            use crate::nesting::A;
            let mut a = Box::<A>::default();
            for _ in 0..depth {
                let mut next = Box::<A>::default();
                next.a = Some(a);
                a = next;
            }
            let mut buf = Vec::new();
            a.encode(&mut buf).unwrap();
            A::decode(buf.as_slice()).map(|_| ())
        }
        if !build_and_roundtrip(100).is_ok() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(100).is_ok()")
            };
        if !build_and_roundtrip(101).is_err() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(101).is_err()")
            };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_deep_nesting_oneof"]
    #[doc(hidden)]
    pub const test_deep_nesting_oneof: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_deep_nesting_oneof"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 438usize,
                start_col: 8usize,
                end_line: 438usize,
                end_col: 31usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_deep_nesting_oneof())),
        };
    fn test_deep_nesting_oneof() {
        fn build_and_roundtrip(depth: usize)
            -> Result<(), prost::DecodeError> {
            use crate::recursive_oneof::{a, A, C};
            let mut a = Box::new(A { kind: Some(a::Kind::C(C {})) });
            for _ in 0..depth {
                a = Box::new(A { kind: Some(a::Kind::A(a)) });
            }
            let mut buf = Vec::new();
            a.encode(&mut buf).unwrap();
            A::decode(buf.as_slice()).map(|_| ())
        }
        if !build_and_roundtrip(99).is_ok() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(99).is_ok()")
            };
        if !build_and_roundtrip(100).is_err() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(100).is_err()")
            };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_deep_nesting_group"]
    #[doc(hidden)]
    pub const test_deep_nesting_group: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_deep_nesting_group"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 461usize,
                start_col: 8usize,
                end_line: 461usize,
                end_col: 31usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_deep_nesting_group())),
        };
    fn test_deep_nesting_group() {
        fn build_and_roundtrip(depth: usize)
            -> Result<(), prost::DecodeError> {
            use crate::groups::{nested_group2::OptionalGroup, NestedGroup2};
            let mut a = NestedGroup2::default();
            for _ in 0..depth {
                a =
                    NestedGroup2 {
                        optionalgroup: Some(Box::new(OptionalGroup {
                                    nested_group: Some(a),
                                })),
                    };
            }
            let mut buf = Vec::new();
            a.encode(&mut buf).unwrap();
            NestedGroup2::decode(buf.as_slice()).map(|_| ())
        }
        if !build_and_roundtrip(50).is_ok() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(50).is_ok()")
            };
        if !build_and_roundtrip(51).is_err() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(51).is_err()")
            };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_deep_nesting_repeated"]
    #[doc(hidden)]
    pub const test_deep_nesting_repeated: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_deep_nesting_repeated"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 484usize,
                start_col: 8usize,
                end_line: 484usize,
                end_col: 34usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_deep_nesting_repeated())),
        };
    fn test_deep_nesting_repeated() {
        fn build_and_roundtrip(depth: usize)
            -> Result<(), prost::DecodeError> {
            use crate::nesting::C;
            let mut c = C::default();
            for _ in 0..depth {
                let mut next = C::default();
                next.r.push(c);
                c = next;
            }
            let mut buf = Vec::new();
            c.encode(&mut buf).unwrap();
            C::decode(buf.as_slice()).map(|_| ())
        }
        if !build_and_roundtrip(100).is_ok() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(100).is_ok()")
            };
        if !build_and_roundtrip(101).is_err() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(101).is_err()")
            };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_deep_nesting_map"]
    #[doc(hidden)]
    pub const test_deep_nesting_map: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_deep_nesting_map"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 505usize,
                start_col: 8usize,
                end_line: 505usize,
                end_col: 29usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_deep_nesting_map())),
        };
    fn test_deep_nesting_map() {
        fn build_and_roundtrip(depth: usize)
            -> Result<(), prost::DecodeError> {
            use crate::nesting::D;
            let mut d = D::default();
            for _ in 0..depth {
                let mut next = D::default();
                next.m.insert("foo".to_owned(), d);
                d = next;
            }
            let mut buf = Vec::new();
            d.encode(&mut buf).unwrap();
            D::decode(buf.as_slice()).map(|_| ())
        }
        if !build_and_roundtrip(50).is_ok() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(50).is_ok()")
            };
        if !build_and_roundtrip(51).is_err() {
                ::core::panicking::panic("assertion failed: build_and_roundtrip(51).is_err()")
            };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_recursive_oneof"]
    #[doc(hidden)]
    pub const test_recursive_oneof: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_recursive_oneof"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 526usize,
                start_col: 8usize,
                end_line: 526usize,
                end_col: 28usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_recursive_oneof())),
        };
    fn test_recursive_oneof() {
        use crate::recursive_oneof::{a, A, B, C};
        let _ =
            A {
                kind: Some(a::Kind::B(Box::new(B {
                                a: Some(Box::new(A { kind: Some(a::Kind::C(C {})) })),
                            }))),
            };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_267_regression"]
    #[doc(hidden)]
    pub const test_267_regression: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_267_regression"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 538usize,
                start_col: 8usize,
                end_line: 538usize,
                end_col: 27usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_267_regression())),
        };
    fn test_267_regression() {
        let buf = ::alloc::vec::from_elem(b'C', 1 << 20);
        <() as Message>::decode(&buf[..]).err().unwrap();
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_default_enum"]
    #[doc(hidden)]
    pub const test_default_enum: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_default_enum"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 548usize,
                start_col: 8usize,
                end_line: 548usize,
                end_col: 25usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_default_enum())),
        };
    fn test_default_enum() {
        let msg = default_enum_value::Test::default();
        match (&msg.privacy_level_1(), &default_enum_value::PrivacyLevel::One)
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&msg.privacy_level_3(),
                &default_enum_value::PrivacyLevel::PrivacyLevelThree) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&msg.privacy_level_4(),
                &default_enum_value::PrivacyLevel::PrivacyLevelprivacyLevelFour)
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_enum_to_string"]
    #[doc(hidden)]
    pub const test_enum_to_string: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_enum_to_string"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 562usize,
                start_col: 8usize,
                end_line: 562usize,
                end_col: 27usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_enum_to_string())),
        };
    fn test_enum_to_string() {
        use default_enum_value::{ERemoteClientBroadcastMsg, PrivacyLevel};
        match (&PrivacyLevel::One.as_str_name(), &"PRIVACY_LEVEL_ONE") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&PrivacyLevel::Two.as_str_name(), &"PRIVACY_LEVEL_TWO") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&PrivacyLevel::PrivacyLevelThree.as_str_name(),
                &"PRIVACY_LEVEL_PRIVACY_LEVEL_THREE") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&PrivacyLevel::PrivacyLevelprivacyLevelFour.as_str_name(),
                &"PRIVACY_LEVELPRIVACY_LEVEL_FOUR") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&ERemoteClientBroadcastMsg::KERemoteClientBroadcastMsgDiscovery.as_str_name(),
                &"k_ERemoteClientBroadcastMsgDiscovery") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_enum_from_string"]
    #[doc(hidden)]
    pub const test_enum_from_string: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_enum_from_string"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 583usize,
                start_col: 8usize,
                end_line: 583usize,
                end_col: 29usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_enum_from_string())),
        };
    fn test_enum_from_string() {
        use default_enum_value::{ERemoteClientBroadcastMsg, PrivacyLevel};
        match (&Some(PrivacyLevel::One),
                &PrivacyLevel::from_str_name("PRIVACY_LEVEL_ONE")) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Some(PrivacyLevel::Two),
                &PrivacyLevel::from_str_name("PRIVACY_LEVEL_TWO")) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Some(PrivacyLevel::PrivacyLevelThree),
                &PrivacyLevel::from_str_name("PRIVACY_LEVEL_PRIVACY_LEVEL_THREE"))
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Some(PrivacyLevel::PrivacyLevelprivacyLevelFour),
                &PrivacyLevel::from_str_name("PRIVACY_LEVELPRIVACY_LEVEL_FOUR"))
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&None, &PrivacyLevel::from_str_name("PRIVACY_LEVEL_FIVE")) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Some(ERemoteClientBroadcastMsg::KERemoteClientBroadcastMsgDiscovery),
                &ERemoteClientBroadcastMsg::from_str_name("k_ERemoteClientBroadcastMsgDiscovery"))
            {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_enum_try_from_i32"]
    #[doc(hidden)]
    pub const test_enum_try_from_i32: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_enum_try_from_i32"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 611usize,
                start_col: 8usize,
                end_line: 611usize,
                end_col: 30usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_enum_try_from_i32())),
        };
    fn test_enum_try_from_i32() {
        use core::convert::TryFrom;
        use default_enum_value::{ERemoteClientBroadcastMsg, PrivacyLevel};
        match (&Ok(PrivacyLevel::One), &PrivacyLevel::try_from(1)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Ok(PrivacyLevel::Two), &PrivacyLevel::try_from(2)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Ok(PrivacyLevel::PrivacyLevelThree),
                &PrivacyLevel::try_from(3)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Ok(PrivacyLevel::PrivacyLevelprivacyLevelFour),
                &PrivacyLevel::try_from(4)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Err(prost::UnknownEnumValue(5)), &PrivacyLevel::try_from(5)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&Ok(ERemoteClientBroadcastMsg::KERemoteClientBroadcastMsgDiscovery),
                &ERemoteClientBroadcastMsg::try_from(0)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_default_string_escape"]
    #[doc(hidden)]
    pub const test_default_string_escape: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_default_string_escape"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 634usize,
                start_col: 8usize,
                end_line: 634usize,
                end_col: 34usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_default_string_escape())),
        };
    fn test_default_string_escape() {
        let msg = default_string_escape::Person::default();
        match (&msg.name, &r#"["unknown"]"#) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_group"]
    #[doc(hidden)]
    pub const test_group: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_group"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 640usize,
                start_col: 8usize,
                end_line: 640usize,
                end_col: 18usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_group())),
        };
    fn test_group() {
        let msg1_bytes = &[0x0B, 0x10, 0x20, 0x0C];
        let msg1 =
            groups::Test1 {
                groupa: Some(groups::test1::GroupA { i2: Some(32) }),
            };
        let mut bytes = Vec::new();
        msg1.encode(&mut bytes).unwrap();
        match (&&bytes, &msg1_bytes) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        let data: &[u8] =
            &[0x0B, 0x30, 0x01, 0x2B, 0x30, 0xFF, 0x01, 0x2C, 0x10, 0x20,
                        0x0C];
        match (&groups::Test1::decode(data), &Ok(msg1)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        let msg2_bytes: &[u8] =
            &[0x20, 0x40, 0x2B, 0x30, 0xFF, 0x01, 0x2C, 0x2B, 0x30, 0x01,
                        0x2C, 0x38, 0x64];
        let msg2 =
            groups::Test2 {
                i14: Some(64),
                groupb: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([groups::test2::GroupB {
                                    i16: Some(255),
                                }, groups::test2::GroupB { i16: Some(1) }])),
                i17: Some(100),
            };
        let mut bytes = Vec::new();
        msg2.encode(&mut bytes).unwrap();
        match (&bytes.as_slice(), &msg2_bytes) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
        match (&groups::Test2::decode(msg2_bytes), &Ok(msg2)) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(kind, &*left_val,
                            &*right_val, ::core::option::Option::None);
                    }
            }
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_group_oneof"]
    #[doc(hidden)]
    pub const test_group_oneof: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_group_oneof"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 684usize,
                start_col: 8usize,
                end_line: 684usize,
                end_col: 24usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_group_oneof())),
        };
    fn test_group_oneof() {
        let msg =
            groups::OneofGroup {
                i1: Some(42),
                field: Some(groups::oneof_group::Field::S2("foo".to_string())),
            };
        check_message(&msg);
        let msg =
            groups::OneofGroup {
                i1: Some(42),
                field: Some(groups::oneof_group::Field::G(groups::oneof_group::G {
                            i2: None,
                            s1: "foo".to_string(),
                            t1: None,
                        })),
            };
        check_message(&msg);
        let msg =
            groups::OneofGroup {
                i1: Some(42),
                field: Some(groups::oneof_group::Field::G(groups::oneof_group::G {
                            i2: Some(99),
                            s1: "foo".to_string(),
                            t1: Some(groups::Test1 {
                                    groupa: Some(groups::test1::GroupA { i2: None }),
                                }),
                        })),
            };
        check_message(&msg);
        check_message(&groups::OneofGroup::default());
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_proto3_presence"]
    #[doc(hidden)]
    pub const test_proto3_presence: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_proto3_presence"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 717usize,
                start_col: 8usize,
                end_line: 717usize,
                end_col: 28usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_proto3_presence())),
        };
    fn test_proto3_presence() {
        let msg =
            proto3::presence::A {
                b: Some(42),
                foo: Some(proto3::presence::a::Foo::C(13)),
            };
        check_message(&msg);
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::test_file_descriptor_set_path"]
    #[doc(hidden)]
    pub const test_file_descriptor_set_path: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("tests::test_file_descriptor_set_path"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                source_file: "tests/src/lib.rs",
                start_line: 727usize,
                start_col: 8usize,
                end_line: 727usize,
                end_col: 37usize,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(#[coverage(off)] ||
                    test::assert_test_result(test_file_descriptor_set_path())),
        };
    fn test_file_descriptor_set_path() {
        let file_descriptor_set_bytes =
            b"\n\x81\x01\n\nroot.proto\x12\x08packages\"\x0f\n\x04Root\x1a\x07\n\x05InnerJP\n\x06\x12\x04\x00\x00\x07\x01\n\x08\n\x01\x0c\x12\x03\x00\x00\x12\n\x08\n\x01\x02\x12\x03\x02\x00\x11\n\n\n\x02\x04\x00\x12\x04\x04\x00\x07\x01\n\n\n\x03\x04\x00\x01\x12\x03\x04\x08\x0c\n\x0c\n\x04\x04\x00\x03\x00\x12\x04\x05\x02\x06\x03\n\x0c\n\x05\x04\x00\x03\x00\x01\x12\x03\x05\n\x0fb\x06proto3\n\x89\x01\n\x0bgizmo.proto\x12\x0epackages.gizmo\"\x10\n\x05Gizmo\x1a\x07\n\x05InnerJP\n\x06\x12\x04\x00\x00\x07\x01\n\x08\n\x01\x0c\x12\x03\x00\x00\x12\n\x08\n\x01\x02\x12\x03\x02\x00\x17\n\n\n\x02\x04\x00\x12\x04\x04\x00\x07\x01\n\n\n\x03\x04\x00\x01\x12\x03\x04\x08\r\n\x0c\n\x04\x04\x00\x03\x00\x12\x04\x05\x02\x06\x03\n\x0c\n\x05\x04\x00\x03\x00\x01\x12\x03\x05\n\x0fb\x06proto3\n\xd3\x02\n\x0cwidget.proto\x12\x0fpackages.widget\".\n\x06Widget\x1a\x07\n\x05Inner\"\x1b\n\x04Type\x12\x05\n\x01A\x10\x00\x12\x05\n\x01B\x10\x01\x12\x05\n\x01C\x10\x02J\xf9\x01\n\x06\x12\x04\x00\x00\r\x01\n\x08\n\x01\x0c\x12\x03\x00\x00\x12\n\x08\n\x01\x02\x12\x03\x02\x00\x18\n\n\n\x02\x04\x00\x12\x04\x04\x00\r\x01\n\n\n\x03\x04\x00\x01\x12\x03\x04\x08\x0e\n\x0c\n\x04\x04\x00\x03\x00\x12\x04\x05\x02\x06\x03\n\x0c\n\x05\x04\x00\x03\x00\x01\x12\x03\x05\n\x0f\n\x0c\n\x04\x04\x00\x04\x00\x12\x04\x08\x02\x0c\x03\n\x0c\n\x05\x04\x00\x04\x00\x01\x12\x03\x08\x07\x0b\n\r\n\x06\x04\x00\x04\x00\x02\x00\x12\x03\t\x04\n\n\x0e\n\x07\x04\x00\x04\x00\x02\x00\x01\x12\x03\t\x04\x05\n\x0e\n\x07\x04\x00\x04\x00\x02\x00\x02\x12\x03\t\x08\t\n\r\n\x06\x04\x00\x04\x00\x02\x01\x12\x03\n\x04\n\n\x0e\n\x07\x04\x00\x04\x00\x02\x01\x01\x12\x03\n\x04\x05\n\x0e\n\x07\x04\x00\x04\x00\x02\x01\x02\x12\x03\n\x08\t\n\r\n\x06\x04\x00\x04\x00\x02\x02\x12\x03\x0b\x04\n\n\x0e\n\x07\x04\x00\x04\x00\x02\x02\x01\x12\x03\x0b\x04\x05\n\x0e\n\x07\x04\x00\x04\x00\x02\x02\x02\x12\x03\x0b\x08\tb\x06proto3\n\xdf\x08\n\x14widget_factory.proto\x12\x17packages.widget.factory\x1a\nroot.proto\x1a\x0bgizmo.proto\x1a\x0cwidget.proto\"\xd2\x03\n\rWidgetFactory\x12B\n\x05inner\x18\x01 \x01(\x0b2,.packages.widget.factory.WidgetFactory.InnerR\x05inner\x12\"\n\x04root\x18\x02 \x01(\x0b2\x0e.packages.RootR\x04root\x123\n\nroot_inner\x18\x03 \x01(\x0b2\x14.packages.Root.InnerR\trootInner\x12/\n\x06widget\x18\x04 \x01(\x0b2\x17.packages.widget.WidgetR\x06widget\x12@\n\x0cwidget_inner\x18\x05 \x01(\x0b2\x1d.packages.widget.Widget.InnerR\x0bwidgetInner\x12=\n\x0bwidget_type\x18\x08 \x01(\x0e2\x1c.packages.widget.Widget.TypeR\nwidgetType\x12+\n\x05gizmo\x18\x06 \x01(\x0b2\x15.packages.gizmo.GizmoR\x05gizmo\x12<\n\x0bgizmo_inner\x18\x07 \x01(\x0b2\x1b.packages.gizmo.Gizmo.InnerR\ngizmoInner\x1a\x07\n\x05InnerJ\xa9\x04\n\x06\x12\x04\x00\x00\x17\x01\n\x08\n\x01\x0c\x12\x03\x00\x00\x12\n\x08\n\x01\x02\x12\x03\x02\x00 \n\t\n\x02\x03\x00\x12\x03\x04\x00\x14\n\t\n\x02\x03\x01\x12\x03\x05\x00\x15\n\t\n\x02\x03\x02\x12\x03\x06\x00\x16\n\n\n\x02\x04\x00\x12\x04\x08\x00\x17\x01\n\n\n\x03\x04\x00\x01\x12\x03\x08\x08\x15\n\x0c\n\x04\x04\x00\x03\x00\x12\x04\t\x02\n\x03\n\x0c\n\x05\x04\x00\x03\x00\x01\x12\x03\t\n\x0f\n\x0b\n\x04\x04\x00\x02\x00\x12\x03\x0c\x02\x12\n\x0c\n\x05\x04\x00\x02\x00\x06\x12\x03\x0c\x02\x07\n\x0c\n\x05\x04\x00\x02\x00\x01\x12\x03\x0c\x08\r\n\x0c\n\x05\x04\x00\x02\x00\x03\x12\x03\x0c\x10\x11\n\x0b\n\x04\x04\x00\x02\x01\x12\x03\x0e\x02\x10\n\x0c\n\x05\x04\x00\x02\x01\x06\x12\x03\x0e\x02\x06\n\x0c\n\x05\x04\x00\x02\x01\x01\x12\x03\x0e\x07\x0b\n\x0c\n\x05\x04\x00\x02\x01\x03\x12\x03\x0e\x0e\x0f\n\x0b\n\x04\x04\x00\x02\x02\x12\x03\x0f\x02\x1c\n\x0c\n\x05\x04\x00\x02\x02\x06\x12\x03\x0f\x02\x0c\n\x0c\n\x05\x04\x00\x02\x02\x01\x12\x03\x0f\r\x17\n\x0c\n\x05\x04\x00\x02\x02\x03\x12\x03\x0f\x1a\x1b\n\x0b\n\x04\x04\x00\x02\x03\x12\x03\x11\x02\x14\n\x0c\n\x05\x04\x00\x02\x03\x06\x12\x03\x11\x02\x08\n\x0c\n\x05\x04\x00\x02\x03\x01\x12\x03\x11\t\x0f\n\x0c\n\x05\x04\x00\x02\x03\x03\x12\x03\x11\x12\x13\n\x0b\n\x04\x04\x00\x02\x04\x12\x03\x12\x02 \n\x0c\n\x05\x04\x00\x02\x04\x06\x12\x03\x12\x02\x0e\n\x0c\n\x05\x04\x00\x02\x04\x01\x12\x03\x12\x0f\x1b\n\x0c\n\x05\x04\x00\x02\x04\x03\x12\x03\x12\x1e\x1f\n\x0b\n\x04\x04\x00\x02\x05\x12\x03\x13\x02\x1e\n\x0c\n\x05\x04\x00\x02\x05\x06\x12\x03\x13\x02\r\n\x0c\n\x05\x04\x00\x02\x05\x01\x12\x03\x13\x0e\x19\n\x0c\n\x05\x04\x00\x02\x05\x03\x12\x03\x13\x1c\x1d\n\x0b\n\x04\x04\x00\x02\x06\x12\x03\x15\x02\x18\n\x0c\n\x05\x04\x00\x02\x06\x06\x12\x03\x15\x02\r\n\x0c\n\x05\x04\x00\x02\x06\x01\x12\x03\x15\x0e\x13\n\x0c\n\x05\x04\x00\x02\x06\x03\x12\x03\x15\x16\x17\n\x0b\n\x04\x04\x00\x02\x07\x12\x03\x16\x02$\n\x0c\n\x05\x04\x00\x02\x07\x06\x12\x03\x16\x02\x13\n\x0c\n\x05\x04\x00\x02\x07\x01\x12\x03\x16\x14\x1f\n\x0c\n\x05\x04\x00\x02\x07\x03\x12\x03\x16\"#b\x06proto3";
        prost_types::FileDescriptorSet::decode(&file_descriptor_set_bytes[..]).unwrap();
    }
}
#[rustc_main]
#[coverage(off)]
#[doc(hidden)]
pub fn main() -> () {
    extern crate test;
    test::test_main_static(&[&bootstrap, &test_bar_is_boxed,
                    &oneof_with_enum_custom_debug, &tuple_struct_custom_debug,
                    &oneof_with_enum_custom_debug, &tuple_struct_custom_debug,
                    &oneof_with_enum_custom_debug, &tuple_struct_custom_debug,
                    &test_proto_msg_custom_debug, &basic, &oneof_with_enum,
                    &tuple_struct, &test_decode_error_any,
                    &test_decode_error_buffer_underflow,
                    &test_decode_error_invalid_key_value,
                    &test_decode_error_invalid_string,
                    &test_decode_error_invalid_tag,
                    &test_decode_error_invalid_varint,
                    &test_decode_error_invalid_wire_type,
                    &test_decode_error_multiple_levels,
                    &test_decode_error_recursion_limit_reached,
                    &test_decode_error_unexpected_wire_type,
                    &test_into_std_io_error, &test_push,
                    &test_warns_when_using_fields_with_deprecated_field, &dummy,
                    &test, &generic_enum, &check_default_values,
                    &check_repeated_floats, &check_scalar_types,
                    &check_tags_inferred, &generated_include, &test, &dummy,
                    &dummy, &test, &test_submessage_without_package,
                    &test_267_regression, &test_all_types_proto3,
                    &test_custom_type_attributes, &test_deep_nesting,
                    &test_deep_nesting_group, &test_deep_nesting_map,
                    &test_deep_nesting_oneof, &test_deep_nesting_repeated,
                    &test_default_enum, &test_default_string_escape,
                    &test_enum_from_string, &test_enum_to_string,
                    &test_enum_try_from_i32, &test_file_descriptor_set_path,
                    &test_group, &test_group_oneof, &test_ident_conversions,
                    &test_nesting, &test_proto3_presence, &test_recursive_oneof,
                    &valid_type_names, &extreme_default_values])
}
