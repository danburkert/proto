use crate::encoding::{DecodeContext, WireType};
use crate::{DecodeError, Message};

use bytes::{Buf, BufMut};

use alloc::format;
use core::cmp;
use core::fmt::{self, Debug};
use core::marker::PhantomData;

pub struct OpenEnum<T> {
    raw: i32,
    _phantom: PhantomData<T>,
}

impl<T> Copy for OpenEnum<T> {}

impl<T> Clone for OpenEnum<T> {
    fn clone(&self) -> Self {
        *self
    }
}

// Safety: the only material inner value is an integer
unsafe impl<T> Send for OpenEnum<T> {}
unsafe impl<T> Sync for OpenEnum<T> {}

impl<T> Default for OpenEnum<T>
where
    T: Default,
    T: Into<i32>,
{
    fn default() -> Self {
        Self::from(T::default())
    }
}

impl<T> Debug for OpenEnum<T>
where
    T: Debug,
    i32: TryInto<T>,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match TryInto::<T>::try_into(self.raw) {
            Ok(v) => f.debug_tuple("Known").field(&v).finish(),
            Err(_) => f.debug_tuple("Unknown").field(&self.raw).finish(),
        }
    }
}

// Eq and Ord are implemented in terms of raw integers. This should be good
// for the #[repr(i32)] discriminated enums generated by prost-build.

impl<T> PartialEq for OpenEnum<T> {
    fn eq(&self, other: &Self) -> bool {
        self.raw == other.raw
    }
}

impl<T> Eq for OpenEnum<T> {}

impl<T> PartialOrd for OpenEnum<T> {
    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl<T> Ord for OpenEnum<T> {
    fn cmp(&self, other: &Self) -> cmp::Ordering {
        self.raw.cmp(&other.raw)
    }
}

impl<T> From<T> for OpenEnum<T>
where
    T: Into<i32>,
{
    fn from(value: T) -> Self {
        Self::from_raw(value.into())
    }
}

impl<T> OpenEnum<T> {
    pub fn from_raw(value: i32) -> Self {
        Self {
            raw: value,
            _phantom: PhantomData,
        }
    }

    pub fn to_raw(self) -> i32 {
        self.raw
    }
}

impl<T> OpenEnum<T>
where
    i32: TryInto<T>,
{
    pub fn unwrap(self) -> T {
        let v = self.raw;
        v.try_into()
            .map_err(|_| format!("unknown field value {}", v))
            .unwrap()
    }

    pub fn unwrap_or(self, default: T) -> T {
        self.raw.try_into().unwrap_or(default)
    }

    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce(i32) -> T,
    {
        let v = self.raw;
        v.try_into().unwrap_or_else(|_| f(v))
    }

    pub fn unwrap_or_default(self) -> T
    where
        T: Default,
    {
        self.raw.try_into().unwrap_or_default()
    }

    pub fn known(self) -> Option<T> {
        self.raw.try_into().ok()
    }

    pub fn known_or<E>(self, err: E) -> Result<T, E> {
        self.raw.try_into().map_err(|_| err)
    }

    pub fn known_or_else<E, F>(self, err: F) -> Result<T, E>
    where
        F: FnOnce(i32) -> E,
    {
        let v = self.raw;
        v.try_into().map_err(|_| err(v))
    }
}

impl<T> Message for OpenEnum<T>
where
    T: Debug,
    i32: TryInto<T>,
{
    fn encoded_len(&self) -> usize {
        self.raw.encoded_len()
    }

    fn encode_raw<B>(&self, buf: &mut B)
    where
        B: BufMut,
    {
        self.raw.encode_raw(buf)
    }

    fn merge_field<B>(
        &mut self,
        tag: u32,
        wire_type: WireType,
        buf: &mut B,
        ctx: DecodeContext,
    ) -> Result<(), DecodeError>
    where
        B: Buf,
    {
        self.raw.merge_field(tag, wire_type, buf, ctx)
    }

    fn clear(&mut self) {
        self.raw.clear()
    }
}
